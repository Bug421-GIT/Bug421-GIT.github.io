[
  
  {
    "title": "共享工作者线程",
    "url": "/posts/%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-29 00:00:00 +0800",
    





    
    "snippet": "共享工作者线程​\tShareWorker被多个可信任的执行上下文访问，消息接口外部和内部接口与Worker有些不同。可以减少共享线程计算性消耗的情形，一个ShareWorker可以管理多个同源页面web Socket消息，或成为上下文之间的通信线程。🎈\t在行内脚本中创建的共享工作者线程始终是唯一的：只有标识不存在时，才会创建新线程；否则静默新建失败，且调用connect与已有线程建立连接。​...",
    "content": "共享工作者线程​\tShareWorker被多个可信任的执行上下文访问，消息接口外部和内部接口与Worker有些不同。可以减少共享线程计算性消耗的情形，一个ShareWorker可以管理多个同源页面web Socket消息，或成为上下文之间的通信线程。🎈\t在行内脚本中创建的共享工作者线程始终是唯一的：只有标识不存在时，才会创建新线程；否则静默新建失败，且调用connect与已有线程建立连接。​\t共享工作者线程的标识：解析后的URL、工作者线程名称、文档源new ShareWorker('./worker.js',{name:'foo'})new ShareWorker('https://www.example.com/worker.js',{name:'foo'})🎈\tShareWorker.port：特殊属性，专门用来与共享线程通信的Message🎈\tShareWorker.cennect： 事件​\tworker.port.onmessage &amp; worker.port.start() 与共享线程建立连接时触发；​\t包括MessagePort实例的port数组，可以用于把消息发回父上下文🎈\t共享工作者线程的生命周期： 只要还有一个上下文连接就会持续存在。​\t当线程连接数为0时（关联的所有页面被销毁且没有连接），线程被终止；没有办法以编程的方式终止它 —— 不存在 ShareWorker.teminate()​\t共享线程端口上调用close()时，只要还有一个端口连接，就不会真正终止线程。连接到共享工作者线程​\t每次调用ShareWorker.construct时，无论是否创建新线程，都会触发cennect事件，隐式创建MessageChannel实例并将所有权给ShareWorker实例，这个MessageChannel实例保存在connect事件对象的ports数组中。​\t没有任何事件可以断开与ShareWorker实例的连接。随着页面加入和退出连接，connectPorts集合会受到死端口的影响。一个方法是在页面注销前beforeunlode事情时，明确发送卸载消息，让共享线程有机会清除死端口。"
  },
  
  {
    "title": "专用工作者线程",
    "url": "/posts/%E4%B8%93%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "专用工作者线程​\t用以执行页面主线程之外的其他任务，如发生网络请求、执行文件输入/输出、密集的计算、处理大量的数据，通过与父页面交换消息，完成不适合在主线程执行的任务。（不能直接操作页面DOM元素）又被称为 后台脚本（background script），由初始化线程时提供的脚本控制线程的各个方面，包括生命周期、代码路径、输入输出。// main.jslocation.href; // \"h...",
    "content": "专用工作者线程​\t用以执行页面主线程之外的其他任务，如发生网络请求、执行文件输入/输出、密集的计算、处理大量的数据，通过与父页面交换消息，完成不适合在主线程执行的任务。（不能直接操作页面DOM元素）又被称为 后台脚本（background script），由初始化线程时提供的脚本控制线程的各个方面，包括生命周期、代码路径、输入输出。// main.jslocation.href; // \"https://...com/\"const worker = new Worker(location.href + 'backgroudScript.js');  // worker是工作者线程与主线程通信的连接点​\tnew Worker() 参数必须是一个脚本文件，专用工作者线程只能被生成它的脚本所使用。​\t初始化工作者线程是需要时间的（初始化延迟），且完全独立于main.js； 相对应的worker线程可能还不存在，但在main.js中的Worker对象已经可以使用了，返回Worker {}；信息发送给初始化状态的工作者线程，会先加入队列，等线程进入活跃状态，再把消息传入线程的消息队列。​\t工作者线程不受主线程（document）内容的安全策略限制，因为工作者线程于父文档处于不同的上下文中运行；但如果线程加载的脚本带有全局唯一标识符时，就会受到文档内容安全策略的限制。Worker 对象​\tnew Worker('url') 返回的实例，与新创建的工作者线程通信的连接点，用于与父上下文传递信息（portMessage）、捕获工作线程发出的事件（onMessage）在终止工作者线程之前，实例不会被垃圾回收，也不能通过编程方式恢复对之前Work对象的引用。​\tworkers 和主线程间的数据传递通过这样的消息机制进行——双方都使用 postMessage() 方法发送各自的消息，使用 onmessage 事件处理函数来响应消息处理程序。可以通过worker.addEventLister('on + type',handler) 添加监视器处理            程序关键词      触发类型      原因                  onerror      ErrorEvent类型的错误事件      线程抛出错误              onmessage      MessageEvent类型的消息事件      向父级上下文发送消息              onmessageerror      MessageEvent类型的错误事件      无法反序列化的消息      方法​\t🎈postMessage(message, targetOrigin, [transfer])：通过异步消息事件，向工作者线程发生消息​\t\t\t🎱 message，需要传递的信息（可以是对象、数组等）无需自己序列化​\t\t\t🎱 targetOrigin，指定哪些窗口能接收到消息事件，字符串”*“（表示无限制，不建议依赖使用）或者一个 URI​\t\t\t🎱 transfer，是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。​\t\t\t 监听分发的 message： data（传递过来的对象），origin（发送方的origin信息），source（发送方窗口对象的引用） 可以用来检查消息的发送者的身份​\t🎈terminate()：立即终止工作者进程，没有清理机会，脚步突然停止；锁定消息队列。DedicatedWorkerGlobalScope​\t全局作用域是 DedicatedWorkerGlobalScope 的实例，因其继承自WorkerGlobalScope，所以包含其内部所有属性和方法。可以通过 self关键字 访问全局作用域。​\t与父类不同的属性和方法：​\t🎈name：可选，Worker实例的字符串标识符​\t🎈close()： 与主线程上的worker.terminate()对应​\t🎈importScripts()： 引入任意数量的脚本生命周期​\t非正式地分为三个状态：初始化（initializing）、活动（active）、终止（terminated），对于其他上下文是不可见的。​\t创建之后，专用工作者线程伴随着 页面整个生命期而存在。即使线程执行完毕，其环境仍然会存在，与之关联的Worker对象就不会被回收。​\t关闭线程：  close()：:one: 取消事件循环中的所有任务，并阻止继续添加新任务； :two: 不停止已经存在的同步任务。  terminate： 线程的消息队列被清理并锁住，立即停止且没有清理的机会。// 主线程worker.terminate();// Worker 线程self.close();​\t在整生命周期中，专用工作者线程只关联一个页面——只要页面存在，专用线程就会存在；页面离开，与页面关联的工作者线程标志为终止，且执行立即停止。通信​\t异步、消息完成通信postMessage() —— 临时通信MessageChannel() —— 专用通信​\tChannel Messaging API 的 MessageChannel 接口允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。MessageChannel实例有个两个只读属性，MessageChannel.port1 &amp; MessageChannel.port2，就像电话的两端，使用其中一个端口发送信息，另个端口的监视事件就可以接收到数据。需要借助 postMessage()建立的临时链接 分派端口给子工作者线程。  其他妙用：  ​\t管道通信 —— MessageChannel用法总结 - 全玉 - 博客园 (cnblogs.com)  ​\t其他框架使用场景 —— 浅谈MessageChannel - 掘金 (juejin.cn)// main.jsconst { port1, port2 } = new MessageChannel();const workerA = new Worker('./scriptA.js')const workerB = new Worker('./scriptB.js')// 1. 需要把端口发送给工作者线程中，建立两者的链接workerA.postMessage('connect',[port1]);workerB.postMessage('connect',[port2]);// 2. 控制两个工作者线程传递消息workerA.postMessage('sending')workerB.postMessage('sending')// scriptA.jslet port;self.onmessage = (e)=&gt;{    switch (e.data){        case 'connect':            port = e.ports[0]          \tbreak;       \tcase 'listening'            port.onmessage = (event) =&gt; {console.log(`workerA get the msg from workerB`)}            break;        case 'sending':            port.postMessage = ('listening') // port1 只能向 port2 传递消息\t            break;    }}BroadcastChannel() —— 广播通信​\t同源脚本可以通过BroadcastChannael互相发送、接收信息，如广播通信，需要有实体监听信道才能获得处理。且考虑初始化工作者线程延迟，应该使用计时器延后处理。// main.jsconst channel = new BroadcastChannel('worker_channel');const worker = new Worker('./Worker.js');channel.onmessage = ({data}) =&gt; {    console.log(`heard ${data} on page`);}// 延时，等工作者线程初始化完成setTimeout(() =&gt; channel.postMessage('foo'), 1000 );// Worker.jsconst channel = new BroadcastChannel('worker_channel');self.onmessage = ({data}) =&gt; {    console.log(`heard ${data} in worker`);    channel.postMessage('bar'), 1000 );}数据传输​\t不同线程处于不同的上下文中，它们之间的数据传输会尝试销毁。转移信息的方式有三种：结构化克隆算法（ structured clone algorithm）、可移动对象（transferable object）、共享数组缓冲区（shared array buffers）结构化克隆算法​\t在浏览器后台实现，不可以显式调用。通过postMessage()传递对象时，浏览器遍历该对象，并在目标上下文中生成一个副本（深拷贝），支持除了Symbol之外的所有原型类型。​\t注意点：  可以识别对象包含的循环引用，不会无穷遍历对象  克隆error对象、Function对象、DOM节点会抛出错误  并不总数创建完全一直的副本，对象属性描述符、get() set()、原型链、RegExp.prototype.lastIndex属性不会复制可移动对象​\t把所有权从一个上下文转移到另一个上下文，适用于在不太可能大量复制数据的情况下。​\tpostMessage() 的第二个可选参数是数组，指定转移哪些对象。浏览器遍历消息负载时，根据这个数据检查对象引用，移动而不是复制它们。// main.jsconst worker = new Worker('./worker.js')const arrayBuffer = new ArrayBuffer(32); // 主线程申请32位的数组缓冲区// 第一种，常规化克隆算法worker.postMessage(arrayBuffer);arrayBuffer.byteLength; // 32, 主线程依然留有// 第二种，可移动对象worker.postMessage(arrayBuffer, [arrayBuffer]);arrayBuffer.byteLength; // 0// worker.jsself.onmessage = ({data}) =&gt; {    console.log(arrayBuffer.byteLength;); // 32}​\tworker.postMessage({foo:{bar:arrayBuffer}}, [arrayBuffer]); 嵌套在对象内部可移动对象，包装对象被复制、嵌套对象被转移共享数组缓冲区​\tSharedArrayBuffer作为ArrayBuffer能够在不同浏览器上下文间共享，在使用postMessage时只会传递原始缓冲区的引用 —— 多个上下文（并行线程）分别维护同一个内存块，存在资源争用的风险。可以使用Atomics对象，让工作者线程获得SharedArrayBuffer实例的锁：Atomics.add(view, view下标, argument)，在执行完成全部读写操作后，才允许下一个线程执行操作。// main.jsconst workers = [] // 线程池for(let i = 0; i&lt;4; ++i){    workers.push(new Worker('./worker.js'));}let responseCount = 0; // 获取计算结果for(const worker of workers){    worker.onmessage = () =&gt;{\t\tif(++responseCount === workers.lenght){        \tconsole.log(`Final buffer value: ${ view[0] }`)         }    }}const shareArrayBuffer = new SharedArrayBuffer(4); // 初始化`SharedArrayBuffer`const view = new Uint32Array(SharedArrayBuffer);   // 创建`SharedArrayBuffer`视图view[0] = 1;for(const worker of workers){    woker.portMessage(SharedArrayBuffer);}// Final buffer value: 400001// worker.jsself.onmessage = ({data} =&gt; {\tconst view = new Uint32Array(data);    // 执行100万次操作    for(let i = 0; i &lt; 1E6; ++i){\t\t// view[0] += 1;  可能产生脏读        Atomice(view, 0, 1);    }})线程池​\t使用固定数量的线程活动，根据线程状态空闲与否分配任务。线程在执行任务时，会被标记为忙碌状态，直至通知线程池空闲时，才会被安排新的工作。这些活动线程被称为“线程池”。​\tnavigator.hardware Concurrency属性返回 系统可用的核心数量，最好以此作为线程池大小的上限。​\t线程策略：每个线程执行相同的任务，但具体执行什么任务由参数个数控制。线程执行耗时计算后返回结果，线程池在将其他工作分配给线程执行。eg：​\t定义TaskWorker类：跟踪线程是否正忙于工作、管理进出线程的信息和事件。class TaskWorker extends Worker{    constructor(notifyAvailable, ...workerArgs){        super(...workerArges);                this.available = false;        this.resolve = false;        this.reject = false;                this.notifyAvailable = notifyAvailable; // 空闲时，向线程池发送信号，以分配任务        this.onmessage = () =&gt; this.setAvailable(); // 线程完成初始化时，向线程池发送信息    }    dispatch({resoleve, reject, postMessageArgs}){        this.available = false;        this.onmessage = ({data}) =&gt; {            resolve(data);            this.setAvailable();        }        this.onerror //... 调用 reject()、setAvailable()        this.postMessageArgs(...postMessageArgs);    }    setAvailable(){ // 初始化线程，通知线程池        this.available = false;        this.resolve = false;        this.reject = false;        this.notifyAvailable();             }}​\t定义workerPool类，使用TaskWorker类：管理未执行的任务队列，并负责关闭线程class WorkerPool {    constructor(poolSize, ...workerArgs){        this.taskQueue = [];        this.workers = [];        // 初始化线程池        for(let i = 0; i &lt; poolSize; ++i){            this.workers.push(                // 将可分配的线程推入数组            \tnew TaskWorker(() =&gt; this.dispatchIfAvaliable(), ...workerArgs);            )        }        // 初始化任务队列        enqueue(...postMessagee){            return new Promise((resolve, reject) =&gt; {                this.taskQueue.push({resolve, reject});                this.dispatchIfAvaliable();            })        }        // 将任务分配给线程        dispatchIfAvaliable(){            if(!this.taskQueue.lenght) return; // 没有可以用的线程            for(const worker of this.workers){                if(worker.avaliable){                    let a = this.taskQueue.shift();                    worker.dispatch(a);                    break;                }            }        }        // 终止所有工作者线程        close(){            for(const worker of this.workers){                worker.terminate();            }        }    }}​\t使用案例： 计算1000万个浮点数之和// worker.jsself.onmessage = ({data}) =&gt; {    let sum = 0;    let view = new Float32Array(data.arrayButter);        for(let i = data.arrayButter; i&lt;data.endIdx; ++i){        sum += view[1];    }    self.postMessage('ready');}// main.jsconst totalFloats = 1E8; //1000万const numTasks = 20; // 20个任务const floatPerTask = totalFloats / numberTasks; // 每个线程计算数const numWorker = 4; // 4个线程// 创建线程池const pool = new WorkerPool(num, './worker.js');// 填充浮点数let arrayBuffer = new ShareArrayBuffer(4 * totalFloats);let view = new Float32Array(data.arrayButter);for(let i = 0; i &lt; totalFloats; i++){    view[i] = Math.random();}let partialsumPromises = [];for(let i = 0; i&lt; totalFloats; i += floatPerTask){    partialSumPromises.push( // 维护一个promise队列    \tpool.enqueue({ // 添加进线程池任务队列            startIdx: i,            endIdx: i + floatPerTask,            arrayBuffer        })    )}// 等待promise队列全部任务结束Promise.all(partialSumPromises)\t.then(partialSum =&gt; partialSum.reduce((prev,cur) =&gt; prev + cur))\t.then(finalSum =&gt; console.log(finalSum))"
  },
  
  {
    "title": "工作者线程",
    "url": "/posts/%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-20 00:00:00 +0800",
    





    
    "snippet": "工作者线程​\t允许把主线程的工作转移到独立的实体，而不改变现有的单线程模式。浏览器主线程负责与处理用户事件和页面绘制等。​\tJavaScript环境实际是运行在托管操作系统的虚拟环境。每个页面都有自己的环境，内存、事件循环、DOM等等，不会影响到其他页面。所有页面环境都是并行处理的。​\t使用工作者线程，可以在原始页面环境之外，在分配一个完全独立的二级子环境，与主线程不能直接通信只能使用 消息...",
    "content": "工作者线程​\t允许把主线程的工作转移到独立的实体，而不改变现有的单线程模式。浏览器主线程负责与处理用户事件和页面绘制等。​\tJavaScript环境实际是运行在托管操作系统的虚拟环境。每个页面都有自己的环境，内存、事件循环、DOM等等，不会影响到其他页面。所有页面环境都是并行处理的。​\t使用工作者线程，可以在原始页面环境之外，在分配一个完全独立的二级子环境，与主线程不能直接通信只能使用 消息 完成，不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行。工作者线程相对较重，通常占用较大内存，不建议大量使用；调度之间存在性能损耗，所以应该谨慎使用线程，给常驻的、启动成本高的、计算量较大的工作分配。​\t🎈\t以实际线程实现的，对应着底层的线程。​\t🎈\t环境内的指令是可以并行执行的​\t🎈\t可以共享某些内存，但不完全共享全部内存。可以使用sharedArrayBuffer在多个环境间共享内容 —— 使用Atomics接口实现并发控制，其他数据进出线程需要移动或者复制。​\t🎈\t工作者线程不一定在同一个进程里，共享工作者线程和服务工作者线程就可能使用独立的进程。​\t存在限制：​\t🚫\t工作者线程（顶级工作者线程和子工作者线程）的脚本文件只能从父页面相同的源加载。可以加载、执行其他非同源的脚步（importScript()）。​\t🚫\tWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。​\t🚫\tWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://）。​\t🚫 \t无法读取、操作主线程所在网页的 DOM 对象、window对象等​\t子工作者线程，确保并行计算的投入的收益 &gt; 多个子线程计算成本；子工作者线程的脚本路径根据父工作者线程解析。本地文件初始化工作者线程​\t工作者线程需要基于脚本文件创建，但不意味着该脚本必须是远程资源。可以利用Blob对象的URL在行内创建。 可以更快速初始化工作者线程，没有网络延迟。​\tBlob 对象，二进制类型的大文件，是不可变、原始数据的类文本对象；可以以文本、二进制格式读取，或转为readable Stream。  new Blob(array,{option})：          array，可迭代对象，Array、DataView、Blob、字符串或他们的混合，将被放入Blob中      option，指定type（指定数据的MIME类型）和endings（包含结束符/n字符串将如何被写入）两个属性的对象                  MIME（多用途互联网邮件扩展类型 Multipurpose Internal Mail Extensions)，如text/html image/png text/plain text/script          endings:transparent 默认值，保存不变          endings:native 更改为更适合宿主系统的换行符。                      URL.createObjectURL(object) —— URL.revokeObjectURL(objectURL)          传入 File / Blob / Medioa 对象 用以创建 URL      使用URL.createObjectURL(object)创建对象URL，代表对象存在引用，会影响内存垃圾回收，应该在合适时机使用URL.revokeObjectURL(objectURL) 释放URL对象      Web Worker中可以用，在Service Worker中不可以用，可能导致内存泄漏。      // 函数后序列化传入，在父上下文中定义，在子上下文中执行function Fibonacci(n) {    return n&lt;1 ? 0 : n&lt;2 ? 1 : Fibonacci(n-1) + Fibonacci(n-2)}// 字符串const workerString = `\tself.onmessage = ({data}) =&gt; console.log(data);\tself.postMessage((${ Fibonacci.toString() })(9))`const workerBlob = new Blob([workerString],{type: 'text/javascript'})const workerBlobURL = URL.createObjectURL(workerBlob);const worker = new Worker(workerBlobURL)worker.onmessage = ({data}) =&gt; console.log(data) // 34 接收worker回传数据worker.postMessage('hi,just say something?'); // hi,just say something? 向worker发生数据// 缩写：const worker = new Worker(URL.createObjectURL(new Blob([workerString])));在工作者线程中动态执行脚本​\t使用importScripts() 方法编程方式，不一定按顺序加载、按顺序同步执行任意脚本，可以接收任意数量的参数  无论是什么类型文件，都会当成JavaScript解析，所以需要是有效的 JavaScript MIME 类型，如text/javascript  在工作者线程内部可以请求任何来源的脚本（没有CORS限制）  加载成功后，每个脚本中的全局上下文都能够在 Worker 线程中使用 —— 共享作用域  如果脚本无法加载，将会抛出错误，并且之后的代码也无法执行了// main.jsconst worker = new Worker('./worker.js',{name:'foo'});// worker.jsimportScripts('./scriptA.js','./scriptB.js');const workerToken = 'worker.js'console.log(`in worker.js,, name is ${ self.name }, workerToken is ${ workerToken }`)// scriptA.jsconsole.log(`in scriptA.js, name is ${ self.name }, workerToken is ${ workerToken }`)// scriptB.jsconsole.log(`in scriptB.js, name is ${ self.name }, workerToken is ${ workerToken }`)处理工作者线程错误​\t抛出错误的工作者线程，可以不打断父线程的执行。try/catch不能捕获到错误，不过依然会冒泡到工作者线程的全局上下文，因此可以在Worker对象上设置 错误事件监听器 才可以访问到。// main.js const worker = new Worker('./woker.js')worker.onerror = console.log; // isTrusted: true, message: 'Uncaught Error: errormessage',....// woker.jsthrow Error('errormessage')"
  },
  
  {
    "title": "11. 垃圾回收机制",
    "url": "/posts/11.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-09-05 00:00:00 +0800",
    





    
    "snippet": "  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾        两种常用方法    ​\t垃圾回...",
    "content": "  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾        两种常用方法    ​\t垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数    1. 标记清除法（大部分浏览器） Mark-Sweep    两个阶段：                  标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达        （标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）                    清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）              优点：实现简单    缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）    优化方案：**标记-整理法  Mark-Compact **    ​\t清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理    2. 引用计数法 Reference counting    ​\t追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：          赋值给引用值时，引用数 +1；      保存引用的变量被覆盖了，引用数 -1        缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。       b 循环引用无法收回，导致内存泄漏。    3. 循环引用    在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 循环引用 的问题：          BOM 和 DOM 中对象是C++实现的COM对象，使用 引用计数 实现垃圾回收。即使引擎使用 标志清理，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。        let element = document.getElementById('one'); // com对象let obj = new Object() // 原生obj对象obj.element = element;element.obj = obj;   // 避免：确保两者没有联系obj.element = null;element.obj = null;        在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。    分代式垃圾回收机制          新生代：对象存活时间短，通常支持 1~8M      老生代：对象存储 存活时间长、常驻内存的对象        两个内存区域回收频率不同，V8才有两个垃圾回收器管控：        新生代垃圾回收    ​\tCheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为使用区（From 空间）。一个处于闲置状态的空间称为空闲区（To 空间）    垃圾回收机制——翻转 （Scavenge）          先对使用区中的活动做标记      标记完成后，将使用区的活动对象复制进空闲区并进行排序      将原先使用区对象占用的空间释放      最后进行角色互换，把空闲区变为使用区，使用区变为空闲区        缺点：由于只能使用堆内存的一半，所以不适用大规模的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）    并行回收    Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。    那当GC时间过长就会造成页面卡顿问题。    那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过    并行回收机制：引入多个辅助线程来同时处理新生代对象空间就采用并行策略。在垃圾回收过程中，    启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22    由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。    新生代何时会到老生代          多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理      复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配        老生代垃圾回收    ​\t老生代数据大多是存活的对象，不需要时常更新，可以使用 标记清收法 回收。在V8中使用 标记整理法 解决标记清除后产生的大量内存碎片。    增量标记 （incremental marking）    ​\t代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题          一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。      应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成              存在问题：      ​\t小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法      ​\t如何进行下一次小GC 标记？—— 惰性清理      ​\t如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障        三色标记法          黑色表示对象自身及对象的引用都被标记（已检查状态）      白色表示未被标记的对象（初始状态）      灰色表示自身被标记，自身的引用未被标记（待检查状态）        执行流程：          初始所有对象都是白色      从root对象开始、标记为灰色，并推入标记工作表中；      当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色      将自身的下一个引用对象标志为灰色        一直执行，直到没有可以被标记为灰色的对象，剩下的白色对象都是不可达的，进入清除阶段；    恢复时，从灰色标记对象开始执行    写屏障    目的：          解决黑色对象在程序执行中被新添加引用      已经标记黑色的被引用对象不再被引用了        写屏障就有了以下两个变化：    ​\t1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。          Write-barrier 机制强制不变黑的对象指向白色对象。                  这个也被称作强三色不变性。所以          一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色          从而保证下一次增量 GC 标记阶段可以正确标记                      惰性清理 （lazy sweeping）    ​\t增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。    V8 script 隐藏类    JS 性能优化 —– V8 隐藏类    ​\t“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中一次性声明所有属性    ​\t“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 = null    优化程序回收，提高性能          手动回收（不建议）：window.ColloectGarbage()（IE）、window.opera.collect()（opera7以上）立即启动垃圾回收；      解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。      1. 使用 块级作用域 ，尽早让垃圾回收程序介入。      "
  },
  
  {
    "title": "10. 事件",
    "url": "/posts/10.%E4%BA%8B%E4%BB%B6/",
    "categories": "JavaScript, Event",
    "tags": "javascriptBase",
    "date": "2022-09-02 00:00:00 +0800",
    





    
    "snippet": "  JavaScript 与 HTML 交互通过 事件 实现；代表文档document 或 浏览器窗口中某个意义的时刻  监听器 ，订阅事件（处理程序） 监听事件发生时执行  触发事件以测试：dispatchEvent()事件流​\t事件流描述了页面接受事件的顺序  IE 支持事件冒泡流          IE事件流被称为事件冒泡      事件从最具体的元素（文档树中最深的节点）开始出发，然...",
    "content": "  JavaScript 与 HTML 交互通过 事件 实现；代表文档document 或 浏览器窗口中某个意义的时刻  监听器 ，订阅事件（处理程序） 监听事件发生时执行  触发事件以测试：dispatchEvent()事件流​\t事件流描述了页面接受事件的顺序  IE 支持事件冒泡流          IE事件流被称为事件冒泡      事件从最具体的元素（文档树中最深的节点）开始出发，然后向上传播到没有那么具体的元素（Document）      IE5.5及早期版本跳过&lt;html&gt; (&lt;body&gt; -&gt; &lt;document&gt;)        Netscape Comuunicator 支持事件捕获流          事件捕获：为在事件达到最终目标前拦截事件（新版本浏览器都支持事件捕获，但旧版本不支持）      最不具体的节点最先收到事件，而具体的节点最后收到事件；      从window对象开始捕获对象，DOM2 Events从document开始        DOM 事件流          DOM2 Events 规定事件分为三个阶段；事件捕获、到达目标、事件冒泡      IE9 之后的浏览器都支持DOM事件流，但会在捕获阶段在事件目标上触发事件 —— 事件目标有两个时机处理事件。      事件处理程序​\t为响应事件而调用的函数被称为 事件处理程序（事件监听器），名字常以on开头，集合多个处理程序名称以handle结尾HTML​\t属性值是JavaScript代码，需要经过转义的情况下使用HTML语法字符&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"console.log('Clicked!')\"/&gt;&lt;!-- 转义 添加空格 --&gt;&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"console.log('&amp;quote;Clicked!&amp;quote;')\"/&gt;&lt;!-- 调用其他地方脚本 --&gt;&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"showMessage()\"/&gt;💬 调用外部脚本showMessage，存在以下特殊的局部变量：  特殊局部变量 event对象  this值相当于事件的目标元素  扩展作用域链：document 和 元素自身成员💬 在 HTML 中指定事件处理程序，存在以下问题：      作用域扩展在不同浏览器中可以导致不同结果，范围无限定的对象可能导致错误        调用时机：元素生成在前，监听器定义在后，用户已经交互过，不会触发监听器，会发生错误；    为此，HTML 事件处理程序会封装到try/catch块中，使这种情况静默失败 —— 捕获在先，元素响应在后  &lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"try{                                                    showMessage();                                                   } catch(ex){}                                                                                             \"/&gt;DOM0​\t将一个函数赋值给（DOM元素的）一个事件处理程序的属性 —— JavaScript指定之前必须先取得操作对象的引用​\t在运行之后才会给事件处理程序赋值，注册在事件流的冒泡阶段let btn = document.getElementById('myBtn'); btn.onclick = function(){ \t// 函数被视为元素的方法，在元素作用域中运行；this = 元素    console.log('Clicked!')}// 将属性值设置为null，移除DOM0方式添加的事件处理程序btn.onclick = null;DOM2​\t提供两个方法处理程序：新增 addEventListener() 移除removeEventListener，暴露在所有DOM节点上。​\t接受三个参数：事件名（click）、事件处理函数、布尔值（false 默认值，冒泡阶段调用；true 捕获阶段调用）​\t使用addEventListener添加的监视器，必须使用removeEventListener并传入添加时相同参数来移除 —— 匿名函数无法移除。​\t主要优势：可以为同一个事件添加多个事件处理程序，顺序触发。​\t事件处理程序通常会被添加到事件流的冒泡阶段（主要原因是跨浏览器兼容性好），注册到捕获阶段参与于事件到达指定目标之前拦截。IE​\t提供两个方法处理程序：新增  attachEvent 移除 detachEvent，暴露在所有DOM节点上。​\t接受两个参数：事件名（on+ click）、事件处理函数 —— IE8及之前只支持事件冒泡，所有会添加到事件冒泡阶段。​\t使用 attachEvent添加的监视器，必须使用detachEvent并传入添加时相同参数来移除、或传入监视器引用—— 匿名函数无法移除。​\t与DOM0区别在于：this = window，程序在全局作用域中运行；​\t同DOM2同样可以为同一个事件添加多个事件处理程序，顺序方向触发跨浏览器事件处理程序var EventUtil = {    addHandler: function(element, type, handler){        if(element.addEventListener){ // DOM2            element.addEventListener(type, handler, false)        }else if(element.attachEvent){ // IE            element.attachEvent('on'+type, handler)       \t}else{ // DOM0            element['on'+type] = handler;        }    },    removeHandler: function(element, type, handler){        if(element.removeEventListener){ // DOM2            element.removeEventListener(type, handler, false)        }else if(element.delactEvent){ // IE            element.delactEvent('on'+type, handler)       \t}else{ // DOM0            element['on'+type] = null;        }    },}❗ 依然未解决以下问题：  IE的作用域问题  多个事件处理程序顺序问题  DOM0 只支持一次添加一个事件处理程序事件对象​\t事件发生时，所有相关信息会存储在event对象中。包含：事件元素、事件类型、可能与特点事件相关的任何其他数据。DOM 事件对象​\t在DOM中（无论是DOM0 或 DOM2），event对象是传递给事件处理程序的唯一参数。​\tevent对象只在事件处理程序执行期间存在，执行完毕就销毁。包含以下公有的属性和方法：  target 相关的属性​\t在事件处理程序内部，this = currentTarget，而target只包含事件实际目标。​\t如果处理程添加到了意图的目标，则this = currentTarget = target  阻止默认动作​\tpreventDefault() 用于阻止特定事件的默认动作，且不影响事件后续传播；前提是其对象的cancelable = true（允许取消）​\tstopPropagation() 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获和冒泡。  eventPhase 属性可以确定事件流当前所处的阶段：      1 —— 事件在捕获阶段被调用        2 —— 事件在目标上被调用        3 —— 事件在冒泡阶段被调用  IE 事件对象​\tIE中的事件对象event是基于事件处理程序被指定的方式以不同方式访问。// DOM0方式指定，event对象是window对象的一个属性。var btn = document.getElementById('myBtn');btn.onclick = function(){\tlet event = window.event; // event.type = 'click'    this === event.srcElement; // true 运行在函数内部}// IE 方式指定，event对象仍然是window对象的属性var btn = document.getElementById('myBtn');btn.attachEvent('onclick',function(event){    event.type; // 'click'    this === event.srcElement; // false 运行在全局作用域下})&lt;!-- HTML 方式指定，同样可以使用event对象访问 --&gt;&lt;input type=\"button\" value=\"点击触发事件\" onclick=\"console.log(event.type)\"/&gt;       this的指向问题    事件处理程序的作用域取决于指定的方式，所以this值并不总是等于事件目标。在IE事件对象中存在一个属性srcElement，只读，指向事件目标（同DOM中的target）可以代替this。        阻止默认动作  ​\treturnValue = false 等同于 DOM中的preventDefault()，取消事件默认行为。​\t`\tcancelButton = true` 属性阻止事件冒泡（IE 中只有冒泡）。​\tstopPropagation() 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获和冒泡。跨浏览器事件对象var EventUtil = {    // addHandler()     getEvent: function(event){        return event? event : window.event;    },    getTarget: function(event){        return event.target || event.srcElement;    },    preventDefault: function(event){        if(event.preventDefault) event.preventDefault();        else\tevent.returnValue = false;    },    // removeHandler()}内存和性能​\t在JavaScript中，页面的处理程序数量与页面整体性能相关。​\t:one: 每个处理程序都是一个对象，都占用内存空间；​\t:two: 处理程序需要访问DOM次数造成页面交互延长；​\t:three: 不正当清理处理程序，会导致DOM元素被引用次数过多而无法释放内存。事件委托​\t给所有元素的 共同父节点添加一个事件处理程序，利用冒泡向上传递的性质，根据传入的事件类型决定执行的处理程序。​\t👍随时可用。只有页面渲染出可以交互的元素，可以无延迟起作用（无需要等待DOMContentLoaded和load事件）​\t👍节省引用、代码数量。减少整个页面需要的内存，提供性能。删除事件处理程序​\t直接删除带有事件处理程序的元素，因为存在着元素的引用和程序的引用，所以不会被垃圾收集程序正常清理。// 正确处理：let btn = document.getElementById('myBtn');btn.onclick = funciton(){    //    btn.onclick = null; // 删除事件处理程序    document.getElementById('myDiv').innerHTML = '父节点替换掉按钮的内容'}​\t页面卸载后，事件处理程序没有被清理，则仍然会驻留在内存中；随着页面每次加载、卸载，越来越占用内存。应该在 onunload 之前，删除事件处理程序；在onload 事件处理程序中做了什么，就应该在 onunload事件处理程序中恢复。"
  },
  
  {
    "title": "9. Proxy & Reflect",
    "url": "/posts/9.Proxy&Reflect/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-09-01 00:00:00 +0800",
    





    
    "snippet": "Proxy &amp; Reflect  代理 — 改变某些操作的默认行为， — Reflect确保原有默认行为正常                              [实现元编程]([Reflect Metadata          深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-bo...",
    "content": "Proxy &amp; Reflect  代理 — 改变某些操作的默认行为， — Reflect确保原有默认行为正常                              [实现元编程]([Reflect Metadata          深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-book-chinese/tips/metadata.html#基础)) — 对编程语言进行编译（在语言层面编程）                      var proxy = new Proxy( target, handler )          target — 所要拦截的 目的对象      handle — 定制拦截对象        Proxy.prototype = undefined ，所以不能用instanceof操作符  不可配置、不可读写的属性不能代理var proxy = new Proxy({},{    get:function(target, key, receiver){ // obj.p时，触发p作为target        return Reflect.get(target, propKey, receiver);    },    set:function(target, key, value, receiver){        return Reflect.set(target, propKey, value, receiver);    }})let obj = Object.creat(proxy); // 将proxy添加到obj的原型上，实现Proxy的继承，读取【原型属性】会被拦截var object = {proxy: new Proxy(target, handler)}; // object 可以调用proxy要使Proxy起作用，必须针对Proxy实例proxy操作，而不是针对目标对象操作 —— 直接操作会绕过代理施予的行为const targetObj = {    where:function(){        console.log(\"I am in target\");    }};var proxy = new Proxy(targetObj,{    get:function(target, propKey){        if(propKey === \"where\"){ // targetObj 里面的属性名 === where进行拦截            console.log(\"I am in proxy\");        }        return target[propKey]; // 返回targetObj原有的属性    }});proxy.where();  //I am in proxy + I am in targettarget.where(); //I am in target若handler是一个空对象，则没有任何拦截效果，访问 Proxy = 访问 targetReflect​\tReflect一个全局内置对象，将默认操作从处理器转发到 target。处理器对象中所有可以捕获的方法都有对应的反射（Reflect）API方法。Reflect 与 targe 方法具有相同的名称和签名属性，且具有相同的方法行为。​\tReflect不是一个函数对象、构造函数，无法像对象一样调用和使用new创建实例；内部所有的属性和方法都是静态。// 1. 安全调用函数// 使用 apply 调用函数时，target 可能自定义了自己的 apply 属性，可以使用 Function.prototype 规避这个问题Function.prototype.apply.call(Math.floor, undefined, [1.75]); // 1Reflect.apply(Math.floor, undefined, [1.75]); // 1;​\t根据一些反射方法返回”状态标记”的布尔值，可以检查意图操作是否成功。但如果是语法出现问题，无法拦截错误。// 2. 使用“状态标志”替换属性定义异常捕获处理try{    Object.defineProperty(obj, prop, attr);}catch(e) {    // Fail}\t// // if (Reflect.defineProperty(obj, prop, attr)) if (Reflect.defineProperty(o,'foo',{value:'bar'})){    console.log(\"1\")}else{    console.log(\"2\")}            Reflect API      返回值      与操作符相比                  Reflect.defineProperty()      提供状态标志                     Reflect.deleteProperty()      提供状态标志      代替delete操作符              Reflect.setPrototyoeOf()      提供状态标志                     Reflect.has()             代替in、with操作符              Reflect.set()      提供状态标志      代替=操作符              Reflect.get()             代替对象属性访问操作符              Reflect.preventExtensions()      提供状态标志      类似Objext.preventExtensions（可强转为对象），但操作对象只能是对象              Reflect.construct()             代替new操作符      // 3.Reflect API 与 一等函数 替换使用Reflect.has(Object, \"assign\"); // true\"assign\" in Object // true​\t在代理中简化使用Reflectconst handler = {    get() {        const someString = \"修饰返回值\"        return Reflect.get(...arg) + someString;    }}new Proxy(target, handler)const handler = {    get:Reflect.get;}new Proxy(target, handler)// 捕获所有方法，并转发给对应反射API的空代理，可以不定义Handler，直接使用Reflectnew Proxy(target, Reflect)this的问题  目标对象内部的this，指向Proxy代理          Proxy无法代理目标对象      通过this区分的内部函数，指向proxy后可能取不到      【使用目标对象调用自身属性方法】Reflect.get()        拦截函数的this，指向handler对象getget(target, propKey, receiver)  propKey — 属性名  receiver — 操作行为所针对的对象 [可选] （）  目标对象不存在的属性，访问时抛出指定的错误  数组读取负数的索引  读取属性返回函数，实现链式操作  生成各种DOM节点的通用函数 目标对象不存在的属性，访问时抛出指定的错误// 目标对象不存在的属性，访问时抛出指定的错误var person = {    name: '张三'}var proxy = new Proxy(person, {    get: function (target, propKey) {        if (propKey in target) {            return target[propKey]        } else {            throw new ReferenceError(`属性名${propKey}不存在`)        }    }})proxy.nameproxy.age数组读取负数的索引// 数组读取负数的索引function createArray(...elements){    let handle = {        get(target, propKey, recevier){            let index = Number(propKey);            if(index &lt; 0) propKey = String(target.length + index); // 倒序            return Reflect.get(target, propKey, recevier) // 结束代理处理，使用target原生处理函数        }    }    let target = [];    target.push(...elements);    return new Proxy(target, handle)}let arr = createArray('a','b','c','d','f');console.log(arr[-1]); // f读取属性返回函数，实现链式操作var pipe = function(value){var funcStacke = []; // 函数堆var oproxy = new Proxy({},{    get: function(pipObject, fnName){        /* 如果当前函数为get，则链式传递到最后一个函数，返回堆栈内函数的计算结果           否者，不为get，链式传递后面还有函数，将当前函数推入funcStrcke，返回Proxy，继续推入函数 */        if(fnName === 'get') {            /* reduce 中的每一项都递归传入，            指定val（第一个参数）为pipe的参数；fn是funcStacke的第二个函数，            返回计算的结果值 */            return funcStacke.reduce(function(val, fn){                return fn(val)            },value)}        funcStacke.push(window[fnName]); //        return oproxy;    \t}\t});    return oproxy;}var double = n =&gt; n*2;let number = pipe(2).double.get;// 1.pipObject = {}; fnName = double,  funcStacke = ['n =&gt; n*2']// 2.pipObject = {}; fnName = get;      console.log(number);生成各种DOM节点的通用函数// 1. target:obj -- property:p -- attrs:href: '//example.com' -- children: ['Mark']// 2. target:obj -- property:a -- attrs:{} -- children:['The web']// 3. target:obj -- property:ul - attrs:{} -- children:['Food']// 4. target:obj -- property:li - attrs:{} -- children:[\"…actually that's it\"] // 5. target:obj -- property:li - attrs:{} -- children:[li, li, li]    // 6. target:obj -- property:li - attrs:{} -- children:['Hello, my name is ', a, '. I like:', ul] const dom = new Proxy({}, {    get(target, property) {        return function (attrs = {}, ...children) {            const el = document.createElement(property); // 传入的属性值创建节点            for (let prop of Object.keys(attrs)) {                el.setAttribute(prop, attrs[prop]); // 节点添加属性            }            for (let child of children) {                 if (typeof child === 'string') { // 孩子节点是字符串，添加节点文字                    child = document.createTextNode(child);                }                el.appendChild(child); // 父节点添加孩子            }            return el;        }    }});const el = dom.p({},                 'Hello, my name is ',                 dom.a({ href: '//example.com' }, 'Mark'),                 '. I like:',                 dom.ul({},                        dom.li({}, 'The web'),                        dom.li({}, 'Food'),                        dom.li({}, '…actually that\\'s it')                       )                );document.body.appendChild(el);set​\tset(target, propKey, propValue, receiver)  propKey — 属性名  propValue — 属性值  数据验证 — 不符合要求的设定值，抛出异常  数据绑定 — 当对象发送变化是，自动更新DOM  结合set、get，实现属性名第一个字符使用下划线，不允许外部使用数据验证 — 不符合要求的设定值，抛出异常let validator = {    set: function (obj, prop, value) {        if (prop === 'age') {            if (!Number.isInteger(value)) {                throw new TypeError('The age is not an integer');            }            if (value &gt; 200) {                throw new RangeError('The age seems invalid');            }        }        // 对于满足条件的 age 属性以及其他属性，直接保存        obj[prop] = value;        return true;    }};let person = new Proxy({}, validator);person.age = 100;person.age = 'young' // 报错person.age = 300 // 报错数据绑定 — 当对象发送变化是，自动更新DOM&lt;body&gt;    &lt;input type=\"text\" id=\"model\"&gt;    &lt;p id=\"words\"&gt;222&lt;/p&gt;&lt;/body&gt;const model = document.getElementById(\"model\");const words = document.getElementById(\"words\");const proxy = new Proxy({}, {    get(target, propKey, receiver) {        return Reflect.get(target, propKey, receiver)    },    set(target, propKey, propValue, receiver) {        if (propKey === 'key') { // 修改的属性名是key，则修改对应的值            model.value = propValue;            words.innerHTML = propValue        }        return Reflect.set(target, propKey, propValue, receiver)    }})// 给输入框添加点击事件model.addEventListener('keyup', (e) =&gt; {    proxy.key = e.target.value;})结合set、get，实现属性名第一个字符使用下划线，不允许外部使用const handler = {    get(target, key) {        invariant(key, 'get');        return target[key];    },    set(target, key, value) {        invariant(key, 'set');        target[key] = value;        return true;    }};function invariant(key, action) {    if (key[0] === '_') {        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);    }}const target = {};const proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = 'c'  // Error: Invalid attempt to set private \"_prop\" propertyapply(target, this, args)​\tapply(target, this, args){}      this，目标对象的上下文        args，目标对象参数数组    拦截函数 — call、apply — 触发调用  has (target， key)  key ，需要查询的属性名  拦截 HasProperty()          has() 不判断一个属性是对象自身的，还是继承的      只对 in运算符生效，而不对for... in生效      construct (target, args, newTarget)  newTarget， 创建实例对象，new命令作用的构造函数  :warning: target必须是函数  :warning: 返回的必须是对象存在问题目标对象方法依赖于调用对象标识const wm = new WeakMap() // 类外部定义，所有实例共享一个 WeakMapclass User{    constructor(id){        wm.set(this,id)    }    get id(id) return wm.get(this);    set id(newid) \twm.set(this,id)    // ... get() set()}const user = new User(123);const userProxy = new Proxy(user,{}); // wm: {user {}: 123}wm.get(User)\t// undefineduser.id \t\t// 相当于 wm.get(user), 返回 123userProxy.id \t// 相当于 wm.get(userProxy), 返回 undefined​\twm.get(this) 方法依赖于调用的对象，暴露了this指向问题，使得返回值不正确；把代理User实例改为代理User类本身，再创建代理实例，就会以代理实例作为WeakMap的键了。const UserClassProxy = new Proxy(User,{});const proxyUser = new UserClassProxy(456);const proxyUser2 = new UserClassProxy(789)// wm: WeakMap {User =&gt; 456, User =&gt; 789}wm.get(User) // undefineduser \t// undefined 类没有创建实例，而是直接使用类代理，创建代理的实例proxyUser.id // 456proxyUser2.id // 789代理与内部槽位​\t当ECMAScript内置类型可能会依赖某些代理无法控制（访问器无法访问到的方法）的机制，会导致使用代理调用时出现问题。​\t例如Date 类型方法的指向依赖this值上的内部槽位[[NumberDate]]，值不能通过普通的get()和set()操作访问到，且代理对象不存在这个内部槽位。于是代理拦截后本应该转发给目标对象的方法，会抛出异常 TyperError。const target = new Date();const proxy = new Proxy(target, {});proxy instanceof Date; // trueproxy.getDate(); // 'this' is not a Date object;"
  },
  
  {
    "title": "8. 闭包",
    "url": "/posts/8.%E9%97%AD%E5%8C%85/",
    "categories": "JavaScript, 闭包",
    "tags": "javascriptBase",
    "date": "2022-08-29 00:00:00 +0800",
    





    
    "snippet": "闭包作用域  在执行上下文中，存在两种变量：  变量对象（全局变量）：全局上下文，在代码执行期间始终存在，保存在scope-script里  活动对象（局部变量）：执行上下文，只在函数执行期间存在  生成的时机：  在定义函数时，会为它创建作用域链，申请空间，预装载全局变量，并保存在内部的[[scope]]中。  预编译不会执行函数里面的内容  在调用函数时，创建相应的执行上下文，并通过复制...",
    "content": "闭包作用域  在执行上下文中，存在两种变量：  变量对象（全局变量）：全局上下文，在代码执行期间始终存在，保存在scope-script里  活动对象（局部变量）：执行上下文，只在函数执行期间存在  生成的时机：  在定义函数时，会为它创建作用域链，申请空间，预装载全局变量，并保存在内部的[[scope]]中。  预编译不会执行函数里面的内容  在调用函数时，创建相应的执行上下文，并通过复制函数的[[scope]]创建其作用域链；并创建函数的活动对象，推入作用域链的前端。​\t作用域链：包含指针的列表，执行每一个变量对象；标识所在位置越深，读写速度就会越慢（全局总是在最末端）​\t在一个函数内部定义的函数，会把其包含函数的活动对象（所有外部的局部变量）添加到自己作用域链中​\t多次调用同一个函数，占用不同的空间，多个内存地址，之间的数据不会共享函数生命周期延长      普通函数创建实例    return 内部函数（引用类型）给外部使用let a = func()。只要外部使用不停止，函数就不会被回收    外部变量a重复调用时，函数变量内部变量值不变，在原有的基础上继续进行处理；而不是重新开始    使用另一个外部变量调用函数，又会重新在内存空间开辟新地址，所有变量初始化（函数调用开辟新开机）；此变量之后的重复使用，在原有的基础上继续处理（变量保存函数空间的地址）        构造函数，默认返回引用；每个实例一个内存空间  什么是闭包闭包（Closure）：指一个函数可以访问到其外层函数中的数据（作用域）—— 闭包是函数作用：  延长变量的生命周期：全局变量不会被回收  创建私有变量空间：私有变量不会污染全局弊端：闭包会保留包含它们函数的作用域，比其他函数更占用内存暴露一个访问器，返回出去的变量可通过该函数间接范围；在javascript语言中，内层函数可以访问到外层函数的数据（即使外层函数不再存在引用），即为闭包​\t内部函数永远不能直接访问到外部函数 this 和 arguments 这两个变量。箭头函数中的this非严格模式下执行window；严格模式下值为undefined。想要访问，可以使用 变量存this，将其引用保存到闭包能够访问得到的变量中。window.getIdentity = \"the window\"let object = {    identity : \"the object\",    getIdentity(){        return function(){            this.identity;  // \"the window\" 内部函数无法访问外部函数的this，内部this不存在这个变量往全局找        }    }}let object = {    identity : \"the object\",    getIdentity(){        let that = this;        return function(){            that.identity;  // that 是外部函数变量，闭包可以访问到        }    }}​\t对象内部使用了thislet object = {    identity : \"the object\",    getIdentity(){        return this.identity;  // 对象方法内部直接使用this    }}object.getIdentity(); // “the object\"(object.getIdentity = object.getIdentity)(); // the window// 执行了一次赋值，然后再调用赋值后的结果；表达式的值是函数本身(getIdentity())，this值不再于任何对象绑定，返回全局变量内存泄漏​\t闭包一直持有可能已经销毁的外部变量，可能导致内存泄漏。匿名闭包将可能难以清除。function assignHandler(){\tlet ele = document.getElementById(\"elementId\");    ele.onclick = () =&gt; { console.log(ele.id); }}​\t内部函数形成了一个闭包，这个匿名函数一直持有着 assignHandler 中的活动对象，即DOM元素的引用。只有匿名函数存在，ele的引用数就至少为1，内存永远不会被回收。function assignHandler(){\tlet ele = document.getElementById(\"elementId\");    let id = ele.id    ele.onclick = () =&gt; { console.log(id); }    el}​\t:one: 消除循环使用，只保存外部函数变量，而不是外部函数获取到的其他元素​\t:two: 闭包会引用外部函数的活动对象，其中仍然包含DOM元素的引用，所以需要把外部引用设置为null​\t至此，闭包与外部函数获取的其他元素无关。"
  },
  
  {
    "title": "7. 函数",
    "url": "/posts/7.%E5%87%BD%E6%95%B0/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-08-26 00:00:00 +0800",
    





    
    "snippet": "​\t函数存在提升的问题，优先级比变量优先级高定义      函数表达式  — let fun = function() {}        构造函数 ——  new Function() {}          参数必须是字符串格式      所有函数都是Function的实例、也是对象（引用类型）      new Function(“参数1”,”参数2”,”函数体”) ，最后一个参数作为...",
    "content": "​\t函数存在提升的问题，优先级比变量优先级高定义      函数表达式  — let fun = function() {}        构造函数 ——  new Function() {}          参数必须是字符串格式      所有函数都是Function的实例、也是对象（引用类型）      new Function(“参数1”,”参数2”,”函数体”) ，最后一个参数作为函数体      函数会被解析两次：        解析器率先读取 函数声明，使其在执行任何代码前就可以被访问；而 函数表达式 必须等解析器执行到其所在的代码行，才被真正解释        箭头函数  ​\t函数声明提升：使用函数声明，会在任何代码执行之前先读取并添加到执行上下文中。​\t函数表达式相当于位于变量声明中，如果是const、let变量，则不存在变量/函数声明提升问题；var变量，则面临与函数声明一样的提升问题。函数特性函数名  使用不带括号的 函数名name，表示指针；带括号使用 函数名name()，表示调用  函数对象都会暴露一个只读的 `name`属性 ，包含关于函数的信息          (new Function()).name 构造函数创建的匿名函数，值为anonymous      (()=&gt;{}).name 匿名函数，值为空字符串\"\"      函数是一个 get set 或者 bind()实例化，标识符会存在一个前缀        一个对象引用（可改变指向，多个函数名可能指向同一个函数）参数​\t函数的参数在内部表现为一个数组，（非箭头函数）定义函数时，可以在内部使用arguments对象访问传入的参数值。  arguments — 类数组对象      始终与对应的命名参数同步，但与参数存放在不同的内存空间中。        数组：包含传入（非定义时）函数的所有参数，可以用arguments.lenght确定实参个数    - 对象：具有callee（指针）属性，指向这个arguments对象的函数，arguments.callee.lenght 确定形参的个数  ​\t在递归回调函数中，回调中写 自身函数名，若修改函数名，则会出现问题；改成arguments.callee，适用于 匿名函数和递归调用时。​\t在严格模式下，:one: 对arguments[0]赋值，不会影响参数； :two: 在函数中重写arguments对象会导致语法错误。  重载：JavaScript不存在验证命名参数的机制，两个同名函数会覆盖先定义的，但可以使用lenght 根据传入参数的数量，实现重载function hello(name,message)(\tif(arguments.length) return 'no one come in'\tif(arguments.length === 1) return \"this gus didn't say anything\"\tif(arguments.lenght === 2) return arguments[1])  函数名解耦function factorial(num){    if(num &lt; 10) return 1    return num * factorial(num - 1)}let a = factorial(10); // 3628800// 为函数体保存多个函数名，并将 factorial 函数名（指针）指向为空let newLocal = factorial;factorial = null;// 再次调用 函数体，内部的factorial() = null，导致计算失败let b = factorial(10); // factorial is not a function​\t可以使用arguments.callee： 指向arguments对象所在函数的指针function factorial(num){    if(num &lt; 10) return 1    return num * arguments.callee(num - 1)}  默认参数值（ES6）arguments不反映默认值，只反映传给函数的参数；修改命名参数不会影响arguments对象，以调用函数时传入的值为准。只有在函数被调用时、未传入相应参数时，默认参数值才会被求值；作用域：位于函数存活时间内，块级作用域，且参数按定义的先后顺序初始化function makeK (name = \"King\"){}function makek (name = \"King\", time = getTime(name)){}      caller属性（非标准的）    调用当前函数的引用，如果是全局调用则为null。    在严格模式下，访问arguments.calleer会报错，且不可以给函数的caller`属性赋值，否则会导致错误  作为值​\t调用函数对象（数组）决定操作的对象，function createComparisonFunction(propertyName){ \t// 外层参数`propertyName` 指定操作的属性值    return function(object1, object2){        let value1 = object1[properyName];        let value2 = object2[properyName];                        // 对 value1 &amp; value2 操作 \t\t\t\t\t内层函数决定操作内容。    }}let arr = [    {name:\"zhang\",age:18},    {name:\"cheng\",age:20}]arr.sort(createComparisonFunction(age));\t// obj.sort 遍历调用数组内部的值this指向1. 普通函数：   - 定义 `function fn() {}`   - 调用 `fn();`   `fn.call()`   - **this → window**2. 构造函数   - 定义：`function Star() {}`   - 调用： `new Star();`   - **this → 实例对象**，原型对象里面的方法也是3. 对象的方法   - 定义： `let o = { sayHi: function() {} }`   - 调用：`o.sayHi();`   - **this → 方法所属的对象**4. 绑定事件函数   - `btn.onclick = function() {};`   - **this → 绑定事件的对象**5. 定时器函数   - window.`setInterval( function() {}, 1000)`  —— 每隔1s自动调用一次   - this → window6. 立即执行函数   - `( function() {} )(传入参数)`   - this → window7. 箭头函数   - 定义：`let fn = ()=&gt;{}`   - **this → 保留定义时的this**案例：新增数组方法操作变量存this​\t声明时，function User(name){this.name = name}为空对象User{}；被调用时，根据参数生成User{name:\"参数\"}​\t所以this是可以被改变的let Lesson = {\tsite:\"122\",    lists: [\"js\",\"css\",\"mysql\"],    show: function() {        const self = this; //指向对象        return this.lists.map(function(value){            console.log(this); //指向window            console.log(value);//形参            console.log(this.site);//指向window，undefined            console.log(self.site);//指向对象，”122\"        })    }部分函数存在第二参数可传递thisshow: function(){\treturn this.lists.map(function(){    \tconsole.log(this); //对象    },this);  }new.target​\t检测函数是否使用了new关键字调用。​\t如果函数是正常调用，new.target = undefined；如果使用new关键字调用，new.target指向被调用的 构造函数。call &amp; apply​\t以指定的this调用一个函数，返回函数的返回值；更换函数调用的作用域；​\t传入的数组内元素的个数 &gt; 函数可以接受的参数，数组内多余的将被丢弃；​\t非严格模式下，调用时没有指定this，this = window；​\t在严格模式下，调用时没有指定this，不会指向window而是会变成undefined。function fun(value1,value2,value3...)// call (this, 参数) 参数间使用逗号分隔function callFun(value1, value2, value3 ...){    return fun.call(this, value1, value2, value3)}// apply (this, 参数数组)function applyFun(value1, value2, value3 ...){    return fun.apply(this, arguments); // 传入数组、类数组    return fun.apply(this, [value1, value2, value3])}​\tcall &amp; apply 区别在与第二个参数是否为数组；如何选用完全取决于怎么调用函数传参方便：​\tapply()数组参数传入函数内部直接展开；call()仍以数组形式传入；如果不需要参数，两者都一样。应用1：避免求值遍历​\tMath.max.apply(null, arr); === Math.max(...arr);应用2：call和apply方法实现封装接口bind()​\t调用bind后此函数后不会立即执行，而是得到一个新的函数、实例（不同内存地址）​\tshow.bind({name: \"\"})()可使其立即执行​\t传递参数的方法：（不是立即执行）​\t绑定时传参（已将全部参数赋值，调用时传参无效）​\t调用时传参（参数填充完，剩余参数无用）// 不调用函数，但改变this的指向原函数的拷贝 = fun.bind( 指定的this, value1，value2 ...){}      主要应用：                  偏函数，使绑定的函数拥有预设的初始参数（包括this值，预设的参数），调用时传递的参数会跟在它们后面            快捷调用      配合定时器      let o = { name: 'baby' } // 调用的对象function fn(arr1,arr2,arr3) {    console.log(this.name);  // baby    console.log(arr1,arr2,arr3);}let bindFun = fn.bind(o,1,3); // arr1 = 1，arr2 = 2， arr3 = undefined ，this指向o， 但没有调用bindFun(0); // arr3 = 0let btn = document.querSelector('button');btn.onclick = function() {    this.disabled = true;  // 函数内的this指向调用者    // bind 解决    setTimeout( function(){        // this.disabled = false;     定时器内的this指向window，没有这个属性    }.bind(this),3000) //为定时器的函数外面（此时的this仍然时函数的调用者）绑定this，之后内部的this指向函数的调用者    // 箭头函数 解决    setTimeout= ()=&gt;{        this.disabled = false;     //箭头函数没有自己的this，这个this指向上一级调用者    },3000)}递归函数​\t定义：函数内部调用自己​\t栈溢出（stack overflow），死循环 —— 退出条件非常重要      解决问题 —— 递归函数案例                  求1-n的阶乘        函数内部使用了 函数名调用，导致执行逻辑与函数名耦合，应该替换为arguments.callee()              function fn(n) {    if (n == 1) { return 1; }    if (n &gt;= 0) {         return n * fn(n - 1);         // return n * arguments.callee(n - 1)    }    else        alert(\"请输入大于等于1的数\");}console.log(fn(-3));                      求斐波那契数列  $a_n = a_{n-1} + a_{n-2}(a_1 = 1,a_2 = 1,n≥3)$        尾调用优化：如果函数逻辑允许基于尾调用将其销毁，则引擎会这么做（ES6特性）              function fb(n) {    console.log(n);    if (n === 1 || n === 2) { return 1; }    else         return fb(n - 1) + fb(n - 2);}console.log(fb(3));  // 优化后：function fib(n){\treturn fibImpl(0, 1, n);}function fibImpl(a, b, n){    if(n === 0) return a;    return fibImpl(b, a+b, n-1);}      尾调用优化的条件：  代码在严格条件下 —— 非严格模式下函数调用中允许使用f.arguments 和 f.caller，都会引用外部函数的堆栈  外部函数（fib）的返回值是对尾调用函数（fibImpl）的调用  —— 上下文不再返回外部函数（fib）中  尾调用函数（fibImpl）返回后不需要执行额外的操作 —— 上下文不再返回外部函数（fib）中  尾调函数（fibImpl）不是引用外部函数作用域中自由变量的闭包 —— 外部函数（fib）上下文仍有存在的必要全局函数function screenX(){}默认压入window中，可能覆盖window中声明的属性/变量，函数提升的问题将函数赋值给let变量可以避免以上问题函数用类的方法声明（es6）class a {}⁉️高阶函数  对其他函数进行操作（满足其中一个）          接受函数作为参数      将函数作为返回值输出      // 接受函数作为参数function fn(callback){ callback &amp;&amp; callback(); }fn(function() { alert('hi'); })// 将函数作为返回值输出function fn(){ return function() {} }// 回调函数立即执行函数 （IIFE）​\tImmediately Invoked Function Expression，在ES5尚未支持块级作用域，用来模拟块级作用域（作用域仅为括号内，执行完毕作用域链销毁）(function( 形参 ){    // 在函数作用域内，使变量活动块级作用域})( 实参 )      链式引用script若有同名函数，取最后引入加载的script函数        使用模块化类的方式  传入参数window(function(window){    function hd(){}    window.js2 = {hd} //对外开放一个接口})(window);js2.hd块作用域解决{\tlet hd = function(){}    window.js1 = {hd};}### ⁉️箭头函数（Es6）const hd = ( 形参 ) =&gt; { 函数体 };let hd = [1,2,3].filter(value =&gt; value &lt;= 3);const sum = (num1,num2) =&gt; num1 + num2;\t// 函数体 只有代码，可以省略大括号；返回值为执行结果console.log( sum(10,20) ); // 30const fn = v =&gt; alert(v); //形参 只有一个，可以省略小括号fn(20);  递归 、构造、事件处理器不适用箭头函数  没有 arguments（只能通过定义的参数名访问）、 super、 new.target 属性，也没有 prototype 属性  无具体参数名称，回调不方便、箭头函数，this指向上一级的this，没有自己的this  函数定义时作用域就有了，this需具体到执行时，箭头函数在绑定时决定var obj = {    age: 40,    say: () =&gt; { alert(this.age) }  // 实际上是定义在window下的方法}obj.say(); // undefind// obj是一个对象，对象不产生作用域；作为window调用，返回undefined取对象同时取DOM节点  取对象：箭头函数；取节点：普通函数，不可同时实现解决方法：  button.addEventListener(\"click\",function(event){})中的event.target指当前绑定的按钮let Dom = {    site: '',    bind: functon(){\t\tconst button = document.querySelector(\"button\");button.addEventListener(\"click\",event =&gt; {\tconsole.log(this); //箭头函数指父级对象    console.log(event.target);//获取当前绑定的DOM节点        })\t}}  const self = this；  hanleEvent  element.addEventListener(type, listener[, useCapture]);其中listener：当指定的事件类型发生时被通知到的一个对象。该参数必须是实现EventListener接口的一个对象或函数。即，第二个参数除了可以传入函数外，还可以传入对象。  事件会自动在传入对象中寻找handleEvent方法let Dom = {    handleEvent: function(event){            },    bind: funcion(){    \tconst button = document.querySelector(\"button\");\t\tbutton.addEventListener(\"click\",this); //传入当前对象，自动寻找handleEvent方法\t}}访问私有变量​\t任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数/块的外部无法访问其中的变量。特权方法​\t其实就是使用 闭包 的原理，具有访问构造函数中定义的所有变量和函数的能力。function Person(value){    // 私有变量    let name = value    // 特权方法    this.getName = function(){ return name; }    this.setName = function(value) { name = value; }}let person = new Person('lisi');person.getName(); // 'lisi'静态私有变量​\t私有作用域内定义公用的构造函数，并在构造函数原型上添加特权方法实现访问私有变量。但这个私有变量是“共享”的.​\t在下面例子中，构造函数使用函数表达式而不是函数声明，函数声明会创建内部函数，这里不是必须的。function (){    // 私有变量     let privateVariable = 10;    // 私有函数    function privateFunction (){        return false;    }    //  构造函数    // 1. 不带关键字的，全局变量    // 2. 表达式声明，执行时才会创建函数    MyObject = function() {}    // 在构造函数的原型上添加特权方法    MyObject.prototype.publicMethod = function (){        return privateFunction();    }}模块模式​\t单例对象(singleton)：只有一个实例的对象，通常通过 对象字面量 创建。​\t模块模式是在单例对象基础上加以扩展，通过作用域链关联私有变量和特权方法。let singleton = function() {    // 私有变量     let privateVariable = 10;    // 私有函数    function privateFunction (){        return false;    }    // 特权、公有方法和属性    return { // 返回对象字面量        publicProperty: true,        publicMethod(){            return privateFunction();        }    }    }​\t函数返回的对象字面量，只包含可以公开访问的属性和方法；因为其定义在匿名函数的内部，所以可以访问同一个作用域的私有变量和私有函数。​\t对象字面量 本质上定义了 单例对象的公共接口。如果单例对象需要进行初始化，且需要访问私有变量，可以使用。模块增强模式​\t在返回对象之前，对其进行增强。适用于：单例对象需要某个特定类型的实例，但又需要给它添加额外属性、方法let application = function(){    let components = new Arrya();    // 指定某种特定的类型    components.push(new BaseComponent());        // 创建局部变量，保存额外功能的实例    let app = new BaseComponent();    // 获取私有变量的属性    app.getCompontCount = function(){        return components.length;    }    // 设置私有变量    app.setCompontRegister = function(components){        return components.push(component)    }    return app; // 返回实例}​\tapplication返回值是app实例，可以让components被外部访问到"
  },
  
  {
    "title": "6. 类",
    "url": "/posts/6.%E7%B1%BB/",
    "categories": "JavaScript, Object, 原型链",
    "tags": "javascriptBase",
    "date": "2022-08-25 00:00:00 +0800",
    





    
    "snippet": "  声明：class name(){ }；实例：new name( )// 类声明class Person {}// 类表达式const Animal = class AnimalClass {};// 接收类的变量名称可以改变，之后可以通过 Aniaml.name 属性获取类名称字符串；但不能单独使用类名称字符串访问类Animal.name // AnimalClassAnimalClas...",
    "content": "  声明：class name(){ }；实例：new name( )// 类声明class Person {}// 类表达式const Animal = class AnimalClass {};// 接收类的变量名称可以改变，之后可以通过 Aniaml.name 属性获取类名称字符串；但不能单独使用类名称字符串访问类Animal.name // AnimalClassAnimalClass // undefined​\t类表达式Animal，在它们求值之前不能被引用，且不能被提升。  作用域： 块级作用域 限制类的构成类方法​\t类方法等同于对象属性，其键可以是 字符串、符号、或是计算后的值class Person(){ // 类名首字母大写；类中的方法， 不需要function；方法之间不需要, 隔开    // 构造方法\tconstruct(uname){        // 实例成员\t\tthis.name = uname; // 自动添加了属性\t}    // 实例方法\tsing(song) {\t\tconsole.log(this.name + song);\t}    // 静态方法：每个类上只有一个，this引用自身；适合用作实例工程    static shareWithSub() {}    // 获取函数    get myName {}    // 设置函数    set myName(newName) {}}成员数据​\t把方法定义在类构造函数、类块中，但不能在类块中给原型添加原始值、对象作为成员数据。给原型定义成员数据：Person.prototype.greeting = 'my name is'Person.name = 'Jack'console.log(`${Person.prototype.greeting} ${this.name}`)迭代器 &amp; 生成器class Person {    *createNameIterator(){ // 原型上定义迭代器\t\tyield 'Jack';\t\tyield 'Mack';\t\tyield 'Anry';            }    static *createTimeIterator(){ // 类上定义迭代器\t\tyield '220101';\t\tyield '220102';\t\tyield '220103';            }}const timeIterator = Person.createTimeIteratortimeIterator.next().value //220101timeIterator.next().value //220102let p = new Person();const nameIterator = p.createNameIterator()nameIterator.next().value //JacknameIterator.next().value //Mack​\t添加一个默认迭代器，把类实例变成可迭代对象class Person() {    constructor(){        this.name = ['Jack','Mack','Anry']    }\t*[Symbol.iterator]() { // 返回迭代器，不直接执行内部指令        yield *this.name.entries();    }    [Symbol.iterator]() { // 返回元素地址，键值对        yield *this.name.entries();    }}class Star {    constructor( name, age ){        this.btn = document.querySelector('button');        this.btn.onclick = this.sing; \t// 当点击时，调用sing函数，        this.btn.onclick = this.sing(); // 立即执行sing函数，undefined       \t/**        个人理解：this.sing 传入了函数所在的地址，点击时查找到函数再调用；this指向调用者                this.sing() 是函数调用语句，返回的结果赋值给按钮；this指向构造者        */    }}实例化​\t类必须使用new实例化对象。解释器在使用new操作符创建类时，需要调用constructor关键字定义的函数。不定义构造函数，相当于使用空函数。使用new操作符时，执行四个步骤。​\t类实例化时传入的参数，会作为构造函数的参数。默认情况下，返回构造函数创建的对象；如果修改默认返回值，而是其他对象，这个结果将不会被instanceOf检测出跟类有任何关系。class Person{    constructor(){        return {}    }}let p1 = new Person(); // {}​\t类的构造函数，除了必须使用new操作符调用，在类实例化完成后，就成为了一个普通的实例方法。​\t普通构造函数不使用new调用，以全局的this（通常是window）作为内部对象let p1 = new Person(); // {} p1 instanceof Person  // truelet p2 = new Person.constructor(); // 使用构造函数引用构造一个新实例p2 instanceof Performance //falsep1 == p2 // false​\t类中定义的constructor()不会被当作构造函数​\t类的本质是一个特殊的函数。类标识符有prototype属性，这个原型中的constructor属性指向类自身。 类中定义的constructor()不会被当作构造函数​\t（实例只保留指向原型的指针[[prototype]]，没有指向构造函数的指针）typeof Person // function// Person 被认为是构造函数Person === Person.prototype.constructor // true用法作为参数let classList = [    class {        constructor(id){            this.id = id;            console.log(`instance ${this.id}`)        }    }]function createInstance(classDefinition, id){    return new classDefinition(id)}let foo = createInstance(classList[0],1); // 批量生成类 foo = classList {id: 1}立即实例化new class Foo { \tconstructor(id){        this.id = id;        console.log(`instance ${this.id}`)    }    }(1)继承class Father {    constructor (x, y) { // 1.父类生成实例时，父类的x、y被赋值        this.x = x;        this.y = y;    }    sum() {    \tconsole.log(this.x + this.y); // 2.这里this指向父类的x、y    }}class Son extends Father {    constructor (x, y) {        // 4. 此处应该调用父类对构造方法：super(x, y);        this.x = x;        this.y = y;    }}let son = new Son(1, 2); // 3.生成是子类，父类构造函数未调用，父类的x、y还是undefined，不能计算son.sum(); // 报错！  extends 可以在类表达式中使用： const son  = new Son extends Father  this 谁调用指向谁  super关键字：调用父类的函数（构造函数、静态函数）          只能在派生类的构造函数、静态函数中调用                  在构造函数中使用super()，表示直接调用父类构造函数super.constructor()，需要手动传入          静态函数中使用super，可以调用继承类的静态方法。                    会返回父类的this，所以【! super必须在子类this之前】        call方法： 在子构造函数中，使用Father.call(this)​\t派生类中显示定义了构造函数，要么🔖返回调用super返回父类 ，要么🏷️返回一个对象class Son extends Father(){    constructor(){        super();    }}class Son extends Father(){    constructor(){        return {};    }}抽象基类​\t可以给其他类继承，但本身不能实例化；使用new.target识别当前实例化的类型，从而决定要不要对其进行实例化class Vehicle{    constructor() {\t\tconsole.log(new.target);        // 识别当前实例化的类型        if(new.target === Vehicle) throw new Error(\"Vehicle can't be directly instantiated\")        // ..                // 必须实现某个方法        if(!this.foo) throw new Error(\"Inheriting class must define foo{}\");    }}new class Bus extends Vehicle {    foo() {}}new class Bus extends Vehicle {} // Error：Inheriting class must define foo{}new class Vehicle {} // Error：Vehicle can't be directly instantiatedspecies访问器​\t返回实例类型，其被构造函数用以创建派生对象。getter默认返回this，未部署setter属性；默认情况下，返回原始实例类型一致。​\t如果需要覆盖这个行为，可以在子类的构造函数内声明为静态方法，或者用 Object.defineProperty 等方法添加或修改此属性。class MyArray extends Array {  // 覆盖 species 到父级的 Array 构造函数上  static get [Symbol.species]() {    return Array;  }}const myArray = new MyArray();myArray instanceof MyArray; // falsemyArray instanceof Array;   // true类混入​\t把不同类行为集中到一个类中。:one: Object.assign()：将多个对象属性混入:two: extend关键字后接表达式class Vehice {}function getParentClass () {    console.log('get superClass1')    return Vehice;}class Bus extends getParentClass(); // Bus extends Vehice// 多重继承: 接受一个超类做为参数，将混入类定义为这个参数的子类let doorMixin = (SuperClass) =&gt; class extends SuperClass{    door() { console.log(\"add car door\") }}let glassMixin = (SuperClass) =&gt; class extends SuperClass{    glass() { console.log(\"add car glass\") }}// class Bus extends doorMixin(glassMixin(Vehice)){}let bus = new Bus();// 借助辅助函数，展开嵌套调用function mixin(BaseClass, ...Mixins){ // Aarry.reduce 累加遍历；accumulator 累加器\treturn Mixins.reduce((accumulator,current) =&gt; {        return current(accumulator)    }, BaseClass) // BaseClass 初始值}class Bus extends mixin(Vehice,doorMixin,glassMixin){}let bus = new Bus();三个注意点  this的指向问题：          constructor 里的this指向创建的实例对象      类中方法的this指向调用的实例对象        类没有变量提示：必须先声明、后使用  使用类中共同属性、方法，一定要加this"
  },
  
  {
    "title": "5. 构造函数",
    "url": "/posts/5.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
    "categories": "JavaScript, Object, 原型链",
    "tags": "javascriptBase",
    "date": "2022-08-23 00:00:00 +0800",
    





    
    "snippet": "构造函数​\t定义： 与普通函数差别在于——使用了new调用function Person(name, age, job){    this.name = name;     // ...    this.sayhello = funciton(){     \tconsole.log('my name is' + this.name)    }}// 使用new定义Person的子类，会自己返...",
    "content": "构造函数​\t定义： 与普通函数差别在于——使用了new调用function Person(name, age, job){    this.name = name;     // ...    this.sayhello = funciton(){     \tconsole.log('my name is' + this.name)    }}// 使用new定义Person的子类，会自己返回对象// 自定义构造函数： 确保被识别为特定类型new执行时做的四件事情   内存中创建对象  指定构造函数：新对象内部的[[Protorype]] = 构造函数的prototype属性  实例化对象：构造函数的this 指向这个新对象  执行构造函数；给新对象添加属性和方法  返回这个新对象 this? this : {}原型​\t使用构造函数创建对象，其定义的方法和属性在每个实例上都备份了一次，但其有些只需要维护一份。​\t为每个函数的prototype属性下包含特点引用类型的 实例共享方法和属性。—— 原来在构造函数中赋予对象实例的值，都可以直接赋值给它们的原型function Person(name) {    this.name = name;}Person.protorype.sayHello = function(){    console.log('my name is' + this.name)}person1 = new Person('小芳');person2 = new Person('小福');person1 === person2 // falseperson1.name == person2.name // falseperson1.sayHello === person2.sayHello // trueconstruct.prototype  prototype 是一个对象，又称原型对象  其属性和方法都归构造函数所有  所有的对象都共享原型对象instance.__proto__  又称为 对象的原型  每个对象都有这个属性构造函数 Person.prototype和 对象person.__proto_是指向是等价的原型的其他构造语法function Person() = {}// 重新定义属性Person.protorype.sayHello = function(){    console.log('my name is' + this.name)}// 1. 对象字面量Person.prototype = {    constructor: fatherClass, // 使用构造函数，指回原来的原型    name: 'humen',    sayHello() {        console.log('My name is '+ this.name);    }}  对象字面量方式，需要重写constructor属性，使得[[Enumerabele]]键值为true。  原生的constructor属性默认不可枚举，需要使用Object.defineProperty()修改回来// 2. 修改 Object.defineProperty()Object.defineProperty(Person.prototype, \"constructor\", {    enumerable: false,    value: Person\t})原型链​\t**对象的原型属性，指向创建它的构造函数object.__proto__.constructor的原型属性 __proto__所指向的原型对象 **​\t修改实例所在的原型链，可以使用Object.setprototypeOf()但不建议。应该通过Object.create(construct)为新对象指定构造函数。成员查找机制（就近原则）  这个对象自身有没有 这个属性（或方法）  没有，查找它的原型 （__proto__指向的prototype原型对象）  还是没有，查找原型的原型（Object的原型对象）  一次类推，直至找到 null 为止实例只有指向原型的指针，没有指向构造函数的指针。​\t实例在原型更改前已经存在，依然可以在原型更改后查找到最新的。因为搜索值的过程是动态的。实例与原型之间的松散关系。​\t实例在构造函数重写前已经存在，依然引用的是最初的原型；重写会切断最初原型与构造函数的联系。in操作符单独使用 in操作符​\t通过对象访问指定的属性时，返回true，无论这个属性是在实例还是原型上。​\t需要使用.hasOwnProperty('..') ，才可以判断是否存在于自有的属性上。function hasPrototyperty(object, name){    return !object.hasOwnProperty(name) &amp;&amp; (name in object)}for-in 循环中使用​\t可以通过对象访问、可以被枚举的属性，都会返回。包括实例属性、原型属性。function Person(name) {    this.name = name;}Person.prototype.local = 'shanhai';Person.prototype.sayHello = function(){    console.log('my name is' + this.name)}let p1 = new Person();// 获取对象上所有可枚举的实例属性Object.keys(Person.protorype); // ['local', 'sayHello']Object.keys(p1);\t// ['name']// 获取对象上所有实例属性，无论是否可以枚举 (constructor 为不可枚举)Object.getOwnPropertyNames(Person.prototype); //  ['constructor', 'local', 'sayHello']Object.getOwnPropertyNames(Person); // ['length', 'name', 'arguments', 'caller', 'prototype']// 获取对象上所有的实例属性，键位符号Object.getOwnPropertyNames()​\t它们枚举顺序是确定的。:one: 先以升序枚举数值键，:two: 插入顺序枚举字符串和符号键 :three: 对象字面量定义的键，以逗号分隔顺序插入继承 6 种方法1、原型链继承；      通过将一个类型A的实例赋值给另一个B构造函数的原型实现的 – B 继承 A        重点：让新实例的原型等于父类的实例 —— 子类的.prototype = new 父类()，子类的实例也是父类的实例    特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。    缺点：    1、新实例无法向父类构造函数传参。    2、继承单一。    3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）    4、子类.prototype 添加属性必须在 指向了父类之后，否则会被覆盖        查看私有属性：hasOwnProperty() — 包括查找原型链中的 [prototype] 的Property  2、借用构造继承（也称伪造对象或经典继承）；  function Child(name){ Parent1.call(this，name), Parent2.call(this，name)}  优点          实现多继承，通过call改变父类的this      创建的子类实例可以向父类传递参数      解决了原型链继承中，所有子类的实例共享父类实例的属性。        缺点          实例是子类的实例，不是父类的实例。      只能继承父类实例属性、方法；不能继承父类原型上的方法      子类实际上是复制了父类的方法当作自己的方法，多个相同的子类占用较大内存      父类的方法改变时，已经存在的子类实例并不能更新方法      3、组合继承组合：原型链继承 + 借用构造函数继承.call (调用函数者， 参数1， 参数2);改变this的指向function fn(x, y) { console.log(this); }let o = {}fn(1, 2); // this指向windowfn.call(o, 1, 2); // this指向o  主要应用：组合继承构造函数 + 原型对象（ES5）// 构造继承：借用父构造函数，继承其属性function Father(name, age){    this.name = name;    this.age = age;}function Son(name, age){    // this指向Son  调用Father的构造函数，    // 将son.this 替换掉 father.this，于是son就拥有了father的属性    Father.call(this, name, age);    // ... 子类的属性和方法}// 原型对象 继承其方法// 【错误示范】Son.propototype = Father.prototype;Son.propototype.exam = function() {}; // 修改Son构造函数的 方法// console.log(Father) 也存在Son的方法 ———— prototype是对象，赋值传递是引用，两者指向同一个内存空间；继承应执行父类的实例而不是父类对象// 【正确示范】Son.prototype = new Father();  // 新建一个Father实例，既有属性、又有方法； 使用对象的方式修改prototype，会使修改原型链Son.prototype.construcor = Son; // 利用construcor 指回原来的原型对象let son = new Son(\"sonName\",\"sonAge\");​\t核心思想：使用原型链继承原型上的属性和方法，通过借用构造函数继承实例属性。​\t组合继承仍然保留了instanceof操作符和isPrototypeOf()方法识别对象的能力 —— 关注类型和构造函数的场景。​\t存在问题：父类的构造函数始终会被调用两次，导致性能浪费​\t:one: 创建子类原型时调用：获取原型属性 —— 父类实例属性成为子类原型属性​\t:two: 子类构造函数中调用 —— 新对象上创建实例属性，覆盖父类实例属性​\t寄生式组合继承可以解决这个问题4、原型式继承​\tobject()方法通过对传入对象执行了一次浅复制——新对象的原型上既有原始值属性，又有引用值属性。子类对于引用值属性的修改，都会同步影响。​\t适用于：不需要单独创建构造函数，但仍然需要在对象间共享信息。// 06年，Douglas Crockford 所著文章提出的一个函数：function object(o){    function F() {}\t// 创建一个临时构造函数    F.prototype = o; // 将传入的对象作为这个构造函数的原型    return new F;\t// 返回这个修改过原型的对象} // F extends o，再对返回的F对象进行修改// ES5 通过新增 Object.create() 方法，将原型式继承的概念规范化了let Person = {    name: \"Nicholas\",    friends: ['sell','court','bar']}let onePerson = Object.create(Person,{ // 仅有第一个参数，效果与第一个函数一样    name:{        value: \"Gred\"; // 第二个参数与 Object.defineProperties() 第二个参数一样，新增属性要通过自己描述符    }})5、寄生式继承​\t思路类似于 寄生构造函数和工厂模式： 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。function createSub(original){    let clone = object(original); // 创建一个父类实例    clone.sayHi = function(){        console.log(\"hi!\")    };    return clone;}​\t返回的 clone 对象相较于 original对象而言，除了拥有其所有属性和方法，还拥有自己的方法。但是会导致函数难以重用。​\t适用范围： 与原型链继承一样，关注对象而不在乎类型和构造函数的场景6、寄生组合式继承 ​\t借用构造函数继承属性（取得父类原型的副本），组合继承方法（给副本设置constructor属性，解决重写原型修改到默认构造函数）。function inheritPrototype(subType, superType){    let prototype = object(superType.prototype); // 取得父类原型的副本    prototype.constructor = subType; // 恢复默认构造函数    subType.prototype = prototype; \t// 新创建的对象作为子类的原型}​\t仅调用一次superType构造函数，避免subType.prototype上获得不必要也用不到属性。​\t原型链仍然保持不变，因此仍然保留了instanceof操作符和isPrototypeOf()方法识别对象的能力 —— 关注类型和构造函数的场景。"
  },
  
  {
    "title": "4. 展开语法  & 解构语法",
    "url": "/posts/4.%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95&%E8%A7%A3%E6%9E%84%E8%AF%AD%E6%B3%95/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-21 00:00:00 +0800",
    





    
    "snippet": "展开语法  ​\t将数组、对象 转换为用 逗号分隔的参数序列在函数中应用      函数调用 (数组元素迭代为函数参数)    ` myFunction(… args); == myFunction.apply(null, args);`    使用new Function()定义，其传参的最后一个作为函数体，其他作为参数，传参都得是字符串        传参给构造函数    .apply执行...",
    "content": "展开语法  ​\t将数组、对象 转换为用 逗号分隔的参数序列在函数中应用      函数调用 (数组元素迭代为函数参数)    ` myFunction(… args); == myFunction.apply(null, args);`    使用new Function()定义，其传参的最后一个作为函数体，其他作为参数，传参都得是字符串        传参给构造函数    .apply执行的是.call，而不是构造constuct    Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。    // 展开语法：let arr = [1003,3,2];let d = new Date(...arr); //传入(1003, 3, 2)   // 不使用展开语法function applyAndNew(constructor, args) {   function partial () {      return constructor.apply(this, args); // 将数组展开传递给构造函数   };   if (typeof constructor.prototype === \"object\") { // 如果构造函数的类型是对象      partial.prototype = Object.create(constructor.prototype); // 重新指向其构造函数   }   return partial;}var myConstructorWithArguments = applyAndNew(myConstructor, myArguments); // 需要自定一个构造函数      在数组中的应用      复制到新的函数    var lyrics = ['head', ...parts, 'and', 'toes'];         连接两个函数    var list3 = [...list1, ...list2]  ==  var arr3 = arr1.concat(arr2);        数组插入 新数组    开头插入：var list1 = [...list2, ...list1] == Array.prototype.unshift.apply(arr1, arr2)    结尾插入：var list1 = [...list1, ...list2] ==  for( const item of list2) { list1.push(item); }  在对象中的应用​\t已有 对象的所有可枚举 (enumerable) 属性 拷贝到新构造的对象中​\tvar mergedObj = { ...obj1, ...obj2 };   浅拷贝对DOM节点操作· document.querySelectorAll(“ “)获取节点为集合，一个类数组，使用map得转化为数组·  Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。Array.form(document.querySelectorAll(\"\")).map(function(item){})· 使用节点原型链上的map函数 call()Array.prototype.map.call(div,function(item){})· 展开语法[...div].map(function(item){    item.addEventListener(\"click\",function(){        this.classList.toggle(\"hide\");    });});剩余参数​\t允许我们将一个不定个数的参数表示为一个数组，结合解构语法将剩余变量全部吸收过来，...args需放在结构的最后一个funcion sum(first, ...args){    console.log(first); // 1    console.log(args); \t// [3,4,5]    let total = 0;    args.forEach(item =&gt; total += item);    console.log(total) // 3 + 4 + 5 = 12}sum(1,3,4,5);// 剩余参数 &amp; 解构函数let [s1, ...s2] = [1,3,4,3,5,6]; // s1 = 1, s2 = [3,4,3,5,6]结合使用let {name:myName} = {name:[1,2,3,4],age:'20',sex:'男'}console.log(myName); // [1,2,3,4]let {name:myAge} = {name:[1,2,3,4],age:'20',sex:'男'}console.log(myAge); // '20'数组去重let arr = [12,54,12,75,12]let item = [...new Set(arr)]console.log(item)解构语法​\t对象解构：使用与对象匹配的结构来实现对象属性赋值​\t当元素存在引用对象时，出现浅拷贝的问题// 1. 左侧的数组、对象 批量赋值给 右边的变量let [name,age] = [\"张三\",\"20\"];let person = { name:'Matt', age:27}let {name:name1, age:age1} = person; // name1 = 'Matte',age1 = 27let {name, age} = person; // name = 'Matte',age = 27// 2. 为个别元素添加默认值let [name,age=20] = [\"张三\",\"20\"];// 3. 仅取其中某个值let [,age] =  [\"张三\",\"20\"]​\t在内部使用函数 ToObject() （不能在运行环境中直接访问）把数据源结构转为对象 —— 原始值会被当成对象。Null &amp; undefined 不能被解构，否则会抛出错误。​\t如果给事先声明的变量赋值，则赋值表达式必须包括在括号内。let name, age, page;let person = {    personName : 'matt',    personAge : 27,    personPage:{ title: 'my life'}}let copy = {}// 嵌套解构({personPage: copy.personPage} = person); //  coye = {personPage:{ title: 'my life'}({personJob: job} = person); // 报错! 外部未声明job，内部未声明personJob，不能使用嵌套解构// 参数上下文匹配： 在函数签名中声明函数提内使用的局部变量function printPerson(foo, {personName:name}, bar){\tconsole.log(name)}​\t解构表达式涉及多个赋值，自赋值出错后面都会失败；则整个解构赋值只会完成一部分。"
  },
  
  {
    "title": "3.对象",
    "url": "/posts/3.%E5%AF%B9%E8%B1%A1/",
    "categories": "JavaScript, 对象",
    "tags": "javascriptBase",
    "date": "2022-08-18 00:00:00 +0800",
    





    
    "snippet": "对象​\tECMA-262定义对象为：一组属性的无序集合  —— 对象的每个属性或方法都有一个名称来标识(key) ，并映射到一个值(value)，散列值三种创建方法  new Object()  字面量创建对象 let obj = {}  构造函数创建对象          function obj() = { }      浪费空间：每个方法都需要一个内存空间存放      成员对象  静...",
    "content": "对象​\tECMA-262定义对象为：一组属性的无序集合  —— 对象的每个属性或方法都有一个名称来标识(key) ，并映射到一个值(value)，散列值三种创建方法  new Object()  字面量创建对象 let obj = {}  构造函数创建对象          function obj() = { }      浪费空间：每个方法都需要一个内存空间存放      成员对象  静态成员：由构造函数本身访问  实例成员：由实例化对象访问对象方法Object.keys(obj)：用于获取对象自身 所有的 属性；返回 数组 [属性名1，属性名2，….]对象属性​\tECMA-262使用一些内部特性描述属性特征，由为Javascript实现引擎的规范定义的。不能直接访问，在规范中，使用双中括号，如 [[Enumerable]] 表示。数据属性            [[Configurable]]： 属性是否可以被删除、再次修改 特性，true      false(默认)，影响Object.defineProperty方法调用                  [[Enuumerable]]：属性是否可以枚举，true      false(默认) ，会影响Object.key()显示这个方法                  [[writable]]：值是否可以重写，true      false(默认)，不使用defineProperty时，属性值为true；使用后默认值为false      [[value]]：属性值，默认为undefined​\t在显性添加属性到对象之后，除了[[value]]绑定赋予的值，其他值都会被设置为true。修改属性的默认特性，需要使用Object.defineProperty()方法。​\tObject.defineProperty(目标对象obj, 需修改的属性名prop, 其特性descriptor)Object.defineProperty(obj, 'num', {value:1000}); // writable=false, 非严格模式下无效；严格模式下报错Object.defineProperty(obj, 'id', {writabel:false}); 访问器属性            [[Configurable]]： 属性是否可以被删除、再次修改 特性、是否可以改为数据属性，true (默认)      false，                  [[Enuumerable]]：属性是否可以通过for-in枚举，true (默认)      false，会影响Object.key()显示这个方法      [[Get]]：获取函数，在读取属性是调用，默认值为undefined[[Set]]：设置函数，在读取属性是调用，默认值为undefined​\t不包含数据值，get 和 set 又称为对象属性监视器，用于获取和设置值​\t访问器属性不能直接定义，必须使用 Object.defineProperty()let value = 10;let person = {    age:29;    name:'张三'}Object.defineProperty(person,'age',{    // get函数(getter) -- 属性值被映射到getter上    get:function(){\t\t// 当 person.age 被读取时（每次读取，都会触发getter）        return value;    } // person.age = 10    set(value){    \t// 当 修改person.age值时，新值作为形参value传递\t}})读取属性特性Object.getOwnPropertyDesciptor()可以获取指定属性的属性描述符。let book = new Object()Object.defineProperties(book,{    year_:{ value:2001; }    year:{    \tget: function() { return this.year_; }\t\tset: function(newValue) { this.year_ = newValue; } \t}})// 数据属性：let value_Descriptor = Object.getOwnPropertyDesciptor(book, 'year_');value_Descriptor.value; // 2001value_Descriptor.set // get、set = undefinedvalue_Descriptor.configurable // false// 访问属性：let access_Descriptor = Object.getOwnPropertyDesciptor(book, 'year');access_Descriptor.value; // undefinedaccess_Descriptor.set; // get、set = functionaccess_Descriptor.enumerable; // false;Object.getOwnPropertyDesciptors()静态方法，在每个自有属性上调用Object.getOwnPropertyDesciptor()并在一个新对象中返回他们。ES6 对象语法糖  属性值简写（键值同名）let name = 'matter'let person = { name: name };// 等价于let person = { name };​\t代码压缩程序会在不同作用域内保留属性名，编译器会保留初始标识符function makePeraon(a){    return { name: a };}      可计算属性：使用变量值作为属性    :one:必须先声明对象； :two:使用中括号 —— 对象属性键告诉运行时将其作为JavaScript表达式而不是字符串求值  const nameKey = 'name';let person = {    [nameKey]: 'Matt'}​\tJavaScript表达式求值，可以搭配复制表达式const className = ObjectClassfunction getUniqueKey(key){    return `${className}_${key}`}let person = {    [getUniqueKey(namekey)] : 'Matt'}// person = { ObjectClass_nameKey:'Matt' };​\tJavaScript表达式求值可能抛出任何错误，都会中断对象创建"
  },
  
  {
    "title": "2.11.集合引用类型（Set）",
    "url": "/posts/2.11.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Set/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-16 00:00:00 +0800",
    





    
    "snippet": "Set &amp; WeakSet      Set类数组，不可放重复数据，不约束不同类型的数据        对象，约束不同类型的数据（原始值还是对象引用，统统转换为字符串存储），同名属性会覆盖        Set 使用 key:key 方式存储：    set.values === set[Symbol.iterator] // trueset.keys === set[Symbol....",
    "content": "Set &amp; WeakSet      Set类数组，不可放重复数据，不约束不同类型的数据        对象，约束不同类型的数据（原始值还是对象引用，统统转换为字符串存储），同名属性会覆盖        Set 使用 key:key 方式存储：    set.values === set[Symbol.iterator] // trueset.keys === set[Symbol.iterator] \t// trueset.values() === set.keys() // false  set.entries(); // 返回集合中的每个值重复出现// 0: {\"李四\" =&gt; \"李四\"}// 1: {\"王五\" =&gt; \"王五\"}// 2: {\"吴六\" =&gt; \"吴六\"}      定义const m = new Set() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let Set = new Set([\"李四\", \"王五\", \"吴六\"]);console.log(Set); // 3// 使用自定义函数初始化const Set2 = new Set({    [Symbol.iterator]: function*() {        yield 'value1';        yield 'key2','value2';        yield 'key3','value3';    }})console.log(mep2.size); // 3const set = new Set([1,2,3,4,6,4,2,1]);  // Set(5) {1, 2, 3, 4, 6} 自动去重// 声明时变量为字符串，将字符串展开为单个字符赋值成对象,，并自动去重const set = new Set('hello');  // Set(4) {'h', 'e', 'l', 'o'} 自动去重增删改查const set = new Set([['firstName','matter'],['lastName','petter']]);// 新增值,返回Set对象,可以链式定义set.add(\"name\",\"张三\").add('age',10)// 查询值 // 1. 通过键查找: set.has(key)set.has('firstName'); // trueset.has('matter'); //false// 2. 返回所有键 set.keys(); // SetIterator {'李四', '王五', '吴六'}// 3. 返回所有值set.values(); // SetIterator {'李四', '王五', '吴六'}// 4. 返回所有键值对set.entries(); //SetIterator {'李四' =&gt; '李四', '王五' =&gt; '王五', '吴六' =&gt; '吴六'} // 查询个数set.size() // 3// 删除// 1. delete(key) 是否成功删除 set.delet('firstName'); // tureset.delet('firstName'); // false// 2. clear() 全删,无返回值set.clear(); // undefined Set.size=0转换      set换数组：                  Array.from(set);                    [...set]                  数组换set：去重复    // 数组去重const set = new Set(['a','b','a','b']);const ary = [...set]   [... new Set(array)]      遍历  取值：\tset.value / set.entries  forEach( function(value, key, arr))：value = key  for-of： set.value自定义操作：交并差​\tSet 和 Map 一样可以存放各种数据类型作为值，使用 SameValueZero 操作判断是否相等（类似于严格相等===）  并：合并多个set，去重const a = new Set([1,2,3,4,5,3,2,4])const b = new Set([1,2,3,4,5,7,8,9])// 第一种方法new Set([...a,...b]) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}// 第二种方法function union(a, ...bSets){    const unionSet = new Set(a);    for (const b of bSets){        for(const bValue of b){            unionSet.add(bValue);        }    }    return unionSet;}unionf(a, b) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}  差： 展开[a]每个元素过滤掉 b存在 的元素// 第一种方法new Set(\t[...a].filter(function(item){        return !b.has(item);    }))// 第二种方法function difference(a, b) {    const differenceSet = new XSet(a);    for(const bValue of b){        if(b.has(aValue)) differenceSet.delete(bValue);    }    return differenceSet;}  交：展开[a]每个元素过滤掉 b不存在 的元素// 第一种方法new Set(\t[...a].filter(function(item){     \treturn b.has(item);       }))// 第二种方法: 返回两个或更多集合的交集function intersetion(a, ...bSets) {    const intersectionSet = new XSet(a);    for (const aValue of intersectionSet){        for(const b of bSets){            if(!b.has(aValue)) intersectionSet.delete(aValue);        }    }    return intersectionSet;}                              对称差集 ： 所有不属于A∩B的元素的集合，$A△B = {x          x∈A∪B,x∉A∩B} = (A∪B) — (A∩B)$                    function symmetricDifference(a, b){    return a.union(b).difference(a.intersection(b));    // a.union(b) 取全集    // a.intersection(b) 取同时属于a、b交集    // c.difference(d) \t// 全集下不属于交集的部分}  笛卡尔积 ：X×Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对function cartersianProduct(a, b){    const set = new Set();    for(const aValue of a){        for(const bValue of b){            set.add([aValue, bValue]); // 数组的集合        }    }    return set;}  集合的幂集 ：集合中所有的子集（包括全集和空集）构成的集族function powerSet(a){    const powerSet = new Set();    powerSet.add(new Set()); // 包含空集    for(const aVal of a){        for(const set of new Set(powerSet)){            powerSet.add(new Set(set).add(aVal))        }    }}WeakSet值必须是引用类型，保存对象数据。 不是正式引用，不会影响垃圾回收机制。对DOM操作时，DOM节点删除后无需修改WeakSet的引用弱引用类型的特性      强引用类型的特性    对象、数组对同一块内存空间引用时，会将空间引用数+1    当所有对该内存空间引用被置为null时，JavaScript对该内存数据当作垃圾处理，回收空间        弱引用类型的特性    WeakSet作为弱引用类型使用内存空间时，不会将空间引用数+1    当该内存空间引用数为0时，JavaScript对内存回收不会通知WeatSet引用数据不存在    WetSet访问为No propertise    无法使用循环  无法访问.value .key .size等属性  无需将引用赋值为null"
  },
  
  {
    "title": "2.10.集合引用类型（Map）",
    "url": "/posts/2.10.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Map/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-14 00:00:00 +0800",
    





    
    "snippet": "Map &amp; WeakMap不同于Set、对象，Map元素键值对可以为对象、字符串、函数、数字等，但必须是可迭代的数据类型定义const m = new Map() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let map = new Map([    [function(){},\"李四\"],...",
    "content": "Map &amp; WeakMap不同于Set、对象，Map元素键值对可以为对象、字符串、函数、数字等，但必须是可迭代的数据类型定义const m = new Map() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let map = new Map([    [function(){},\"李四\"],    [{},\"王五\"],    [1,\"吴六\"]]);console.log(map); // Map(3)// 使用自定义函数初始化const map2 = new Map({    [Symbol.iterator]: function*() {        yield ['key1','value1'];        yield ['key2','value2'];        yield ['key3','value3'];    }})console.log(mep2.size); // 3增删改查const map = new Map([['firstName','matter'],['lastName','petter']]);// 新增值,返回Map对象,可以链式定义map.set(\"name\",\"张三\").set('age',10)// 查询值 // 1. 通过键查找: map.has(key)map.has('firstName'); // truemap.has('matter'); //false// 2. 返回所有键map.keys();// 3. 返回所有值map.values();// 4. 返回所有键值对map.entries();// 查询个数map.size() // 3// 删除// 1. delete(key) 是否成功删除 map.delet('firstName'); // turemap.delet('firstName'); // false// 2. clear() 全删,无返回值map.clear(); // undefined map.size=0循环Map 实例会维护插入顺序，提供一个迭代器（Iznterator）生成 [key, value]形式的数组。可以使用entries() / Symbol.iterator 获得这个迭代器。因为 entries() 是默认迭代器，所以可以调用 展开操作符，将Map对象转换为数组对象  for循环for(const [key,value] of map.entries()){    console.log(value,key);}for(const pair of map[Symbol.iterator]){    console.log(pair);}map.entries() === map[Symbol.iteratror] // true  forEach循环map.forEache((value,key) =&gt; {    console.log(value,key);},this)修改值​\t—— 键是引用类型时，修改内部数据不影响映射的值// 键为字符串时，修改无效const strMap = ([    ['key1','val1']])for (let key of strMap.keys()){    key = 'newKey';    console.log(key); // newKey    console.log('newKey'); // undefined    console.log(strMap.get('key1')); // val1}// 键为对象属性时，内部映射依然引用相同的地址const objKey = {id:1};const objMap([    [objKey,'val2']])for (let key of objKey.keys()){    key.id = 'newKey';    console.log(key); // {id:\"newKey\"}    console.log(objKey.get(objKey)); // 'val2'}转换      数组 ...map 或者 [... map]        利用数组过滤器    [... map].filter(item =&gt; {return item[1].include(\"111\")} ) // item[1] 指键名        转换回map类型  与Object相比的优势  内存占用（多存储）：在给定固定内存大小里，Map 可以比 Object 多存储 50% 的键值对  插入性能（快）：消耗大致相当  查找速度（性能差异小）：Object 在类数组使用的情况下，更快  删除性能          删除 object  只能使用 伪删除对象属性的操作， 值设置为undefined 或者 null      删除 map ，delete() 操作比插入和查找更快      使用场景  ​\t表单提交前，检查某些元素的状态，当返回值是false时，阻止提交并跳出弹窗function post(){    let map = new Map();    let inputs = document.querySelectorAll(\"[error]\");    inputs.forEach(item =&gt; {        map.set(item,{            error:item.getAttribute(\"error\"),            status:item.checked        })    })}return [...map].every(([elem,config])=&gt;{    config.status || alert(config.error); // 或 短路运算    // 已勾选status=true，退出判断；    // 否则，未勾选status=false，执行第二个语句，跳出弹窗    return config.status;})weakMap键只能是 Object 或者 Object类型，其他非对象设置为键会抛出 TypeError； 值的设置没有限制// 初始化 是一个全有全无的操作const wm = new WeakMap([    [key1, 'val1'], [key2, 'val2'], ['errkey', 'val3'] // 'errkey' 将导致初始化失败])// 但可以先把原始值包装成对象再作为键const objStr = new String('errKey');wm.set(objStr, 'val3')// weakMap 拥有于 Map 相似的方法；但没有 clear() —— 随时都可以被销毁  弱键： 键不属于正式引用，不会阻止垃圾回收； 值的引用，属于正式引用，影响垃圾回收只要存在键值对于映射中，并当作对值的引用，值就不会被垃圾回收。  不可迭代键：不能在不知对象引用的情况下从弱映射中获得值。之所以限制 只能用Object 作为键，是为了保证通过 键对象引用（内存唯一值）才能取得值使用weakMap私有变量私有变量存储在弱映射中，以对象实例为键，以私有成员为值const User = (() =&gt; {    const wm = new WeakMap(); // 闭包内的wakMap 不暴露在外，统一实例才使用同一个weakMap    // 且生存时间与实例同步，而不是与类同步    class User {        // ...        setPrivate(property, value){            const privaterMembers = wm.get(this) || {}; // 获取当前实例            privaterMembers[property] = value; // weakMap 新增键值对            wm.set(this, privaterMembers); // 返回weakMap        }        getPrivate(property) {\t\t\treturn wm.get(this)[property]        }        // ...    };    return User;})();// cosnt User = ()()const user = new User('张三');user.getPrivate(id);不使用闭包，直接定义 class，外部可以通过对象实例的引用获得私有变量// wm 在 外部定义，使用同一个weakmap，可以通过实例获取wm.get(user)[user.getPrivate];但也是代码完全陷入ES6之前的 闭包私有变量模式操作DOM元素对象&lt;div name=\"1\"&gt;11&lt;/div&gt;&lt;div name=\"2\"&gt;22&lt;/div&gt;使用 Map 关联元数据：let map = new Map();// 对应DOM中每个div元素对象，存入Map中，后续不需要操作DOM直接操作Mapdocument.querySelectorAll(\"div\").forEach(item =&gt;{    map.set(item,{        content1:item.getAttribute(\"name\"),        content2:item.innerHTML    })})// map:Map(2) [[Entries]] 0:{div=&gt; Object}// 0:{key:div, value: {content:\"1\",content2:\"11\"}}console.log(map);map.forEach((config, elem)=&gt;{    // map.item --        // this:undefined        // config:{content1:\"1\", content2:\"11\"}        // elem: div    elem.addEventListener(\"click\", ()=&gt;{        alert(config.content1)    })})​\t存在问题： 当关联的元数据从DOM树删除后，其值依然被 Map实例 引用而不能删除，所以对应的DOM节点依然滞留在内存中，除非明确销毁​\t使用弱映射是，代码执行完毕 weakmap 被回收，没有实例引用DOM节点，这其从DOM树删除后就可以立即释放内存let wm = new WeakMap();const fistDIV = document.querySelector('div');wm.set(firstDIV,{disable: true});firstDIV.remove()"
  },
  
  {
    "title": "2.9.基本引用类型（Array）",
    "url": "/posts/2.9.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Array/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-12 00:00:00 +0800",
    





    
    "snippet": "Array1️⃣ 有序； 2️⃣ 每一个项可以保存任何类型的数据； 3️⃣ 动态大小，自动增长基本操作  创建：          new Array  可以忽略new声明数组，效果一样      ['value1', 'value2']  与Object一样，不会调用构造函数      Array.from(arrayLike, mapFun, thisArg)  类数组结构 → 数组实例...",
    "content": "Array1️⃣ 有序； 2️⃣ 每一个项可以保存任何类型的数据； 3️⃣ 动态大小，自动增长基本操作  创建：          new Array  可以忽略new声明数组，效果一样      ['value1', 'value2']  与Object一样，不会调用构造函数      Array.from(arrayLike, mapFun, thisArg)  类数组结构 → 数组实例 （浅复制）                  arrayLike — 想要转换成数组的伪数组对象或可迭代对象                          伪数组对象（拥有一个 length 属性、可索引元素结果的对象）              可迭代对象（Set Map等）                                mapFun — [可选] 新数组中的每个元素会执行该回调函数          thisArg — [可选] 执行回调函数mapFun时的this对象                    Array.of() 一组参数 → 数组实例                  代替 Array.prototype.slice.call(arguments) 将对象转为数组的方法                      取值：基于0开始的 数字索引  长度 length （不仅是可读属性）          0 ≤ length      移动至 length = length-1 删除最后一个元素      移动至 length = length+1添加最后一个元素        判断： isArray()          使用instanceof 判断是否处于同一个继承链中，在封装过Array构造函数后的情况下，数组会不相同      isArray() 不论哪个全局执行上下文中创建，也可能判断是否为数组      数组空位 const options = [,,,,,]; // 使用一串逗号来创建空位ES6中， 会将空位视为 存在的元素，值为undefinedES6之前，将空位忽略，或视为空字符串 —— 行为不同、存在与否，会导致不同平台出现问题​\t如果需要空位，可以用显示的undefined值代替查找严格相等查找 （===比较）  indexOf('') &amp; lastIndexOf('')：从0开始，不存在返回 -1  includes('', start)： 返回true / false断言函数查找（短路判断）  find &amp; findIndex：短路查找，不存在返回undefined过滤  .some() &amp; every() ：短路遍历，返回Boolean  filter          对于引用类型，返回 false（比较地址）      变量所有元素，返回 新数组      返回值：true，将currentValue加入新数组；false，跳过currentValue      const newList = array.filter( function( currentValue, index, arr ) {\t// ...    // return currentValue % 2 === 0 返回偶数    return})// 箭头函数array.filter( (currentValue, index, arr) =&gt; current*2 )填充 &amp; 复制🚩 连接：      arr.concat()                    传值：添加到arr后面，返回新数组                    传数组：数组的每一项添加到arr后面，返回新数组                  打平：是去掉中括号 Symbol.isConcatSpreadable                arr = ['red','green']     // 不打平追加arr1 = [1,2,3]arr1[Symbol.isConcatSpreadable] = falsearr.concat('yellow',arr1) // ['red','green','yellow',[1,2,3]]     // 打平追加arr2 = [4,5,6]arr2[Symbol.isConcatSpreadable] = truearr.concat('yellow',arr2) // ['red','green','yellow',4,5,6]                          展开语法 arr[...arr, ...arr2]  🚩 复制  slice(start, end) — 提取指定位置的数据，返回一个新数组（字符串也可用）          结束位置 &lt; 开始位置，返回空数组        copyWithin(target, start, end)  （ES6 新增方法）          浅复制数组（对象复制引用）一部分到同一数组中的另一个位置，并返回它      参数说明：必须为整数                  target：指定复制序列的位置；                          负数，从末尾计算；≥arr.lenght，不发生拷贝              target在start之后，复制序列复制的序列将被修改以符合arr.lenght                                start： 开始复制元素的起始位置                          负数，从末尾计算；无值，从0开始复制                                end：结束复制元素的位置                          负数，从末尾开始计算；无值，直至数组结束                                          不会改变原数组的长度：超过长度、零长度、方向相反，不报错且不处理      🚩 替换  array.fill(value, start, end) —  固定值替换数组的元素          参数说明：必须为整数                  target：指定复制序列的位置；                          负数，从末尾计算；≥arr.lenght，不发生拷贝              target在start之后，复制序列复制的序列将被修改以符合arr.lenght                                start： 开始复制元素的起始位置                          负数，从末尾计算；无值，从0开始复制                                end：结束复制元素的位置                          负数，从末尾开始计算；无值，直至数组结束                                          不会改变原数组的长度：超过长度、零长度、方向相反，不报错且不处理      🚩 splic(start, delectNum, end) ， 改变原数组，返回处理后的数组      删除 splice(start, num) 返回删除[start],[start+1]…[start+num]，无删除的数据返回空数组        插入 splice(start,0,interItem) 从开始位置，删除0项，插入数据        替换 splict(start,num,iterItem)  转换  字符串转为数组 — 字符串具有length属性          str.split(‘指定拆分符’)      arr.from(str, mapFun)      ...\"abcd\" == ['a','b','c','d']        数组转为字符串          toString()、valueOf()、alert() — 为数组每一项调用 toString()      toLocaleString() — 每一项调用toLocalString()      join(\"指定连接符\") — 某一项是null、undefind，返回结果是以空字符串表示        对象转为数组          为对象添加length属性，key值改为数组下标相同      栈队方法  栈          push推入 — 接受任意数量的参数，逐个添加到末尾，返回修改后的数组长度      pop弹出 — 移除末尾最后一项，减少length值，返回移除项        队          push + shift — 移除第一项，减少length值，返回移除项      pop + unshift — 前端添加任意项，返回数组长度， 反方向模拟队列        展开语法： array = [...array,...hd];重排序​\t都返回调用数值的引用  reverse() ： 反转数组项顺序  sort() : 升序排列数组项          默认情况下，调用每项的toString()，比较得到的字符串，所以可能出现$ 10&lt;5 $ 的情况      可以 接受一个比较函数作为参数：      // 比较值为字符串// a&lt;b -1, a在前面； a&gt;b 1,a在后面；a=b 0,ab相等value.sort((a,b) =&gt; a &lt; b? 1 : a &gt; b? -1: 0)// 比较值为数值value.sort((a,b) =&gt; b-a)循环1. forfor(let i = 0; i &lt; arr.length; i++){}​\t同理，还有while、do…while，常用于数组遍历2. for … inlet obj = {name:'zhou',age:'**'}for(let i in obj) { console.log(i, obj[i])}  i 是对象的key值，是字符串形式，可能会发生 字符串运算  不仅仅遍历自身属性，还会找prototype上的属性；加判断obj[i].hasOwnProperty(i)，否则不遍历3. forEacharr.forEach(function(item, index),this){}let arr = [1,2,3];arr.forEach(function(i,index){ console.log(i,index)})  没有返回值  不能中断遍历（没有break语句）；使用try...catch{return}返回  只能遍历数组，不能遍历普通对象4. maparr.map(function(item, index, arr),this){}//item\t[必须],当前遍历项//index\t[可选],当前遍历项的下标//arr\t[可选],当前元素所属的数组对象let arr = [1,2,3];let tt = arr.map(function(i){ console.log(i) return i*2;})  【与forEach一样】没有返回值  不能中断遍历（没有break语句）；使用try...catch{return}返回  只能遍历数组，不能遍历普通对象5. filter​\t对于引用类型的比较，返回false，因为比较的是引用地址​\t回调函数中，返回值为 true，currentValue将加入新数组；false，跳过currentValuearr.filiter(function(item, index, arr){    // ...    // return currentValue % 2 === 0 返回偶数    return})let arr = [1,2,3];let tt = arr.filter(function(i) =&gt; i &gt; 1)// [2,3]  数组的内置方法，返回通过过滤的元素组成的新数组，不改变原数组6. some &amp; everylet arr = [1,2,3];// 【some】let tt = arr.some(function(i){ return i&gt;1;})// true, 存在一个就为true，短路判断// 【every】let tt = arr.every(function(i){ return i&gt;1;})// false, 任意一个都需要满足，否则为false，短路判断7.  reduce &amp; reduceRightarr.reduce(function(pre, cur, index, arr){}, this){}//pre\t[必须] 初始值，计算结束后返回的值，且作为下次循环调用的第一个参数//cur\t[必须] 当前元素//index\t[可选] 当前元素的下标//arr\t[可选] 当前元素所属的数组//this\t[可选]let arr = [1,2,3];let ad = arr.reduce(function(i,j){ return i+j;     //就是计算从左到右 1+2+3})// 6  reduce（从左到右）计算数组中的每一个值，最终计算为一个值。  reduceRight （从右到左）8. for … offor (variable of iterable) {    //statements}  可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 9. 迭代器 iterator​\t表示”集合”的数据结构，有一个统一的接口机制完成遍历操作（依次处理该数据结构的所有成员），叫做Iterator接口。  迭代器对象的本质是一个 指针对象，使用.next()移动指针，会有两个结果          下一项，返回对象                  当前成员数据信息(value)          是否完成遍历(done — Boolean)          value:undefined + done:fale  都是可以省略的                    引起stopiteration 异常        Iterator接口在ES6规定中，定义在Symbol.iterator上          具有这个iterato属性，可以认为是”可遍历的”      调用Symbol.iterator会得到当前数据结构默认的遍历器生成的函数      Symbol.iterator本身是一个表达式，返回iterator属性      while( ({value, done} = values.next())  &amp;&amp; done === false) {}// ({value, done} = values.next()) 在括号内，先执行，获得done，判断是否已经完成迭代，避免死循环10.迭代器 entries​\tObject.entries(obj)方法  将一个给定对象obj自身，可枚举属性的键值对以数组的形式返回出来，  其排列与使用 for...in 循环遍历该对象时返回的顺序一致  （区别在于 for-in 循环还会枚举原型链中的属性）而entries不会。const obj = {'a':'3',b:'39'};let objEntries = Object.entries(obj); //[ [ 'a', '3' ], [ 'b', '39' ] ]const arr = [2,9,38,30]console.log(Object.entries(arr)); //[ [ '0', 2 ], [ '1', 9 ] ]Array.prototype.entries()方法  返回一个新的Array迭代器对象Array Iterator对象，该对象包含数组中每个索引的键/值对  Object [Array Iterator] {}  Array Iterator原型是有一个next方法，可以用于遍历迭代器取得的原数组的[key, value]const arr = [2,9]// Array.prototype.entries() let entries = arr.entries(); // 返回Object [Array Iterator] {}let {done, value} = entries.next(); // { value: [ 1, 9 ], done: false }// 数组遍历循环for(const [key,value] of arr.entries()){    console.log(`${key}+${value}`);    //0+2 1+9}清空数组  splice(0, arr.length) — 从零开始，删除至最后一个  arr.length == 0          == lenght+2， 多出来的2个元素 ，赋值为undefined      == lenght-2，减少的2个元素，后面的2个元素被删除        arr = [] — 重置引用，之前的数组等待垃圾回收  while(arr.pop()) — 非0的值，都为trueTyped Array"
  },
  
  {
    "title": "2.7.基本引用类型（Date）",
    "url": "/posts/2.7.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Date/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-10 00:00:00 +0800",
    





    
    "snippet": "日期 Date​\t\tDate类型将日期保存为 自协调世界时（UTC，UNiversal Time Coordinated）：1970年1月1日00时至今所经历的毫秒数。      创建          new Date — ①无参数，获取创建时日期时间；②或传递日期 时间的 毫秒数        若想传入指定日期的值，而不是毫秒数，有两个辅助函数：          Date.parse(...",
    "content": "日期 Date​\t\tDate类型将日期保存为 自协调世界时（UTC，UNiversal Time Coordinated）：1970年1月1日00时至今所经历的毫秒数。      创建          new Date — ①无参数，获取创建时日期时间；②或传递日期 时间的 毫秒数        若想传入指定日期的值，而不是毫秒数，有两个辅助函数：          Date.parse() — 接受字符串                  格式： ①\"mouth/day/year\" ②mouthEnglish day,year ③weekEnglish mouthEnglish day year h:m:s 时区           直接传 字符串给Date(“May 22,22”)也会调用Date.parse()          字符串不能代表日期，返回NaN                    Date.UTC(year, mouth, [day, h, m, s, ms]) — 基于本地时区                  年份、月份为必须          月份从0开始，日期从1开始，小时从0开始                      创建一个新Date对象的唯一方法是通过new 操作符，例如：let now = new Date(); 若将它作为常规函数调用（即不加 new 操作符），将返回一个字符串，而非 Date 对象。  const time = new Date();console.log(typeof time); //Objectconsole.log(time * 1);\t// 时间戳const time1 = Date()console.log(typeof time1); //stringconsole.log(time1 * 1);\t// NaN  其他操作            转化为字符串                                              普通字符串      系统区域设置格式      特殊地区时间              日期      toDateString()      toLocalDateString()      toUTCString() 全球标准时间              时间      toTimeString()      toLocalTimeString()      toGMTString() 格林威治时间      ​\t以上方法输出的时间格式因浏览器而异，不能用于在用户界面上一致地显示日期            转为时间戳                         标准时间对象 * 1      Number(标准时间对象)              标准时间对象.valueOf()      标准时间对象.gerTime()      时间戳转为标准时间对象 — new Date(时间戳)  toString 和 toLocaleString 的区别  1.当数字是四位数及以上时，有区别  ​\ttoLocaleString()会让数字三位三位一分隔  2.当目标是标准时间格式时，有区别  sd.toLocaleString()“2017/2/15 上午11:21:31”  sd.toString()“Wed Feb 15 2017 11:21:31 GMT+0800 (CST)”  查询脚本执行时间  定义标志位：console.time(“for”)  定义结束标志位： console.timeEnd(“for”)格式化时间对象function dateFormat(date, format = 'YYYY年MM月DD日 HH:mm:ss'){    const config = {        YYYY: date.getFullYear(),        MM: date.getMonth(),        DD: date.getDate(),        HH: date.getHours(),        mm: date.getMinutes(),        ss: date.getSeconds()    };    for(const key in config){        format = format.replace(key, config[key]);    }    console.log(format);    return format;}const time = new Date();let time3 = dateFormat(time)   // 2022年7月30日 17:38:48日期对象比较大小：毫秒数let lastDay = new Date()let toDay = new Date()lastDay &lt; toDay  // 距离1970年的毫秒数比较  时间封装 第三方库  www.momentjs.cm"
  },
  
  {
    "title": "2.6.基本引用类型（RegExp）",
    "url": "/posts/2.6.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-RegExp/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-08 00:00:00 +0800",
    





    
    "snippet": "正则表达式 RegExp​\t声明和定义：/pattern/flages 或 new RegExp(\"pattern\",\"tage\")      tage ：          g：全局模式，查找全部内容      i：不区分大小写      m：多行模式，查找到第一行文本末尾还会继续      y：粘附模式，只查到从lastIndex开始之后的字符串      u：Unicode模式    ...",
    "content": "正则表达式 RegExp​\t声明和定义：/pattern/flages 或 new RegExp(\"pattern\",\"tage\")      tage ：          g：全局模式，查找全部内容      i：不区分大小写      m：多行模式，查找到第一行文本末尾还会继续      y：粘附模式，只查到从lastIndex开始之后的字符串      u：Unicode模式      s：dotAll 模式，表示元字符.匹配任何字符。/s出现空白就匹配； /S非空白就匹配；[/s/S]换行完全匹配            元字符转义    在RegExp构造函数中，两个参数都是字符串，所以元字符需要二次转义        实例属性：提供模式的各方面信息          global：Boolean，是否设置了g标志      ignoreCase：Boolean，是否设置了i标志      unicode：Boolean，是否设置了u标志      sticky：Boolean，是否设置了y标志      lastIndex：int，源字符串在下次搜索的开始位置，始终从0开始      multiline：Boolean，是否设置了m标志      dotAll：Boolean，是否这是了s标志      source：正则实例的pattern（字面量）      flags：标记字符串，始终以字面量而非传入构造函数的字符串形势返回（没有前后斜杠）            实例方法：exec() 配合捕获组，接受要查找的目标字符串                  存在匹配项，返回第一个匹配信息的数组；                  返回值是Array实例，但包含两个额外属性：index  和 input                          index 表示模式匹配的起始位置； input 是查找到的字符串                                Array实例，第一个元素包含 匹配整个模式的字符串，其他元素包含 表达式中捕获组匹配的字符串；如果没有捕获组，就只有一个元素                          捕获组 pattern = /妈妈(和爸爸(和孩子)?)?/gi  和 ‘妈妈和爸爸和孩子’，存在三个元素                                  array[0] = 妈妈和爸爸和孩子                  array[1] = 和爸爸和孩子                  array[2] = 和孩子                                                                                不存在匹配项，返回null                    不同的tage在exce下的表现                              没有设置全局变量，只会返回第一个匹配项，lastIndex不变；            设置了全局变量，每次调用exec都在字符串向前搜索下一个匹配项，lastIndex每次都会变化，直至末尾                                设置粘附模式，每次只会在lastIndex的位置上寻找匹配项；            找不到匹配项，exce() 返回 null，lastIndex = 0                                    实例方法： test()只在乎输入是否有效，而不在乎内容且无什么无效        构造函数方法（静态属性）：提取exec()和 test()执行的操作相关信息              $1 - $9 ：取出存储的9个捕获组匹配项        使用方法：  const pattern = /hort/g;const text = 'this has been a short summer' RegExp.input;  // this has been a short summer = RegExp.&amp;_;RegExp.leftContext; // this has been a = RegExp[$`]; //`RegExp.rightContext; // summer = RegExp[$']RegExp.$1; //'and dad and baby'"
  },
  
  {
    "title": "2.4.基本数据类型（String）",
    "url": "/posts/2.4.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-String/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-07 00:00:00 +0800",
    





    
    "snippet": "字符串 String固有属性： length属性，取长度重复输出：repeat(n)，重复n次，返回一个新字符串码元组成（U+0000 ~ U+FFFF范围内的字符）基本多语言平面（BMP) ：由16位码元（code unit）组成一个字符            函数      返回值                  charAt( index )      指定16位码元的指定位置，返回...",
    "content": "字符串 String固有属性： length属性，取长度重复输出：repeat(n)，重复n次，返回一个新字符串码元组成（U+0000 ~ U+FFFF范围内的字符）基本多语言平面（BMP) ：由16位码元（code unit）组成一个字符            函数      返回值                  charAt( index )      指定16位码元的指定位置，返回其对应字符              charCodeAt( index )      指定位置的码元值              fromCharCode( 码元1, 码元2, …)      根据数值对应字符拼接起来，返回字符串      代码对 = 基本多语言平面 + 增补平面 ：需要由另外16位码元组成，2×16=32位组成一个字符                                             codePointAt( index )      指定16位码元的指定位置，识别完整的码点                     codePointAt( index )      指定位置的码元值                     fromCodePoint( 码元1, 码元2, …)      根据数值对应字符拼接起来，返回字符串             码点（codePoint）是Unicode中一个字符的完整标识。如果传入的码元索引不是代理对的开始，就会返回错误的码点。这种错误只有检查单个字符时出现。console.log([...'abcv①']) // ['a', 'b', 'c', 'v', '①']迭代字符串可以智能识别代码对的码点编码方式​\tUnicode提供4种规范化形式：NFD(Normalization From D) 、NFC(Normalization From D)、NFKD(Normalization From KD)、NFKC(Normalization From KD)​\tString.normalize(NFD) 根据传入的模式，返回Boolean值，判断是否以规范化转换  toString()： null、undefined不能用；参数是转出数值的基数  String()：可以转任何类型          可以转化的，调用toString()      null，返回null      undefined，返回undefined      截取                   参数      正数      负数                  slice      (start, end)      [start, end)      [start, length+(-end)+1)              subString      (start, end)      [start, end)      将所有负数视为0，输出[0,start] == [start,0]              subStr      (start, strNumber)      [start, length)      第一个负参数当作length+end，之后的所有负参数都转为0start&gt;0, length&lt;=0, 返回''      检索  indexOf('') &amp; lastIndexOf('')：从0开始，不存在返回-1  includes('', start)： 返回true / false，检索整个字符串  startsWith &amp; endWith ：是否在字符串头部 / 尾部出现          start：第二个参数表示开始位置      end：第二个参数表示字符串末尾的位置        .some() &amp; every() ：短路遍历                                             指定字符的位置，不存在返回-1      indexOf(‘’)      lastIndex(‘’)              是否包含指定字符，返回Boolean      includes(“char”, startIndex)                     指定字符串是否出现在头部/尾部      startsWith(‘hello’)      endWith(‘hello’)              遍历，短路判断      .some(‘’=&gt;{}) 存在      .every(‘’=&gt;{}) 任意      替换      arr.replace(searchvalue, newValue)                  searchvalue 可以是正则表达式，也可以是字符串                    newValue 是字符串的情况下，可以使用 字符序列 ，使用之前匹配的内容：        let text = 'cat, bat, sat, fat';result = text.replace('/(.at)/g',\"word($1)\")result // 'word(cat), word(bat), word(sat), word(fat)' 返回一个字符串                            newValue 可以是一个函数，接受3个参数，可以有多个捕获组match，但最后两个参数还是与整个匹配模式的开始位置和原始字符串        str.replace(/[&lt;&gt;\"&amp;]/g,function(match, pos, originalText){    switch(match){        case \"&lt;\" : return '&amp;lt;';        case \"&gt;\" : return '&amp;gt;';        case \"&amp;\" : return '&amp;amp;';                }})                          str.reduce()          (function(...),0)： 第二个参数指定了pre的初始值不再是word/arry[0],而是第二个参数的值      pre.replace(word,)：对目标字符串中的与关键字列表相同的字段进行替换操作      数组同，可做引用引用对象等Max/Min比较            match(regexp) ： 参数与返回类型等同于exec()，返回查找位置        trim()：不影响原字符串， 删除前、后所有空格符； trimLeft()&amp;trimRight() 从开始/末尾清理空格符        padStart(targetLengh, padString) &amp; padEnd(targetLengh, padString) 复制字符串          第一个参数是目标长度；第二个参数指定填充的字符（默认为‘’ “空格0）      迭代​\tString 在原型中暴露一个@@interator方法，表示可以迭代字符串中的每个字符let message = 'abc';let stringIterator = massage[Symbol.iterator]();stringIterator.next(); [value:'a',done: false]// ... 模板字符串（ES6）​\t使用反引号定义 ​\t字符串连接： 'str1' + 'str2'1. 解析变量`${字符串1}成立与${字符串2}`2. 可调用函数：显示代码执行的返回值`www.${show()}`3. 可拼接&lt;&gt;`&lt;ul&gt; ... &lt;/ul&gt;`4. 可嵌套模板字面量,可换行、排版友好let html = `&lt;ul&gt;\t&lt;li&gt;${result.name}&lt;/li&gt;    &lt;li&gt;${result.age}&lt;/li&gt;    &lt;li&gt;${result.sex}&lt;/li&gt;&lt;/ul&gt;`"
  },
  
  {
    "title": "2.3.基本数据类型（Number）",
    "url": "/posts/2.3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Number/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-05 00:00:00 +0800",
    





    
    "snippet": "特殊数字number的数字进制      二进制：0b        八进制：0        十六进制：0x  number的最大值最小值      最大值： Number.MAX_VALUE        最小值：Number.MIN_VALUE  无穷大 无穷小  无穷大：Infinity — 大于最大值  无穷小：-Infinity — 小于最小值  NaN，代表非数值       ...",
    "content": "特殊数字number的数字进制      二进制：0b        八进制：0        十六进制：0x  number的最大值最小值      最大值： Number.MAX_VALUE        最小值：Number.MIN_VALUE  无穷大 无穷小  无穷大：Infinity — 大于最大值  无穷小：-Infinity — 小于最小值  NaN，代表非数值          本应该返回数值的操作数，未返回操作数      NaN != NaN 不等于任何数      判断      数字的类型 Number.isInteger()：是否为整数        是否为NaN：          Number.isNaN();                  true：表示非数字，任何不能转为数值的值： NaN、”blue“          不是NaN， false                    Object.is(,NaN)            判断是否是 安全整数：    ​\t在 Number.MIN_SAFE_INTEGER （$-2^{53}+1$）到 Number.MAX_SAFE_INTEGER （$2^{53}-1$） 范围内二进制值可以表示一个整数值。超出这个范围，即使尝试保存为整数，也会保存成一个错误的完全不同的数值。    ​\t判断是否在安全范围内，可以使用 Number.isSafeInteger()，返回 true    0.1 + 0.2 ≠ 0.3 问题  转化      parseInt() 和 parseFloat()，专门为字符串转数字          忽略字符串的空格，直到找到第一个非空格字符      空字符串\"\"，没有数字字符串（如'blue'）， 转化结果为NaN      可将数字开头的字符串删去后边非字符串的部分，仅保留数字      对于Int，小数点不是有效数字字符      对于Float，第二个小数点不是有效数字字符            Number()可以转任何类型为数字，要求字符串需为数字字符串                                                                                         Boolean          true=1          false=0                          Number          Number原值                                     null          0                                     undefined          NaN                                     String          空字符串          0                                     只包含数值          十进制数                                     包含有效浮点数          忽略前置0，转为浮点数                                     包含Ox的数值          十六进制数                                     包含Ox的数值          二进制数                                     除此之外          NaN                          Object          :one: ValueOf() 转          若为NaN                                     :two: toString() 转                                     toString 接受一个表示基数的参数，返回相应基数形式的数值字符串        toFixed() toExponential() toPrecision() 调整小数位精确表示数值：          toFixed()： 指定小数点位，不足用0填充；超过位数，四舍五入。      toExponential()：科学计数法，指定小数的位数。99.toExponential(1) = 1e+2      toPrecision()：根据数值和精度决定调用toFixed()还是 toExponential()      Number对象 &amp;Number值​\t存在着和 Boolean 同样的问题。0.1+0.2 ≠ 0.3​\t原因： 采取 IEEE-754 64位双精度 浮点数存储， Javascript、 Java 、python等语言都存在这个问题​\t一个浮点数占64个bit，由符号位（0为正，1为负）、指数部分（确定小数点在第几位）、数值部分      指数部分，使用 移码表示法          11bit 指数代表的大小 $e=2^0+2^1+\\cdots+2^{11}$，第一位 $2^0$ 为隐藏位，一定为1（规范数）      小数位置 $p = e -1023$ （1023 = 指数部分 bit 都为 1）              $p=1075-1023=52$时， 所有数值部分都被用来表示整数；52bit 全为1时，是能够表示的最大数值 9007199254740991                  $max +1 = 9007199254740992$ : 小数点向右移动一位 p=53，隐藏位（第12bit）=1，整数部分（53bit）为0 —— 第53bit 不存在只能为0                          $9007199254740992+1$ ：第53bit 无法修改为1，无法加2              $9007199254740992+2$ ：第52bit = 1， 53bit = 0（无法改变）              $9007199254740992+3$ ：第53bit 无法修改为1，无法加4              …… 以2为间隔相加                                小数点位为53，第45bit &amp; 第54bit = 0 无法改变，只能以4为间隔相加          之后的数值都无法完整表示，任何计算都会出错                            小数点位越过隐藏位（第11bit），所有数值部分都被用来表示小数；                  隐藏位固定值为1时（规范数），表示的数一直都是 $2^{-1}$ 幂次，值可能非常小，但一直有值                    指数部分的极端情况：                  符号位1、0  + 指数部分都为`0` + 隐藏位为0 + 数据部分都为0 = ±0 —— 非规范数          符号位1、0  + 指数部分都为`1`  + + 数据部分都为0 = ±infinity          符号位1、0  + 指数部分都为`1`  + + 数据部分存在1 = NaN（typeof NaN = ”number“，存在1的关系 可以有多种NaN）                          数字部分：小数位置将数值部分分为 整数和小数          小数值 $x = 2^{-1} + 2^{-2} + \\cdots + 2^{-n}$`                  并非所有小数都是可以为 $ 2^{-n}$ 直接表示          如 $0.1 \\approx 2^{-4} + 2^{-5} + 2^{-5} + \\cdots + 2^{-47}$， 51bit 只得到一个无限近似于 0.1 的值，已经存在误差          用 $2^{-n}$ 相加得到小数， 当 $p=1074 - 1023 = 51$，只留给小数值 1bit 时，只能表示 0.5                    整数部分：            数字 ±0：除符号位，其他bit = 0 ，包括隐藏位，所以是非规范数  "
  },
  
  {
    "title": "2.2.基本数据类型（Boolean）",
    "url": "/posts/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Boolean/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-03 00:00:00 +0800",
    





    
    "snippet": "Boolean            Boolean()      true      false                  string      非空串 “ ”      “” 空串              number      非零值（包括无穷）      0 、 NaN              Object      对象      null              ...",
    "content": "Boolean            Boolean()      true      false                  string      非空串 “ ”      “” 空串              number      非零值（包括无穷）      0 、 NaN              Object      对象      null              undefined      -      undefined              数值 Array      数组（空数组）      ![]  先转为空串，再取反        隐式转换：两步取反：转换+取反+取反Boolean对象 &amp; Boolean值​\ttypeof 操作符对 Boolean值（原始值）返回 ‘boolean’，对Boolean对象返回 ‘object’​\tBoolean对象是Boolean类型的实例，而Boolean值（原始值）不是typeof booleanObject;\t// objecttypeof booleanValue;\t// booleanbooleanObject instanceof Boolean; // truebooleanValue instanceof Boolean; // false​\t在判断中转换的值不同：booleanObject &amp;&amp; false // true, object = truelet booleanValue = falsebooleanValue &amp;&amp; true // false🌞  强烈不建议使用 Boolean对象"
  },
  
  {
    "title": "2. 数据类型",
    "url": "/posts/2.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-01 00:00:00 +0800",
    





    
    "snippet": "  基本数据类型：          undefined &amp; null      number      boolean      string        基本引用类型：          原始值包装类型      RegExp      Date      单例内置对象        集合引用类型：          Array &amp; TypeArray      Map...",
    "content": "  基本数据类型：          undefined &amp; null      number      boolean      string        基本引用类型：          原始值包装类型      RegExp      Date      单例内置对象        集合引用类型：          Array &amp; TypeArray      Map   &amp; weakMap      Set   &amp; weakSet      基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中      引用存放到新变量栈中，操作同一个地址              分配机制      自动分配，大小固定      动态分配，可指向同一块引用              回收机制      回收及时，生存时间固定      根据引用次数交给回收器回收      回收机制​\tJavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。​\t最主要的标记策略：标记清理和引用计数值类型的判断  typeof： 一元运算，返回String — 判断引用类型时，只会返回object  instanceof： 判断是否在原型链上prototypeobject instanceof contructor     -- 判断object的原型链上是否存在constructor.prototype\t-- object 一定要是一个对象    -- contructor 一定要是一个函数      值定义：          引用类型        let number = new Number(99);number.valueOf()+1              值类型        ler number = 99;number+1;        对于值类型使用.方法时，会在原型链中调用对象的方法（转换为对象）    两者会结合封装成一个工具类function getDataType(obj) {  if (obj === null) {    return 'null';  } else if (typeof obj === 'object') {    if (obj instanceof Array) {      return 'array';    } else {      return 'object';    }  } else {    return typeof obj;  }}undefined &amp; null  undefined ：声明但未赋值  null：执行空对象指针🌞 undefined 派生自 null，undefined == null❗ 原始值包装类型​\t每当用到某个原始值的方法或属性是，后台会创建一个相应原始包装类型的对象，使得原始值具有操作属性的各种方法。​\tECMAscript提供了三种特殊的引用类型：Boolean 、Number、Stringlet str1 = new String('text string') // 原始值 str1let str2 = str1.length;  // 访问到 str1 中的属性 —— 只读的模式str2 以只读的模式访问 str1 在内存中保存的值，后台会执行以下三个操作：​\t :one: 创建String实例 :two:调用实例上的特点方法  :three:销毁实例作用域​\t引用类型和原始值包装类型主要区别在于对象的生命周期：​\t自动创建的原始值包装类型对象，只存在于访问它的那行代码执行期内。即不能在运行时给它添加属性和方法。let str1 = new String('text string') // 原始值 str1str1.color('red');console.log(str1.color); // undefined第二行代码尝试给 原始值新增属性str1.color，但第三行访问不到：  第二行代码访问到的String对象是临时的，已经被销毁  第三行代码中创建了新的自己String对象，但这个对象没有这个属性类型转换​\t可以使用Boolean 、Number、String构造函数显式原始值包装类型，但不建议let str = '30'typeof str; //'string'// 转型函数let num = Number(str) typeof num; // 'number'// 构造函数let obj = new Number(str)typeof obj; // 'object'❗ 单例内置对象​\tECMA-262中，对内置对象的定义：任何由ECMAScript实现提供、与宿主环境无关，并在程序开始执行是就存在的对象。​\t\t可以直接使用，而无需创建实例 ——无法在显性地实例化内置对象（在运行时就存在对象），包括Object、Array、String、Global、Math兜底对象 Global​\tECMA-262规定，Global对象为兜底对象，所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数，都是Global的属性。​\t包括 isNan() 、isFinite() 、parseFloat() 等​\t在 浏览器中，window对象实现为Global对象的代理。所有全局作用域中声明的变量和函数都变成了window属性。URL 编码方法            encodeURL()      encodeURLComponent()                  对整个URL编码      编码URL中单独的组件              不编码属于URL组件的特殊字符      编码所有非标准字符      ​\tdecodeURL() &amp; decodeURLComponent()  同上eval 方法​\t完整的ECMScript解释器，接受一个字符串（要执行的ECMAScript语句）。运行时，才将参数解释为ECMAScript语句，并插入到该位置，调用代码所在的上下文 —— 被执行的代码与该上下文拥有同样的作用域链。​\t但定义的任何变量和函数都不会被提升：解析代码时候，ECMAScript语句仅仅作为一个字符串，只有在执行是才会被创建。​\t在严格模式下，eval() 内部创建的变量和函数无法被外部访问。必须非常慎重使用。在解释用户输入等不可控字符串时，可能被植入执行语句Global 对象属性  所有原生引用类型构造函数；  特殊值：NaN Undefined infinity；  Error构造函数；"
  },
  
  {
    "title": "1. 变量",
    "url": "/posts/1.%E5%8F%98%E9%87%8F/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-01 00:00:00 +0800",
    





    
    "snippet": "数据类型基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中，两个变量互不干扰      引用存放到新...",
    "content": "数据类型基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中，两个变量互不干扰      引用存放到新变量栈中，操作同一个地址              分配机制      自动分配，大小固定      动态分配，可指向同一块引用              回收机制      回收及时，生存时间固定      根据引用次数交给回收器回收            变量声明方式，会影响其数据类型    使用new关键字会创建一个Object类型对象，其行为类似原始值  let name = 'username' // typeof = stringname.age = 18console.log(name.age) // undefinedlet name = new String('username') // typeof = objectname.age = 20console.log(name.age) // 20       传递参数时，按值传递（与复制变量一样，引用类型仅传递地址）    但在函数内部重写对象obj时，变成一个指向本地对象的指针，与外部对象断联。且这个指针在函数结束调用时，销毁掉了，对外部对象没有影响。  function setName(obj){    obj.name = 'nicholas'    obj = new Object()    obj.name = 'greg'}let person = new Object()setName(person) // person.name = 'nicholas'变量声明（es6 特性）作用域又称为“执行上下文”，每个上下文都有一个关联的变量对象（varialbe object），定义的所有变量和函数都存在与此，在后台处理数据时可以读取到。上下文在其所有代码都执行完毕后会销毁，包括定义的变量和函数。全局上下文是最外层的上下文，根据ECMAscript实现的宿主环境不同，表示全局上下文的对象可能不一样。在浏览器中，全局上下文指“window对象”。只有在退出浏览器或关闭页面时，window对象会销毁。ECMAscript程序执行流通过上下文堆栈进行控制。上下文执行代码时，创建变量对象的一个作用域链(scopt chain)，决定各级上下文代码访问变量、函数的顺序。正在执行的上下文位于堆栈最上面，其代码始终位于链条最前端；全局上下文变量始终位于链条最后面。执行标识符短路查找变量定义。上下文是函数，其活动对象（activation object）作为变量对象，最初只有一个定义变量argument；全局变量不包含。块作用域      未定义声明变量类型，同样可以使用到该变量 – 污染全局：可能修改到引用的文件内的变量        使用严格模式\"use strict\"要求必须声明        for没有块作用域，临时变量i定义使用var与全局变量同名时，将修改全局变量；推荐使用let声明，产生块级作用域        立即执行函数： 避免对全局变量的污染，强制在函数内部使用    花括号{}内使用let产生块级作用域· const 在同一作用域内不可改，函数内的局部作用域可再次声明var  存在变量声明提升的缺陷： 未声明可使用，就是没有定义；js 所有声明提到函数体顶部，赋值操作留在原来的位置  变量覆盖：多次声明定义无报错，使用最近定义的变量  没有块级作用域；是函数级作用域· var 声明的变量会保存到 Window 中，若与 Window 内已有全局对象同名，会修改到 DOM 的值const let  ！块级作用域，不存在变量提升  let 定义变量；  const 定义常量，声明时必须赋值，值和引用地址不可更改，引用的值可以改避免变量体现的缺陷，形成TDC 暂时性死区： 使用前必须先声明      变量名对内存地址的引用，引用不可更改；对象等同一个内存空间修改可以          修改变量值会重新开辟一个内存空间，相当于修改地址引用            同一作用域中 不可重复声明  冻结变量 Object.freeza· const 定义对象的内容可以改变，此时用到冻结变量const HOST = {  url: \"https://www..com/api\",  port: 442};Object.freeze(HOST);HOST.port = 80; //在严格模式下报错：重复声明共同点      函数中变量可访问到外部的全局变量（无论是哪种变量）        在块级作用域找不到时，往外查找定义  作用域链延长      try/catch 语句中的 catch块。   在catch语句之前，创建新变量对象，包含将要抛出的错误对象声明。        with 语句。   向作用域链前端添加指定对象    在IE8之前，catch捕捉到的错误添加到执行上下文的变量对象上，而不是catch语句的变量对象上，导致在catch外部也可以捕获到错误。回收机制​\tJavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。​\t最主要的标记策略：标记清理和引用计数  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾  两种常用方法​\t垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数#### 1. 标记清除法（大部分浏览器） Mark-Sweep两个阶段：      标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达    （标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）        清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）  优点：实现简单缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）优化方案：**标记-整理法  Mark-Compact **​\t清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理#### 2. 引用计数法 Reference counting​\t追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：  赋值给引用值时，引用数 +1；  保存引用的变量被覆盖了，引用数 -1缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。   b 循环引用无法收回，导致内存泄漏。3. 循环引用在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 循环引用 的问题：  BOM 和 DOM 中对象是C++实现的COM对象，使用 引用计数 实现垃圾回收。即使引擎使用 标志清理，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。   let element = document.getElementById('one'); // com对象   let obj = new Object() // 原生obj对象   obj.element = element;   element.obj = obj;      // 避免：确保两者没有联系   obj.element = null;   element.obj = null;在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。分代式垃圾回收机制  新生代：对象存活时间短，通常支持 1~8M  老生代：对象存储 存活时间长、常驻内存的对象两个内存区域回收频率不同，V8才有两个垃圾回收器管控：新生代垃圾回收​\tCheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为使用区（From 空间）。一个处于闲置状态的空间称为空闲区（To 空间）垃圾回收机制——翻转 （Scavenge）  先对使用区中的活动做标记  标记完成后，将使用区的活动对象复制进空闲区并进行排序  将原先使用区对象占用的空间释放  最后进行角色互换，把空闲区变为使用区，使用区变为空闲区缺点：由于只能使用堆内存的一半，所以不适用大规模的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）并行回收Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。那当GC时间过长就会造成页面卡顿问题。那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过并行回收机制：引入多个辅助线程来同时处理   新生代对象空间就采用并行策略。在垃圾回收过程中，启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。新生代何时会到老生代  多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理  复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配老生代垃圾回收​\t老生代数据大多是存活的对象，不需要时常更新，可以使用 标记清收法 回收。在V8中使用 标记整理法 解决标记清除后产生的大量内存碎片。增量标记 （incremental marking）​\t代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题  一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。  应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成  存在问题：  ​\t小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法  ​\t如何进行下一次小GC 标记？—— 惰性清理  ​\t如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障三色标记法  黑色表示对象自身及对象的引用都被标记（已检查状态）  白色表示未被标记的对象（初始状态）  灰色表示自身被标记，自身的引用未被标记（待检查状态）执行流程：  初始所有对象都是白色  从root对象开始、标记为灰色，并推入标记工作表中；  当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色  将自身的下一个引用对象标志为灰色一直执行，直到没有可以被标记为灰色的对象，剩下的白色对象都是不可达的，进入清除阶段；恢复时，从灰色标记对象开始执行写屏障目的：  解决黑色对象在程序执行中被新添加引用  已经标记黑色的被引用对象不再被引用了写屏障就有了以下两个变化：​\t1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。  Write-barrier 机制强制不变黑的对象指向白色对象。          这个也被称作强三色不变性。所以      一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色      从而保证下一次增量 GC 标记阶段可以正确标记      惰性清理 （lazy sweeping）​\t增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。优化回收V8 script 隐藏类JS 性能优化 —– V8 隐藏类​\t“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中一次性声明所有属性​\t“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 = null优化程序回收，提高性能  手动回收（不建议）：window.ColloectGarbage()（IE）、window.opera.collect()（opera7以上）立即启动垃圾回收；  解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。  使用 块级作用域 ，尽早让垃圾回收程序介入。"
  },
  
  {
    "title": "6.网络层",
    "url": "/posts/6.%E7%BD%91%E7%BB%9C%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-18 00:00:00 +0800",
    





    
    "snippet": "​\t网络体系结构的最顶层，享受下层提供的服务，无视下层具体操作活动；​\t通过应用进程的交互，实现特定网络应用的问题；​\t是设计和建立计算机网络的最终目的C/S 和 P2PC/S客户 / 服务器（Client/Server）  客户：是计算机、是进程，是服务请求方  服务器：          是计算机、是进程，是服务提供方      总是处于运行状态，等待客户请求      具有固定的端口号...",
    "content": "​\t网络体系结构的最顶层，享受下层提供的服务，无视下层具体操作活动；​\t通过应用进程的交互，实现特定网络应用的问题；​\t是设计和建立计算机网络的最终目的C/S 和 P2PC/S客户 / 服务器（Client/Server）  客户：是计算机、是进程，是服务请求方  服务器：          是计算机、是进程，是服务提供方      总是处于运行状态，等待客户请求      具有固定的端口号，主机有固定的IP地址        服务集中型          应用服务集中 比客户端少得多的 服务器上      常会出现服务器跟不上客户端请求的情况      计算机群集（服务器场）构建一个强大的虚拟服务器      P2P对等方式 （ Peer - to - Peer）  没有固定的请求者和提供者，应用进程对等、直接通信  服务分散型          大量对等计算机都是服务的提供和请求者      可扩展性：不会因为规模扩大而减低系统性能        用户越多，速度越快；成本优势DHCP​\t动态主机配置协议，又称为即插即用网络。​\t允许一台计算机加入新网络时，可以自动获取IP地址等网络配置信息而不用手工配置。​\tTCP/IP的应用层协议，使用UDP传输​\tDHCP\t服务器的端口67；客户端的端口68工作过程      *discover ** *寻找服务器    客户端 发送UDP用户数据报，包含DHCP发现报文；          目的地址255.255.255.255：不知道当前网络中有多少个DHCP服务端，和他们具体的IP      源地址0.0.0.0：当前主机未分配到IP地址      目的端口号67：非DHCP服务器不监视该端口，收到但丢弃；仅DHCP服务器作出回复      数据域封装有 事务ID + DHCP客户端的MAC地址            Offer 提供一套方案    DHCP服务器收到该报文，          拆分、查找是否有针对其MAC地址的配置信息                  有：将该配置信息封装 → DHCP提供报文          无：默认配置信息封装 → DHCP提供报文                    封装回复报文                  目的地址：255.255.255.255，目标设备未分配到IP地址          源地址：DHCP服务器地址          目的端口号68：非DHCP客户端不监视该接口，收到但丢弃；仅DHCP客户端作出回复                          Request 确认选择某一套方案    客户端收到回复：          根据报文中的事务ID判断是否是自己所请求的报文      配置信息包括：IP地址（使用ARP检测确保该IP未被网络中的其他主机占用）、子网掩码、地址租期、默认网关、DNS服务器      挑选一个（先到的）报文作为自己的DHCP，发送 DHCP请求报文征求其同意：                  目的地址255.255.255.255：告知所有的DHCP，我挑选到它啦          源地址0.0.0.0：现在未获得DHCP服务器的同意          报文内容：事务ID、DHCP客户端的MAC地址、接受租约的IP地址、提供租约的DHCP服务端IP地址等                          ACK 最终确认    服务端回复是否同意租约          目的地址：255.255.255.255      源地址：DHCP服务器            客户端收到确认后，使用ARP检测所分配的IP地址是否被网络其他主机占用          若未被占用，客户端可以开始使用该IP地址      若被占用，                  给DHCP服务器发送 DHCP decline报文撤销IP地址租约          重发 DHCP discover报文寻找方案                          续约 当租期过半时                  客户端请求续约 DHCP request                  源地址：租用的地址          目的地址：DHCP服务器                    服务器不同的反应                  若同意续约 DHCP ACK，得到新的租期          若不同意续约 DHCP NACK，客户端必须立即停用租用的IP地址并重新发送 DHCP discover          若不响应，客户端等待一段时间                    等待到0.875 = 7/8的租期时间，客户端必须重新发送 续约 DHCP request      等待到租期结束，客户端必须停用租用的IP地址并重新发送 DHCP discover            解约 客户端可以随时放弃租用的IP地址，向提供DHCP服务器发送 DHCP release释放报文即可  中继代理​\t某个网络拓扑中没有DHCP服务器，其客户端法发送的 DHCP discover请求使用广播地址255.255.255.255不能经过普通路由器转发而是丢弃，内部又没有可以相应其DHCP请求的服务，导致该网络拓扑中的主机无法自动获取网络配置信息。​\t解决办法，为该路由器配置DHCP服务器的IP地址使之成为 DHCP中继代理​\t路由器收到广播的DHCP discover报文后，会单播转发给其他网络拓扑中存在的DHCP服务器，此后都如此交互​\t使每个网络不必都配置DHCP服务器，至少有一个即可DNS​\t域名系统（Domain Name System），将域名翻译为IP地址寻址​\t每台用户主机都需要经过DNS查找域名对应的IP地址，故DNS服务器不能只有一台，它应该在本地解析或一个分布式服务器集群​\t因特网使用层次结构命名树 + 分布式域名系统，大多数域名在本地解析域名空间​\t1. 各级域名：由若干个分量，以.隔开，分别代表不同级别的域名​\t\t每一级域名（&lt; 63个字符）有 英文（不区分大小写） + 数字 ，完整域名 &lt; 255个字符​\t\t···.三级域名.二级域名.顶级域名 右边大，各级域名由其上级机构管理；顶级域名由因特网名称与数字分配机构ICMN管理  顶级域名TLD（Top Level Domain）分为三类          国家顶级域名nTLD：ISO 3166规定      通用顶级域名gTLD：常见七个（com公司企业、net网络服务机构、org非营利性组织、int国际组织、edu美国教育机构、gov美国政府部门、mil美国军事部门）      反向域名arpa：用以反向域名解析，即IP地址 → 域名        二级域名          由国家自行规定      分为两类                  类别域名：七个（ac科研机构、com工商金融等企业、edu教育机构、gov政府部门、net提供网络服务机构、mil军事机构、org非盈利组织）          行政区域名：34个，分配给各省、自治区、直辖市                      便于维护名字的唯一性，易查询；逻辑概念，而非物理地点域名服务器​\t分布式实现  根 域名服务器          分布式构成的13个根域名服务器，是高层的域名服务器      不直接对域名解析，而是提供该域名所在的 顶级服务器IP地址        顶级 域名服务器          管理该顶级域名下的 二级域名      返回下一级权限服务器的IP地址        权限 域名服务器          管理某个区的域名，主机必须所管辖服务器注册登记      管辖的域名与IP地址的映射关系；下级服务器的地址        本地 域名服务器          主机第一个经过的域名服务器，起着代管作用，对其转发      距离主机距离较近，一般四五个路由器      域名解析解析过程      递归查询    直接一级一级向下查询，本地 – 根 – 顶级 – 权限，获得结果就往回传递        迭代查询    每向一节查询，拿着结果，向另一级查询。    本地 – 跟 = 顶级IP；本地 – 顶级IP = 权限IP；本地 – 权限 = 目标IP；本地服务器将目标IP交给主机  递归查询对被查询的域名服务器负载要求大，所以采用两者相结合：  主机 – 本地：递归查询  本地 – 其余服务器：迭代查询解析原理（？）DNS指针查询（反向查找、逆向解析）的基本原理DNS缓存​\t为提高查询效率，减少查询报文数量，减轻服务器负荷​\t域名服务器广泛使用 高速缓存，存放最近查询过的域名、何处获取的域名映射信息记录​\t本地主机也需要维护好 域名：IP地址数据库​\t缓存为每项内容设置计时器，并删除超过合理时间的项FTP​\t文件传输协议（File Transfer Protocol）  交互式访问，允许指明文件类型与格式、文件存取权限（授权、口令）  屏蔽计算机系统细节，适用于异构网络中任意计算机之间基本工作原理两种不同的传输模式主动模式      服务器监听 熟知端口号21，等待客户发起FTP连接        控制连接：建立TCP连接，用于传送FTP相关控制命令，即命令通道        如果有数据传输，客户端通过命令通道告知服务器：需要开放另一条TCP连接，作为数据通道        数据连接：服务器开放 熟知端口号`20`，向客户发起FTP连接（主动模式），用于传输FTP文件  被动模式  控制连接一样  如果有数据传输，客户端通过命令通道告知服务器：需要开放另一条TCP连接，作为数据通道  数据连接：服务器开启 临时端口（双方协商好的端口号），被动等待客户连接（被动模式），建立数据通道两个TCP连接并行：​\t控制连接需要在绘话期间一直保持打开；​\t数据连接在每次文件传输时建立，结束时结束客户端的接口都是随机的？  控制连接 + 数据连接（为什要？  两种工作模式：PASV + PORT      指令和响应码    断电续传 + 匿名FTP万维网WWW​\tworld wide web，运行在Internet中的分布式应用，而非某种特殊的计算机网络​\t利用超链接，将不同网站的网页连接统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;连接方式两种：  非持续连接          HTTP / 1.0      每次请求就建立TCP连接，收到响应后立即关闭连接      请求一个WWW文档时间 = 2RTT + 文档传送时延      为减少时延，通常会建立多个并行TCP同时请求多个对象；但占用服务器资源        持续连接          HTTP / 1.1      同一个浏览器与该服务器的TCP连接可以继续传送请求和响应      流水线模式：收到响应之前连续发送多个请求，而后服务器一个接一个响应      非流水线模式：只有上一个请求被响应后才可以发送下一个请求      HTTP报文格式HTTP是 面向文本，报文的每一个字段都是一些ASCII码率，且长度不确定请求格式（+各种字段）  请求行          指明方法：GET POST PUT      资源地址：URL      HTTP 版本        首部行          Connect：close — 告诉服务器发送完请求文档后可释放连接      User-Agent：Mozilla/5.0 — 告诉服务器 浏览器使用的类型和版本      Accept-Language：cn — 告诉服务器 用户希望优先得到中文版本的文档                  方法      描述                  HEAD      请求URL标志的文档首部              CONNECT      用于代理服务器              OPTIONS      请求一些选项信息              TRACE      用来进行环回测试                                    GET      请求URL标志的文档              POST      向服务器发送数据              PUT      在指明的URL下存档一个文档              DELETE      删除URL标志的文档              PATCH      对PUT方法补充，对已知资源进行局部更新      响应（+各种字段）            状态码      （五大类，33种）描述                  1XX      表示通知信息，如：请求收到了、正在进行处理              2XX      表示成功，如：接受了、知道了              3XX      表示重定向，即要完成请求还必须采取进一步的行动              4XX      表示客户的差错，如：请求中有错误的语法、或不能完成              5XX      表示服务器的差错，如：服务器失效无法完成请求      Cookie​\tHTTP为无状态协议，使用Cookie对其进行状态化的技术  双方建立TCP连接成功时，服务器为用户生成唯一的cookie识别码Set-Cookie  用户端将Cookie信息存放到文档  每次用户端发送请求，读取Cookie码并将其携带上  服务器根据Cookie码识别用户，并返回个性化页面HTTPS（？  详细握手过程  摘要算法、数字签名、数字证书的原理和过程电子邮件​\t电子邮件系统上采用 客户/服务器方式，有三个部件构成：用户代理，邮件服务器，电子邮件所需的协议  用户代理：用户与电子邮件系统的接口，又称 电子邮件客户端软件  邮件服务器：          电子邮件系统的基础设施，Internet所有的ISP（Internet Service Provider，互联网服务提供商）都有邮件服务器      其功能是发送和接受邮件，维护用户的邮箱        协议：邮件发送协议（SMTP）+邮件读取协议（POP3，IMAP）邮件协议的使用范围SMTPSMTP 与 MIME  SMTP协议          只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。      不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。      许多其他非英语国家的文字（例如中文、俄文、甚至带有重音符号的法文或德文）也无法用SMTP传送。        MIME（多用途因特网邮件扩展，Multipurpose Internet Mail Extensions）          为解决SMTP传送非ASCII码文本的问题，      增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。      定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。      定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。      实际上，MIME不仅仅用于SMTP，也用于后来的同样面向ASCII字符的HTTP基本工作原理信息格式邮件读取协议​\t都使用基于TCP连接的客户/服务器方式POP 邮局协议​\tPost Office Protacol，是Internet的正式标准。  非常简单，功能有限  用户只能 下载+删除、下载+保留的方式 获取邮件到计算机  不允许用户在邮件服务器上管理自己的邮件  熟知端口110IMAP Internet邮件访问协议​\tInternet Message Access Protocol，是Internet的建议标准  功能强大，是一个联机协议  用户可以在计算机上操作邮件服务器的邮箱  熟知端口143基于万维网的电子邮件​\t通过浏览器 → 邮件服务器万维网，撰写、收发、阅读和管理；无需安装软件TCP 区分应用进程；实现可靠传输添加ETH 使之成为（以太网）帧帧：目的地址 + 源地址 + 类型 + 包 + 4字节校验码前导码：1字节帧开始界定符 + 7字节前同步码 让目的主机做好接受帧的准备"
  },
  
  {
    "title": "5. 运输层",
    "url": "/posts/5.%E8%BF%90%E8%BE%93%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-16 00:00:00 +0800",
    





    
    "snippet": "​\t主机到主机的通信：物理层 + 数据链路层 + 网络层​\t主机进程间的通信：传输层​\t如果为运行在不同主机的 应用进程的逻辑通信提供直接通信服务，又称为端到端协议（端口）​\t向上层隐藏下面的网络服务核心细节，提供两种不同的运输协议  面向连接的TCP  面向无连接UDP端口号​\t进程标识符PID，不同OS、不同进程的表示格式不同，使用统一的方法对TCP/IP体系的应用进程标识​\t16bit...",
    "content": "​\t主机到主机的通信：物理层 + 数据链路层 + 网络层​\t主机进程间的通信：传输层​\t如果为运行在不同主机的 应用进程的逻辑通信提供直接通信服务，又称为端到端协议（端口）​\t向上层隐藏下面的网络服务核心细节，提供两种不同的运输协议  面向连接的TCP  面向无连接UDP端口号​\t进程标识符PID，不同OS、不同进程的表示格式不同，使用统一的方法对TCP/IP体系的应用进程标识​\t16bit表示，取值范围0~65535；      熟知端口号：0~1023；FTP 21/20; HTTP 80; DNS 53        登记端口号：1024~49151；必须登记手续        短暂端口号：49152~65535；动态端口号    【端口号只具有本地意义】不同OS、不同进程的端口号之间没有联系    复用：多个线程利用一个 IP+端口 发送信息称为 复用；  分用：多个线程利用一个 IP+端口 接收信息成为 分用；UDP​\tUser Datagram Protocol 用户数据报协议  无连接的 — 支持单播、多播以及广播  面向应用报文：          以报文为单位      对应用层传输下来的报文既不合并也不拆分，保留报文的边界        不可靠服务          运输层、网际层都是向上提供无连接、不可靠的传输服务      当报文出现误码、丢失时，接收方仅丢弃而什么都不做        适用于IP电话、视频会议、直播等实时应用数据报格式​\t首部（仅8字节） + 数据部分TCP​\tTransmission Control Protocol 传输控制协议  面向连接（逻辑上的连接，物理上仍然是无连接）— 仅支持单播  面向数据流：          传送字节流      不保证一次传完、只保证传输数据一致；      要求应用层有能力处理乱序字节流、多次传输的数据流拼接完整还原        可靠的服务          网际层可能出现传输差错，但TCP可以使其差错重传      不会出现传输差错      数据报格式  源端口、目的端口：          各16bit，用于识别发送、接受该TCP报文段的应用进程      源端口：填写暂时端口号（？      目的端口：填写该应用的熟知端口号（？        序号：          32bit，增加到最后一个后又从0开始      指出本TCP报文段数据载荷的第一个字节序号        确认号：          32bit，增加到最后一个后又从0开始      指出希望收到下一个数据载荷的第一个字节的序号；对之前收到的数据进行确认，收到数据的最后一个字节号+1      ！需要搭配 标志位 ACK使用：                  ACK=1时才有效，ACK=0时无效          TCP规定，在建立连接后TCP报文段必须把 ACK=1                      数据偏移：          4bit，以4字节为单位      指出 数据载荷的起始 距离 TCP报文段的起始 处有多远      指出TCP报文的首部长度                  首部固定长度为20字节，数据偏移量min = (0101) ~2~ = 5*4          首部最大长度为60字节，数据偏移量max = (1111) ~2~ = 15*4                      窗口：          16bit，以字节为单位      指出 发送本报文段的一方 的接受窗口      根据接收方的接受能力 控制 发送方的发送能力，即流量控制      接收方 让 发送方 设置其发送窗口的依据之一：[拥塞窗口，接受窗口]~min~        校验和          16bit，检查 TCP报文段的首部 + 数据载荷 两个部分      校验方式与UDP一样        标识符          SYN：建立连接的同步符      FIN：释放连接的终止符      RST：复位TCP连接                  表示连接出现异常，必须释放后重新建立连接          拒绝非法报文段 、 拒绝打开一个TCP连接                    PSH：推动标志位，该报文尽快推送上交应用进程，而不必等待接收缓存填满再上传      URG：紧急标志位，搭配 紧急指针使用                  URG=1，紧急指针有效；URG=0，紧急指针无效          发送方有紧急数据时，可插队到发送缓存的最前面，并立即封装一个TCP段发送          紧急指针：数据载荷有多长的紧急数据，紧急数据之后的普通数据          接收方根据紧急指针取出紧急数据，直接上交应用进程，而不必等待接收缓存填满再上传                      选项（可选）          最大报文段长度MSS选项：TCP报文的数据载荷最大长度      窗口扩大选项：为扩大窗口（提高吞吐率）      时间戳选项：                  计算往返时间RTT          处理序号超范围情况，又称为凡是序号绕回PAWS                    选择确认选项        填充：使整个首部长度能被4整除，数据偏移字段以4字节为单位连接控制​\tTCP面向连接，三个阶段  建立连接（三次握手）  数据传送  释放连接（四次挥手）三次握手 — 连接  解决问题：          确知对方的存在，协商参数（窗口值max，是否使用时间戳选项一级服务质量等）      双方对运输实体资源（缓存大小、连接表中的项目）进行分配        双方先建立传输控制块：          TCP连接表      指针：发送和缓存的、重传队伍的      当前发送和接受的序号        服务器等待客户端的连接，成为被动打开连接  客户端主动发起的连接，称为主动打开连接      三次握手：    在不可靠网络信道中建立可靠的连接                  你听见我在说话了吗？（客户端发送SYN=1,seq=x，进入SYN-SENT同步已发送状态）        （SYN=1：不允许携带数据，但要消耗一个序号；seq=x：客户端进程所选择的初始序号；）                    我听见了，你能听见我在说话吗？（服务端回复SYN=1,ACK=1,seq=y,ack=x+1,进入SYN-RCVD同步已接收状态）        （SYN=1,ACK=1：TCP连接请求确认报文，不允许携带数据，但要消耗一个序号；）        （seq=y：服务器进程所选择的初始序号；ack=x+1：对客户端初始序号确认）                    我听见了你在说话了（客户端回复ACK=1,seq=x+1,ack=y+1，进入establish连接已建立状态）        （ACK =1：普通的确认报文；seq=x+1：请求连接报文已消耗掉一个序号；ack=y+1：对服务器初始序号的确认）        （TCP规定：普通的确认报文段可以携带数据，如不携带则不消耗序号；则下一个报文序号仍为x+1）                    双方开始通话（服务器收到确认报文，也进入establish链接已建立状态）                  为什么不使用两次握手？    防止已经出错的请求报文突然又传给服务器，而引起的错误                  你听到我在说话了吗？（客户端第一次发送SYN，滞留或丢失）                    无回复                    （客户端重新发送SYN包）你听到我在说话了吗？                    我听见了，我们开始聊天吧！（服务端正常收到，并回复SYN + ASK）        （二次握手成功，双方开始建立连接）                    第一次发送的SYN突然恢复，会出现两种情况                  双方正在连接，此时服务端以为客户端请求新的连接，发送回复SYN + ASK建立两次握手后，进入等待数据状态；服务端建立两个连接，而客户端只认可一个连接，导致状态不一致。          双方已释放连接，服务器以为客户端重新请求连接，发送回复SYN + ASK建立两次握手后，而进入等待数据状态；客户端无连接请求，将不会回复数据。            四次挥手 – 释放                                服务器等待客户端的释放，成为被动关闭  客户端主动发起的释放，称为主动关闭      我客户端说完了，要撤咯（客户端发送FIN=1,ACK=1,seq=u,ack=v，进入FIN-WAIT-1终止等待状态）    （FIN=1：即使不携带一个数据，也要消耗一个序号）    （seq=u：客户端最后已发送的最后一个字节序号+1；ack=v：客户端最后已收到的最后一个字节序号+1）        知道了，我服务端还有话要说点（服务器发送确认报文ACK=1,seq=v,ack=u+1，进入CLOSE-WAIT关闭等待状态）    （普通的确认报文段， 服务器通知服务器进程关闭链接；）    （seq=v：服务器最后已发送的最后一个字节序号+1；ack=u+1：服务器最后已收到的最后一个字节序号+1）    （客户端收到报文，进入FIN-WAIT-2终止等待状态）    （两端的应用进程方向连接释放，进入 半关闭状态：客户进程无话要说，服务器进程可能有话要说，客户仍要开放接收）        我服务端讲完了，听见没啊？（服务器发送FIN=1,ACK=1,seq=w,ack=u+1，并进入LAST-ACK最后确认状态）    （FIN=1,ACK=1：TCP连接释放报文，seq=w：半关闭状态下可能发送的数据序号，ack=u+1：对收到的报文进行重复确认）        嗯嗯，听到你说的话了，等你先挂电话（客户端发送ACK=1,seq=u+1,ack=w+1，并进入TIME-WAIT超时等待状态）    （普通的确认报文段，seq=u+1：客户端之前已发送的序号，fin消耗掉一个序号；ack=w+1：客户端收到的序号确认）    （服务器收到报文，立即关闭连接，进入closed关闭状态）        （客户端超时等待结束，关闭连接）  超时等待状态  为确保服务器端已收到ACK包；时间=2MSL，最长报文段寿命的两倍（一个来回）  ACK丢包！服务器会重新发送FIN包： 喂？喂？喂！          客户端在超时等待中可捕获到这个包，而重新第四次挥手      立即断开连接，客户端无法捕获这个FIN包，没有第四次成功挥手，将会使得服务器一直处于连接状态      保活计时器​\t【情景】客户端出现故障。服务端不会再收到信息，如果及时发现对方已下线？  服务器维护一个 保活计时器  客户端 → 服务器，服务器就重启保活计时器（2h）  保活计时器到时候，服务器 → 客户端发送 探测报文段；之后的75s/次，一连10次仍然没有响应，关闭连接数据确认为解决丢包、乱序问题      为每一个连接建立 发送缓冲区，建立连接后的第一个字节序列号为0，此后序列号 + 1        发送报文格式：取其数据序列号 + 长度 + 数据内容        确认报文格式：ACK = 序列号 + 长度 = 下一包起始序列号    （可以连续发送多个发送报文，接收端只需回复一次ACK就可以）    （收到ACK确认报文，发送端可将已接受字段删除）        切割发送：根据序列号+长度重组 = 数据内容        丢失重发：ACK = 丢失报文的序列号    【全双工：以上过程部区分客户端、服务端】  流量控制​\tFlow Control, 让发送方的发生效率不要太快，让接收方 来得及 接受；滑动窗口​\t依靠滑动窗口实现 可靠传输  发送窗口和接受窗口并不重视一样大          网络传输窗口值有一定的滞后      发送方可根据自身情况修改发送窗口        不按序到达的数据，TCP无明确规定          接收方一律丢弃，管理简单但浪费资源，发送方需要重复发送数据      接收方暂存到接受窗口，等待数据齐全后，交付给上层的应用进程        接收方必须有 累计确认 和 捎带确认 机制          捎带确认：可以在有数据发送的时候，吧确认信息捎带      不应该过分推迟确认：每隔一个报文段就发送一个确认      不经常发送，因为很少要求经常同时向两个方向发送        TCP通信是全双工通信【举例】每个报文可携带100字节数据，将要发送的数据编号后以100为单位分割      建立TCP连接时，接收方B告诉发送方A：我的接收窗口为400    （A的发送窗口设置为400，在未收到B的确认，可将落入发送窗口的全部数据一直发送出去）        发送A发送1~100字节数据，seq=1,DATA，还能发送300        发送A发送101~200字节数据，seq=101,DATA，还能发送200        发送A发送201~300字节数据，seq=201,DATA(丢失)，还能发送100        接受B对1~200字节数据累计确认，并将接收窗口设置为300，ACK=1,ack=201,rwnd=300    （ACK确认标志符，ack确认了n字节数之前的数据，rwnd重置的窗口的大小。）    （:number1: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后201；调整发送窗口的大小=300；丢弃发送缓存中已被确认接收的数据1~200）    （201~300字节已发送但没有收到确认，重传计时器开始计时）        发送A发送301~400字节数据，seq=301,DATA，还能发送100        发送A发送401~500字节数据，seq=401,DATA，还能发送0，不能再发送新数据    （重传计数器到点，开始重传旧数据；300窗口为丢失数据保留一个100发送，但不能再发送新数据了）        发送A发送201~300字节数据，seq=201,DATA，还能发送300        接受B对201~500字节数据累计确认，并将接收窗口设置为100，ACK=1，ack=501，rwnd=100    （:number2: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后501；调整发送窗口的大小=100；丢弃发送缓存中已被确认接收的数据201~500）        发送A发送501~600字节数据，seq=501,DATA，还能发送0，不能再发送新数据        接受B对600之前的字节数据累计确认，并将接收窗口设置为100，ACK=1，ack=601，rwnd=0    （:number3: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后601；调整发送窗口的大小=0；丢弃发送缓存中已被确认接收的数据501~600）  【窗口为0的确认】      当B接收缓存有了一些存储空间，于是发送我要调整窗口为300，但丢失了！    形成死锁：主机A等待B的非零窗口通知；主机B等待A的数据报文        A主动发送零窗口探测报文，携带1字节数据，询问接收方        每次A接收到0窗口报文后，启动持续计时器，超时时主动询问        B收到零窗口探测报文，需回复确认报文，并告知现在的窗口大小，ACK=1,rwnd=300    B接受缓存已满，可以不接受一般报文，但必须接受紧急报文、确认报文和零窗口探测报文  拥塞控制慢启动、拥塞避免  拥塞窗口cwnd：          值取决于 网络拥塞程度，并动态变化      维护原则：                  网络未出现拥塞，cwnd值就大一些；          网络一旦出现拥塞，cwnd值就小一些；                    发送方的发送窗口swnd = cwnd        网络拥塞的依据：没有按时收到应当到达的确认报文（发送超时重传）  两种控制的应用：慢开始门限 ssthresh          cwnd &lt; ssthresh，拥塞窗口 &lt; 慢开始门限 —- 使用慢开始算法（cwnd × 2）      cwnd &gt; ssthresh，拥塞窗口 &gt; 慢开始门限 —- 停止使用慢开始，而使用拥塞算法（cwnd + 1）      cwnd = ssthresh，拥塞窗口 = 慢开始门限 —- 可使用慢开始，也可使用拥塞算法        维护一个 慢开始门限 ssthresh          设置一个初始值      每次发生网络拥塞时                  拥塞窗口值cwnd / 2 = ssthresh          cwnd重置为初始值，并开始慢开始                    快速重传、快速恢复  不是所有的报文丢失由于网络拥塞导致的，当超时重传时判断是否为 网络拥塞          是网络拥塞，使用拥塞算法      不是网络拥塞，开启快重传、快恢复        快速重传：          要求接收方每次收到报文，都要对其及时确认      若收到失序的报文，对失序报文重复确认（确认报文只能确认最高序号）      同时保留失序的报文      发送方接受三次重复的报文确认                  网络未拥塞          一至两次重复确认，可能报文滞留在网络某处          三次确认可认为报文丢失，重发报文                      快速恢复：          启用快重传后，抛弃慢启动，使用快速恢复      ssthresh = cwmd / 2      cwmd = ssthresh      拥塞避免算法      超时重传超时时间选择​\t超时重传的时间ORT 应该略小于 一个报文段往返时间RTTO  过短：不必要的重传，网络拥塞  过长：不必要的等待，网络闲置  略？：经过不同速率的网络、不同数量的路由等等因素加权平均往返时间 RTTs – – 平滑的往返时间：多次测量的RTT样本加权平均加权平均往返时间 RTTs\t初始化：RTTs = RTT1\t新的RTTs1 = （1 - α）× RTTs1 + α × 新的RTT样本（0 &lt;= α &lt; 1，α=1/8=0.125）RTT偏差的加权平均RTTd\t初始化：RTTD = RTT1 ÷ 2\t新的RTTD = （1 - β ）× RTTD1 + β × |RTTs1 - 新的RTT样本| （0 &lt;= β &lt; 1，β=1/4=0.25）超时重传时间 RTO\tRTP = RTTs + 4 × RTTd      RTT的测量准确与否非常重要                  RTT的测量有难度：                  数据报文段丢失后重发。距离收到确认报文的时间，是第一次报文还是第二次报文？          数据未收到确认而重发。距离收到确认报文的时间，是第一次报文还是第二次报文？                            Karn算法：只要报文重传，就不采用其RTT样本，RTO也不会重新计算        （若报文时延突然增大且持续很久，RTO内不会收到确认报文，于是重发，而不更新RTO，将一直重发）                    修正Karn算法：报文重传，就把RTO增大一些（× 2）            "
  },
  
  {
    "title": "4. 网络层",
    "url": "/posts/4.%E7%BD%91%E7%BB%9C%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-14 00:00:00 +0800",
    





    
    "snippet": "​\t实现网络互连，数据包在其之间的传输      向上层（运输层）提供怎样的服务？IP提供的是 面向无连接，不可靠服务        网络寻址问题：A类地址、B类地址、C类地址        路由选择问题：路由表 + 目的地址          路由表的数据来源：人工设置（小型，不改变）、路由选择协议中的选择算法        因特网，使用TCP/IP协议，网络层使用网际协议IP，由此TCP...",
    "content": "​\t实现网络互连，数据包在其之间的传输      向上层（运输层）提供怎样的服务？IP提供的是 面向无连接，不可靠服务        网络寻址问题：A类地址、B类地址、C类地址        路由选择问题：路由表 + 目的地址          路由表的数据来源：人工设置（小型，不改变）、路由选择协议中的选择算法        因特网，使用TCP/IP协议，网络层使用网际协议IP，由此TCP/IP中的网络层又称为网际层  提供的两种连接      面向连接的虚电路          可靠通信由网络来保障      建立网络层的连接——虚电路CV，沿着此电路发送分组      目的主机地址仅在建立初阶段使用，之后 首部只携带虚电路的编号      通信结束后，需要释放所建立的虚电路        虚电路 + 可靠传输协议 = 无传输差错          虚电路是一条逻辑上的电路，事实上不存在      电话交换的电话通信，是建立一条物理上的电路            无连接的数据报服务          可靠通信由用户主机来保障      不建立网络层练级——每个分组可走不同的路径      目的主机的完整地址需要时刻携带      可能出现传输差错，但造价低廉，适应性强        将复杂网络处理功能至于因特网边缘（用户主机和其内部的运输层）  IPv4​\t每一台主机（或路由器）的每个接口，分配唯一的32bit的识别符​\t点分十进制表示法，每8位分为一组分类编址方式  A类地址：8位（网络号）+ 24位（主机号）          网络号第一个比特值一定为0      最小网络号0，保留不指派                  0.0.0.0是一个特殊的网络地址，表示“在本网络上的本主机”，只能作为源地址使用                    最大网络号127，作为本地环回测试地址，不指派                  最小的：127.0.0.1          最大的：127.255.255.254                    可指派的网络地址1.0.0.0 - 126.0.0.0        B类地址：16位（网络号）+ 16位（主机号）          网络号第一二个比特值一定为10      最小网络号，也是第一个可指派的网络号 128.0      最大网络号，也是最后一个可指派的网络号 129.255      可指派的网络地址：128.0.0.0 - 191.255.0.0        C类地址：24位（网络号）+ 8位（主机号）          网络号第一二三个比特值一定为110      最小的网络号，也是第一个可指派的网络号 192.0.0      最大的网络号，也是最后一个可指派的网络号 223.255.255      可指派的网络地址：192.0.0.0 - 223.255.255.0        D类地址：多播地址  E类地址：保留今后使用  广播地址：255.255.255.255，表示“只在本网络进行广播”，只能作为目的地址使用子网划分      为什么要划分子网：          申请更多的IP地址，会导致路由表记录数量怎多      浪费原有网络中剩余的IP地址            子网地址计算    【例题】网络地址为218.75.230.0，使用子网掩码255.255.255.128对其子网划分。                  218.75.230.0：该网络为C类网络地址，前三个值为网络号，最后一位是主机号                    255.255.255.128：                  前三个255表示连续24个比特1，对应了网络号部分，                            128化为二进制表示一个比特1，即从主机号中借用了一个比特作为子网号                  划分的子网数量 2^1 = 2，每个子网可分配的地址数量2^（8-1 ) - 2=126    [去掉主机号全为0的网络地址、全为1的广播地址]        默认子网    在未划分子网的情况下使用子网掩码    网络号对应掩码全为1，主机号的对应掩码全为0  报文首部格式首部长度：4个字节  最大值为15：固定部分 20字节 + 可变部分 40字节  最小值为10：固定部分 20字节      IP数据报的首部长度一定是4的整数倍    区分服务          8bit，一般不使用      该字段的不同数值可提供不同等级的服务质量            总长度          首部长度 + 数据载荷            【标识 + 标志 + 片偏移：IP数据报分片】        生存时间：防止数据报在网络中兜圈 – 路由环路          以“时间”为计数，初始 - 当前路由花费的时间 = 剩余时间                  ＞0，转发；≤ 0，丢弃                    以“跳数”为计数，跳转指定次数                  ＞0，转发；≤ 0，丢弃                          协议                  8bit，数据部分是何种协议数据单元                    常用协议与字段值                      首部检验和          16bit，检验首部在传输过程是否出现差错      IP层本身不提供可靠传输服务，因而IPv6将不再进行校验        源IP地址和目的IP地址，各占32bit分片方式  为什么要分片：          IP数据报需要打包成帧，而帧长度受限于的最大传输单位MTU      当IP数据报长度 &gt; 帧，需要 分片 成更小的数据报文        标识：          16bit      同一个数据报的各分片应该具有相同的标识      IP软件维持一个计数器，每产生一个数据报计数器+1，赋值给标识字段        标志          3bit      DF位：（Don’t 分片？）                  1 – 不允许分片          0 – 允许分片                    MF为：（More 分片?）                  1 – 后面还有分片          0 – 这是最后一个分片                    保留位，必须设置为0        片偏移          13bit      分片数据报的数据载荷部分 在原数据报位置 偏移多少个位置      以8个字节为单位 – 数据载荷的第n个字符 / 8 （再次分片，第n遵循最初的位置）      选路？ICMP​\t为提高IP数据报 转发和交付成功的概率，在网际层使用网际控制报文协议Internet control message protocol​\t被封装在IP数据报中发送​\t应用场景：  分组网间探测PING          测试主机间的连通性      应用层直接使用网际层的ICMP（而不ton过运输层的TCP和UDP）      使用ICMP的回送请求和回答请求        跟踪路由          测试IP数据报经过哪些路由传递      Windows系统                  tracect命令          应用层直接只用网际层ICMP          ICMP回送请求、回答报文、差错报文                    Unix版本                  traceroute命令          在运输层使用UDP协议          只使用了差错报文                    查询报文2种  回送请求和回答：          请求报文：向特定主机发出询问      回答报文：收到请求的主机必须回复      测试目的站是否可达+状态        时间戳请求和回答          请主机回答当前的日期和时间      时钟同步和测量时间      差错报文5种  终点不可达：目的主机、路由不能交付数据报  源点抑制：目的拥塞而丢弃报文，通知源点数据发送速率放慢  时间超过：          路由因TTL &lt; 0而丢弃报文时，要通知源点      规定时间内没有收到一个报文的全部报片，会将已收到的全部丢弃，并通知源点        参数问题：首部检验与字段发现传输中出现误码，丢弃且通知源点  改变路由（重定向）：路由路径有更优解时不可发送差错报文的情况：  对ICMP差错报文 不再发送 差错报文          对第一个分片的数据报片的所有后续数据报片 都不再发送差错报文      对具有多播地址的数据报 都不发送ICMP差错报文      对特殊地址的数据报 不发送差错报文      ARP？"
  },
  
  {
    "title": "3. 链路层",
    "url": "/posts/3.%E9%93%BE%E8%B7%AF%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-13 00:00:00 +0800",
    





    
    "snippet": "链路层  链路（Link）：两个结点间的物理线路  数据链路：把实现通信协议的硬件和软件，加到链路上  封装成帧：加上帧头 帧尾  差错检测：帧尾的检验码  可靠传输：接收方发现帧验证错误，丢弃该帧而不接受广播通道链路：将目标地址、源地址写入帧头共享式局域网信号碰撞问题：接入控制协议 CSMA/CD封装成帧            1字节      1字节      1字节      2字节 ...",
    "content": "链路层  链路（Link）：两个结点间的物理线路  数据链路：把实现通信协议的硬件和软件，加到链路上  封装成帧：加上帧头 帧尾  差错检测：帧尾的检验码  可靠传输：接收方发现帧验证错误，丢弃该帧而不接受广播通道链路：将目标地址、源地址写入帧头共享式局域网信号碰撞问题：接入控制协议 CSMA/CD封装成帧            1字节      1字节      1字节      2字节      &lt;1500字节      2字节      1字节                  标志（开始）      地址      控制      协议      数据      FCS      标志（结束）              帧头                    帧头             帧尾      帧尾        帧定界：          帧头帧尾      MAC没有帧头定界标志，用物理层的前导码作为其帧开始标志      帧间间隔（96bite发送时间）作为标志        透明传输：数据链路层 对上层交付的数据没有任何限制，就如同透明的一样          帧中出现数据与定界符一致，将导致接收方识别错误信息，不能实现透明      发送前扫描，将相似的数据添加转义 【面向字符类型：1字节，值27】【面向比特类型：每五个比特1插入一个0】        最大传输单元 MTU，数据部分应该尽可能大些，但为差错检查等数据链路层功能的保证，设定的值差错检测  基本概念：          比特差错：比特在传输过程中可能发生的差错，1→0,0→1      误码率（BER，bit error rate）= 传输错误的比特 / 总比特      使用错误检测码 检验是否发生了错误        奇偶校验          使整个数据（包括检验位）中“1”的个数为奇数 / 偶数；      出现偶个数误码，无法检出        循环冗余校验（CRC，cyclic redundancy check）          双方约定的生成多项式G(x)，必须包含最低次项      发送方：计算出冗余码，添加到待传输数据后面      接收方：使用多项式计算数据，判断是否产生误码      漏检率极低，只能检测出发生差错，而不能定位      G(x) = x^4 +x^2 +X^1 + 1  \t = 1*x^4 + 0*x^3 + 1x^2 + 1x^1 + 1*x^0\t = 生成多项式各项系数构成的比特串：10111发送方：[ 待传输数据bit + G(x)最高次个0（4个0）]÷生成多项式各项系数构成的比特串 = 商 ···· 余数发生的数据：待传输数据bit + 补全的余数接收方：[ 接收数据 + 余数 ] ÷ 生成多项式各项系数构成的比特串 = 商 ···· 0 才是正确的可靠传输服务​\t当发生误码时，对帧的操作，取决于向上层提供的服务类型。  不可靠传输服务：仅仅丢弃（有线链路中使用，出现误码由上层负责）  可靠传输服务：检测到误码发生的位置（无线链路必须提供）其它层级也可使用可靠传输服务不仅仅局限于数据链路层，其他层级也可能出现传输差错            比特差错      分组丢失      分组失序      分组重复                  数据链路层                           网络层 IP协议：无连接、不可靠运输层 TCP协议：连接、可靠运输层 UDP协议：无连接、不可靠可靠传输的实现机制​\t【三种方式，待补充】"
  },
  
  {
    "title": "2. 计算机网络用语",
    "url": "/posts/2.%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-12 00:00:00 +0800",
    





    
    "snippet": "专业术语实体协议  控制两个对等实体的逻辑通信规范的集合  三要素：语法、语义、时序",
    "content": "专业术语实体协议  控制两个对等实体的逻辑通信规范的集合  三要素：语法、语义、时序"
  },
  
  {
    "title": "1. 计算机网络分层",
    "url": "/posts/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-10 00:00:00 +0800",
    





    
    "snippet": "网络分层模型OSI：开放式系统互联【物理链路层：物理层+链路层 – Link】【内核态】  物理层：bit，①物理接口，②怎样的信号表示比特  数据链路层：帧，①标识主机MAC，②识别MAC与数据地址访问媒介【网络层 – IP ICMP ARP】【内核态】  网络层：包，IP地址访问【传输层 – TCP UDP】【内核态】  传输层：段，不同主机用户进程的数据通信【应用层 – HTTP FT...",
    "content": "网络分层模型OSI：开放式系统互联【物理链路层：物理层+链路层 – Link】【内核态】  物理层：bit，①物理接口，②怎样的信号表示比特  数据链路层：帧，①标识主机MAC，②识别MAC与数据地址访问媒介【网络层 – IP ICMP ARP】【内核态】  网络层：包，IP地址访问【传输层 – TCP UDP】【内核态】  传输层：段，不同主机用户进程的数据通信【应用层 – HTTP FTP DNS ..】【用户态】  会话层：数据，应用之间的通信机制  表示层：数据，信息语法问题  应用层：数据，进程间通信、提供网络和用户应用各层传输设备【应用层 -（网关）- 传输层 - 网络层（路由器） - （交换机） - 数据链路层（网桥） - 物理层（集线器、中继器）】  网关：          实现复杂网络互连设备      仅用于 高层协议不同的网络 互通      可用于广域网，也可用于局域网        路由器：路由选择、存储转发；隔离冲突域+广播域  交换机：          识别MAC地址信息，并进行转发      保存一份地址表，包括 MAC地址+端口      隔离冲突域，不隔离广播域        网桥：          将两个LAN连接，根据MAC地址转发 帧      隔离冲突域，不隔离广播域        集线器：纯硬件设备，连接网络终端  中继层：延长bite在网络传输距离透明性？            [前导码]      [ETH]      [HTTP]      [TCP]      [IP]      [ETH]                  [物理层]      [数据链路层]      [应用层]      [运输层]      [网络层]      [数据链路层]                            HTTP报文                                                        TCP报文段                                                        IP数据报                            帧                                          字节流                                         "
  }
  
]

