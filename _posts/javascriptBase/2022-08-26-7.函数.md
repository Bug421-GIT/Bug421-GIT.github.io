---
title: 7. 函数
author: "Ana-Ana"
date: 2022-08-26
tags: [javascriptBase]
categories: ["JavaScript","Object"]
render_with_liquid: true
layout: post
pin: true
---
![javascript_function](../assets/img/JavaScriptBase.assets/javascript_function.png)

​	函数存在提升的问题，优先级比变量优先级高

### 定义

- 函数表达式  — `let fun = function() {}`

- 构造函数 ——  `new Function() {}`

  - 参数必须是字符串格式
  - 所有函数都是Function的实例、也是对象（引用类型）
  - new Function("参数1","参数2","函数体") ，最后一个参数作为函数体
  - 函数会被解析两次：

  *解析器率先读取 <u>函数声明</u>，使其在执行任何代码前就可以被访问；而 <u>函数表达式</u> 必须等解析器执行到其所在的代码行，才被真正解释*

- [箭头函数](#ES6-2)




​	**函数声明提升**：使用函数声明，会在任何代码执行之前先读取并添加到执行上下文中。

​	函数表达式相当于位于变量声明中，如果是`const`、`let`变量，则不存在变量/函数声明提升问题；`var`变量，则面临与函数声明一样的提升问题。

### 函数特性

#### **函数名**

- 使用不带括号的 函数名`name`，表示指针；带括号使用 函数名`name()`，表示调用
- 函数对象都会暴露一个只读的 <u>`name`属性</u> ，包含关于函数的信息
  - `(new Function()).name` 构造函数创建的匿名函数，值为`anonymous`
  - `(()=>{}).name` 匿名函数，值为空字符串`""`
  - 函数是一个 `get` `set` 或者 `bind()`实例化，标识符会存在一个前缀
- 一个对象引用（可改变指向，多个函数名可能指向同一个函数）

#### **参数**

​	函数的参数在内部表现为一个数组，（非箭头函数）定义函数时，可以在内部使用`arguments`对象访问传入的参数值。

1. `arguments` — 类数组对象

- 始终与对应的命名参数同步，但与参数存放在不同的内存空间中。

- 数组：包含传入（非定义时）函数的所有参数，可以用`arguments.lenght`确定实参个数
      - 对象：具有`callee`（指针）属性，指向这个`arguments`对象的函数，`arguments.callee.lenght` 确定形参的个数

​	在递归回调函数中，回调中写 <u>自身函数名</u>，若修改函数名，则会出现问题；改成`arguments.callee`，适用于 匿名函数和递归调用时。

​	在严格模式下，:one: 对`arguments[0]`赋值，不会影响参数； :two: 在函数中重写`arguments`对象会导致语法错误。

- **重载：**JavaScript不存在验证命名参数的机制，两个同名函数会覆盖先定义的，但可以使用`lenght` 根据传入参数的数量，实现重载

```javascript
function hello(name,message)(
	if(arguments.length) return 'no one come in'
	if(arguments.length === 1) return "this gus didn't say anything"
	if(arguments.lenght === 2) return arguments[1]
)
```

- **函数名解耦**

```javascript
function factorial(num){
    if(num < 10) return 1
    return num * factorial(num - 1)
}
let a = factorial(10); // 3628800

// 为函数体保存多个函数名，并将 factorial 函数名（指针）指向为空
let newLocal = factorial;
factorial = null;

// 再次调用 函数体，内部的factorial() = null，导致计算失败
let b = factorial(10); // factorial is not a function
```

​	可以使用`arguments.callee`： 指向`arguments`对象所在函数的指针

```javascript
function factorial(num){
    if(num < 10) return 1
    return num * arguments.callee(num - 1)
}
```

2.  默认参数值（ES6）

  `arguments`不反映默认值，只反映传给函数的参数；修改命名参数不会影响`arguments`对象，以调用函数时传入的值为准。

  只有在函数被调用时、未传入相应参数时，默认参数值才会被求值；

  作用域：位于函数存活时间内，块级作用域，且参数按定义的先后顺序初始化

```javascript
function makeK (name = "King"){}

function makek (name = "King", time = getTime(name)){}
```

3. `caller`属性（非标准的）

   调用当前函数的引用，如果是全局调用则为`null`。

   在严格模式下，访问`arguments.calleer会报错，且不可以给函数的`caller`属性赋值，否则会导致错误

#### 作为值

​	调用函数对象（数组）决定操作的对象，

```javascript
function createComparisonFunction(propertyName){ 	// 外层参数`propertyName` 指定操作的属性值
    return function(object1, object2){
        let value1 = object1[properyName];
        let value2 = object2[properyName];        
        
        // 对 value1 & value2 操作 					内层函数决定操作内容。
    }
}

let arr = [
    {name:"zhang",age:18},
    {name:"cheng",age:20}
]
arr.sort(createComparisonFunction(age));	// obj.sort 遍历调用数组内部的值
```

#### this指向

    1. 普通函数：
       - 定义 `function fn() {}`
       - 调用 `fn();`   `fn.call()`
       - **this → window**
    2. 构造函数
       - 定义：`function Star() {}`
       - 调用： `new Star();`
       - **this → 实例对象**，原型对象里面的方法也是
    3. 对象的方法
       - 定义： `let o = { sayHi: function() {} }`
       - 调用：`o.sayHi();`
       - **this → 方法所属的对象**
    4. 绑定事件函数
       - `btn.onclick = function() {};`
       - **this → 绑定事件的对象**
    5. 定时器函数
       - window.`setInterval( function() {}, 1000)`  —— 每隔1s自动调用一次
       - this → window
    6. 立即执行函数
       - `( function() {} )(传入参数)`
       - this → window
    7. 箭头函数
       - 定义：`let fn = ()=>{}`
       - **this → 保留定义时的this**

案例：[新增数组方法操作](E:\Computer language\H5\新增数组方法操作\index.html)

#### 变量存this<span id="that"></span>

​	声明时，`function User(name){this.name = name}`为空对象`User{}`；被调用时，根据参数生成`User{name:"参数"}`

​	所以`this`是可以被改变的

```JavaScript
let Lesson = {
	site:"122",
    lists: ["js","css","mysql"],
    show: function() {
        const self = this; //指向对象
        return this.lists.map(function(value){
            console.log(this); //指向window
            console.log(value);//形参
            console.log(this.site);//指向window，undefined
            console.log(self.site);//指向对象，”122"
        })
    }
```

部分函数存在第二参数可传递this

```JavaScript
show: function(){
	return this.lists.map(function(){
    	console.log(this); //对象
    },this);  
}
```

#### new.target

​	检测函数是否使用了`new`关键字调用。

​	如果函数是正常调用，`new.target = undefined`；如果使用`new`关键字调用，`new.target`指向被调用的 <u>构造函数</u>。

#### call & apply

​	以**指定的`this`**调用一个函数，返回函数的返回值；**更换函数调用的作用域**；

​	传入的数组内元素的个数 > 函数可以接受的参数，数组内多余的将被丢弃；

​	非严格模式下，调用时没有指定`this`，`this = window`；

​	在严格模式下，调用时没有指定`this`，不会指向`window`而是会变成`undefined`。

```javascript
function fun(value1,value2,value3...)

// call (this, 参数) 参数间使用逗号分隔
function callFun(value1, value2, value3 ...){
    return fun.call(this, value1, value2, value3)
}


// apply (this, 参数数组)
function applyFun(value1, value2, value3 ...){
    return fun.apply(this, arguments); // 传入数组、类数组
    return fun.apply(this, [value1, value2, value3])
}
```

​	`call & apply` 区别在与第二个参数是否为数组；如何选用完全取决于怎么调用函数传参方便：

​	`apply()`数组参数传入函数内部直接展开；`call()`仍以数组形式传入；如果不需要参数，两者都一样。

**应用1：**避免求值遍历

​	`Math.max.apply(null, arr);` === `Math.max(...arr);`

**应用2：**call和apply方法实现封装接口



#### bind()

​	调用bind后此函数后不会立即执行，而是得到一个新的函数、实例（不同内存地址）

​	`show.bind({name: ""})()`可使其立即执行

​	传递参数的方法：（不是立即执行）

​	绑定时传参（已将全部参数赋值，调用时传参无效）

​	调用时传参（参数填充完，剩余参数无用）

```JavaScript
// 不调用函数，但改变this的指向
原函数的拷贝 = fun.bind( 指定的this, value1，value2 ...){}
```

- 主要应用：

  - 偏函数，使绑定的函数拥有预设的初始参数（包括this值，预设的参数），调用时传递的参数会跟在它们后面

  - 快捷调用
  - 配合定时器

```javascript
let o = { name: 'baby' } // 调用的对象
function fn(arr1,arr2,arr3) {
    console.log(this.name);  // baby
    console.log(arr1,arr2,arr3);
}
let bindFun = fn.bind(o,1,3); // arr1 = 1，arr2 = 2， arr3 = undefined ，this指向o， 但没有调用
bindFun(0); // arr3 = 0
```

```JavaScript
let btn = document.querSelector('button');
btn.onclick = function() {
    this.disabled = true;  // 函数内的this指向调用者
    // bind 解决
    setTimeout( function(){
        // this.disabled = false;     定时器内的this指向window，没有这个属性
    }.bind(this),3000) //为定时器的函数外面（此时的this仍然时函数的调用者）绑定this，之后内部的this指向函数的调用者
    // 箭头函数 解决
    setTimeout= ()=>{
        this.disabled = false;     //箭头函数没有自己的this，这个this指向上一级调用者
    },3000)
}
```

### 递归函数

​	定义：函数内部调用自己

​	栈溢出（stack overflow），死循环 —— 退出条件非常重要

- 解决问题 —— [递归函数案例](E:\Computer language\H5\递归函数案例)

  1. 求1-n的阶乘

     函数内部使用了 函数名调用，导致执行逻辑与函数名耦合，应该替换为`arguments.callee()`

  ```javascript
  function fn(n) {
      if (n == 1) { return 1; }
      if (n >= 0) { 
          return n * fn(n - 1); 
          // return n * arguments.callee(n - 1)
      }
      else
          alert("请输入大于等于1的数");
  }
  console.log(fn(-3));
  ```

  2. 求斐波那契数列  $a_n = a_{n-1} + a_{n-2}(a_1 = 1,a_2 = 1,n≥3)$

     **尾调用优化**：如果函数逻辑允许基于尾调用将其销毁，则引擎会这么做（ES6特性）

  ```javascript
  function fb(n) {
      console.log(n);
      if (n === 1 || n === 2) { return 1; }
      else 
          return fb(n - 1) + fb(n - 2);
  }
  console.log(fb(3));
  
  // 优化后：
  function fib(n){
  	return fibImpl(0, 1, n);
  }
  function fibImpl(a, b, n){
      if(n === 0) return a;
      return fibImpl(b, a+b, n-1);
  }
  ```

**尾调用优化的条件：**

1. **代码在严格条件下** —— 非严格模式下函数调用中允许使用`f.arguments` 和 `f.caller`，都会引用外部函数的堆栈
2. 外部函数（`fib`）的**返回值是对尾调用函数（`fibImpl`）的调用**  —— 上下文不再返回外部函数（`fib`）中
3. 尾调用函数（`fibImpl`）**返回后不需要执行额外的操作** —— 上下文不再返回外部函数（`fib`）中
4. 尾调函数（`fibImpl`）**不是<u>引用外部函数作用域中自由变量</u>的闭包** —— 外部函数（`fib`）上下文仍有存在的必要

### 全局函数

``` javascript
function screenX(){}
```

默认压入window中，可能覆盖window中声明的属性/变量，函数提升的问题

将函数赋值给let变量可以避免以上问题

函数用类的方法声明（es6）

```javascript
class a {}
```

### ⁉️高阶函数

- 对其他函数进行操作（满足其中一个）
  - 接受函数作为参数
  - 将函数作为返回值输出

```JavaScript
// 接受函数作为参数
function fn(callback){ callback && callback(); }
fn(function() { alert('hi'); })
// 将函数作为返回值输出
function fn(){ return function() {} }
// 回调函数
```

### 立即执行函数 （IIFE）

​	Immediately Invoked Function Expression，在ES5尚未支持块级作用域，用来模拟块级作用域（作用域仅为括号内，执行完毕作用域链销毁）

```javascript
(function( 形参 ){
    // 在函数作用域内，使变量活动块级作用域
})( 实参 )
```

- 链式引用script若有同名函数，取最后引入加载的script函数

- 使用模块化类的方式

**传入参数`window`** 

```javascript
(function(window){
    function hd(){}
    window.js2 = {hd} //对外开放一个接口
})(window);

js2.hd
```

**块作用域解决**

```JavaScript
{
	let hd = function(){}
    window.js1 = {hd};
}
```

<span id='ES6-2'></span>

 ### ⁉️箭头函数（Es6）

```javascript
const hd = ( 形参 ) => { 函数体 };
let hd = [1,2,3].filter(value => value <= 3);

const sum = (num1,num2) => num1 + num2;	// 函数体 只有代码，可以省略大括号；返回值为执行结果
console.log( sum(10,20) ); // 30

const fn = v => alert(v); //形参 只有一个，可以省略小括号
fn(20);
```

- 递归 、构造、事件处理器不适用箭头函数
- 没有 `arguments`（只能通过定义的参数名访问）、 `super`、 `new.target` 属性，也没有 `prototype` 属性
- 无具体参数名称，回调不方便、

箭头函数，this指向上一级的this，没有自己的this

> 函数定义时作用域就有了，this需具体到执行时，箭头函数在绑定时决定

```javascript
var obj = {
    age: 40,
    say: () => { alert(this.age) }  // 实际上是定义在window下的方法
}
obj.say(); // undefind

// obj是一个对象，对象不产生作用域；作为window调用，返回undefined
```

### 取对象同时取DOM节点

1. 取对象：箭头函数；取节点：普通函数，不可同时实现

解决方法：

1. `button.addEventListener("click",function(event){})`中的event.target指当前绑定的按钮

```JavaScript
let Dom = {
    site: '',
    bind: functon(){
		const button = document.querySelector("button");
button.addEventListener("click",event => {
	console.log(this); //箭头函数指父级对象
    console.log(event.target);//获取当前绑定的DOM节点
        })
	}
}
```

2. const self = this；
3. hanleEvent

> `element.addEventListener(type, listener[, useCapture]);`其中listener：当指定的事件类型发生时被通知到的一个对象。该参数必须是实现EventListener接口的一个对象或函数。即，第二个参数除了可以传入函数外，还可以传入对象。
>
> 事件会自动在传入对象中寻找handleEvent方法

```javascript
let Dom = {
    handleEvent: function(event){
        
    },
    bind: funcion(){
    	const button = document.querySelector("button");
		button.addEventListener("click",this); //传入当前对象，自动寻找handleEvent方法
	}
}
```

### 访问私有变量

​	任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数/块的外部无法访问其中的变量。

#### 特权方法

​	其实就是使用 <u>闭包</u> 的原理，具有访问构造函数中定义的所有变量和函数的能力。

```javascript
function Person(value){
    // 私有变量
    let name = value
    // 特权方法
    this.getName = function(){ return name; }
    this.setName = function(value) { name = value; }
}
let person = new Person('lisi');
person.getName(); // 'lisi'
```

#### 静态私有变量

​	私有作用域内定义公用的构造函数，并在构造函数原型上添加特权方法实现访问私有变量。但这个私有变量是**“共享”**的.

​	在下面例子中，构造函数使用函数表达式而不是函数声明，函数声明会创建内部函数，这里不是必须的。

```javascript
function (){
    // 私有变量 
    let privateVariable = 10;
    // 私有函数
    function privateFunction (){
        return false;
    }
    //  构造函数
    // 1. 不带关键字的，全局变量
    // 2. 表达式声明，执行时才会创建函数
    MyObject = function() {}
    // 在构造函数的原型上添加特权方法
    MyObject.prototype.publicMethod = function (){
        return privateFunction();
    }
}
```

#### 模块模式

​	单例对象(singleton)：只有一个实例的对象，通常通过 <u>对象字面量</u> 创建。

​	模块模式是在单例对象基础上加以扩展，通过作用域链关联私有变量和特权方法。

```javascript
let singleton = function() {
    // 私有变量 
    let privateVariable = 10;
    // 私有函数
    function privateFunction (){
        return false;
    }
    // 特权、公有方法和属性
    return { // 返回对象字面量
        publicProperty: true,
        publicMethod(){
            return privateFunction();
        }
    }
    
}
```

​	函数返回的对象字面量，只包含可以公开访问的属性和方法；因为其定义在匿名函数的内部，所以可以访问同一个作用域的私有变量和私有函数。

​	<u>对象字面量</u> 本质上定义了 <u>单例对象的公共接口</u>。**如果单例对象需要进行初始化，且需要访问私有变量，可以使用。**

#### 模块增强模式

​	在返回对象之前，对其进行增强。适用于：单例对象需要某个特定类型的实例，但又需要给它添加额外属性、方法

```javascript
let application = function(){
    let components = new Arrya();
    // 指定某种特定的类型
    components.push(new BaseComponent());
    
    // 创建局部变量，保存额外功能的实例
    let app = new BaseComponent();
    // 获取私有变量的属性
    app.getCompontCount = function(){
        return components.length;
    }
    // 设置私有变量
    app.setCompontRegister = function(components){
        return components.push(component)
    }
    return app; // 返回实例
}
```

​	`application`返回值是app实例，可以让`components`被外部访问到