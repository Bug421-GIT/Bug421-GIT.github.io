---
title: 2. 数据类型
author: Ana-Ana
date: 2022-08-01
tags: [javascriptBase]
categories: ["JavaScript"]
render_with_liquid: true
layout: post
pin: true
---

![javascript_数据类型分类](../assets/img/JavaScriptBase.assets/javascript_数据类型分类.png)

- 基本数据类型：
    1. [undefined & null](#undefined&null)
    2. <a href='../2.2.基本数据类型-Number'>number</a>
    3. <a href='../2.3.基本数据类型-Bolean'>boolean</a>  
    4. <a href='../2.4.基本数据类型-String'>string</a>

- 基本引用类型：
    5. [原始值包装类型](#-原始值包装类型)
    6. <a href='../2.6.基本引用类型-RegExp'>RegExp</a>
    7. <a href='../2.7.基本引用类型-Date'>Date</a>
    8. [单例内置对象](#-单例内置对象)

- 集合引用类型：
    9. <a href='../2.9.集合引用类型-Array'>Array & TypeArray</a>
    10. <a href='../2.10.集合引用类型-Map'>Map   & weakMap</a>
    11. <a href='../2.11.集合引用类型-Set'>Set   & weakSet</a>

##   基本和引用类型区别

|                | 基本数据类型           | 引用数据类型                         |
| -------------- | ---------------------- | ------------------------------------ |
| 声明的存储分配 | 栈                     | 堆                                   |
| 不同的访问机制 | 可以直接访问到         | 只能操作对象在栈中的引用             |
| 复制变量时     | 值存放到新变量内存中   | 引用存放到新变量栈中，操作同一个地址 |
| 分配机制       | 自动分配，大小固定     | 动态分配，可指向同一块引用           |
| 回收机制       | 回收及时，生存时间固定 | 根据引用次数交给回收器回收           |

<!-- ##  [回收机制](#1.变量/#回收机制) -->
##  <a href='../1.变量/#回收机制'>回收机制</a>

​	JavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。

​	最主要的标记策略：标记清理和引用计数

##  值类型的判断

1. typeof： 一元运算，返回String — 判断引用类型时，只会返回`object`
2. instanceof： 判断是否在原型链上prototype

```js
object instanceof contructor 
    -- 判断object的原型链上是否存在constructor.prototype
	-- object 一定要是一个对象
    -- contructor 一定要是一个函数
```

1. 值定义：

   1. 引用类型

   ```javascript
   let number = new Number(99);
   number.valueOf()+1
   ```

   2. 值类型

   ```
   ler number = 99;
   number+1;
   ```

   对于值类型使用`.`方法时，会在原型链中调用对象的方法（转换为对象）

-------------

- 两者会结合封装成一个工具类

```js
function getDataType(obj) {
  if (obj === null) {
    return 'null';
  } else if (typeof obj === 'object') {
    if (obj instanceof Array) {
      return 'array';
    } else {
      return 'object';
    }
  } else {
    return typeof obj;
  }
}
```

##  <span id='undefined&null'>undefined & null</span> 
- undefined ：声明但未赋值
- null：执行空对象指针

 🌞 undefined 派生自 null，`undefined == null` 

##  ❗ 原始值包装类型

​	每当<u>用到</u>某个原始值的方法或属性是，后台会创建一个相应原始包装类型的<u>对象</u>，使得原始值具有操作属性的各种方法。

​	ECMAscript提供了三种特殊的引用类型：**`Boolean` 、`Number`、`String`**

```javascript
let str1 = new String('text string') // 原始值 str1
let str2 = str1.length;  // 访问到 str1 中的属性 —— 只读的模式
```

`str2` 以只读的模式访问 `str1` 在内存中保存的值，后台会执行以下三个操作：

​	 :one: 创建`String`实例 :two:调用实例上的特点方法  :three:销毁实例

**作用域**

​	引用类型和原始值包装类型主要区别在于对象的生命周期：

​	自动创建的原始值包装类型对象，**只存在于访问它的那行代码执行期内**。即不能在运行时给它添加属性和方法。

```javascript
let str1 = new String('text string') // 原始值 str1
str1.color('red');
console.log(str1.color); // undefined
```

第二行代码尝试给 原始值新增属性`str1.color`，但第三行访问不到：

- 第二行代码访问到的`String`对象是临时的，已经被销毁
- 第三行代码中创建了新的自己`String`对象，但这个对象没有这个属性

**类型转换**

​	可以使用`Boolean` 、`Number`、`String`构造函数显式原始值包装类型，但不建议

```javascript
let str = '30'
typeof str; //'string'
// 转型函数
let num = Number(str) 
typeof num; // 'number'
// 构造函数
let obj = new Number(str)
typeof obj; // 'object'
```


##  ❗ 单例内置对象

​	ECMA-262中，对内置对象的定义：任何由ECMAScript实现提供、与宿主环境无关，并在程序开始执行是就存在的对象。

​		**可以直接使用，而无需创建实例** ——无法在显性地实例化内置对象（在运行时就存在对象），包括Object、Array、String、Global、Math

##  兜底对象 Global

​	ECMA-262规定，Global对象为兜底对象，所针对的是不属于任何对象的属性和方法。在**全局作用域中定义的变量和函数，都是Global的属性**。

​	包括 isNan() 、isFinite() 、parseFloat() 等

​	**在 <u>浏览器中</u>，window对象实现为Global对象的代理。**所有全局作用域中声明的变量和函数都变成了window属性。

#### URL 编码方法

| encodeURL()                 | encodeURLComponent() |
| --------------------------- | -------------------- |
| 对整个URL编码               | 编码URL中单独的组件  |
| 不编码属于URL组件的特殊字符 | 编码所有非标准字符   |

​	decodeURL() & decodeURLComponent()  同上

#### eval 方法

​	**完整的ECMScript解释器**，接受一个字符串（要执行的ECMAScript语句）。运行时，才将参数解释为ECMAScript语句，并插入到该位置，调用代码所在的上下文 —— 被执行的代码与该上下文拥有同样的作用域链。

​	但定义的任何变量和函数都不会被提升：解析代码时候，ECMAScript语句仅仅作为一个字符串，只有在执行是才会被创建。

​	在严格模式下，eval() 内部创建的变量和函数无法被外部访问。

  **必须非常慎重使用。在解释用户输入等不可控字符串时，可能被植入执行语句**

#### Global 对象属性

1. 所有原生引用类型构造函数；
2. 特殊值：NaN Undefined infinity；
3. Error构造函数；