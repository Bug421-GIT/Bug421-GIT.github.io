---
title: 4. 展开语法  & 解构语法
author: "Ana-Ana"
date: 2022-08-21
tags: [javascriptBase]
categories: ["JavaScript"]
render_with_liquid: true
layout: post
pin: true
---
### 展开语法  <span id='ES6-4'></span>

​	将<u>数组、对象</u> 转换为用 <u>逗号分隔的参数序列</u>

#### 在函数中应用

1. 函数调用 (数组元素迭代为函数参数)

   ` myFunction(... args);` == `myFunction.apply(null, args);`

   使用`new Function()`定义，其传参的最后一个作为函数体，其他作为参数，传参都得是字符串

2. 传参给构造函数

   `.apply`执行的是`.call`，而不是构造`constuct`

   **`Object.create()`** 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。

   ```javascript
   // 展开语法：
   let arr = [1003,3,2];
   let d = new Date(...arr); //传入(1003, 3, 2)
   
   // 不使用展开语法
   function applyAndNew(constructor, args) {
      function partial () {
         return constructor.apply(this, args); // 将数组展开传递给构造函数
      };
      if (typeof constructor.prototype === "object") { // 如果构造函数的类型是对象
         partial.prototype = Object.create(constructor.prototype); // 重新指向其构造函数
      }
      return partial;
   }
   var myConstructorWithArguments = applyAndNew(myConstructor, myArguments); // 需要自定一个构造函数
   ```


#### 在数组中的应用

1. 复制到新的函数

   `var lyrics = ['head', ...parts, 'and', 'toes']; `  

2. 连接两个函数

   `var list3 = [...list1, ...list2]`  ==  `var arr3 = arr1.concat(arr2);`

3. 数组插入 新数组

   开头插入：`var list1 = [...list2, ...list1]` == `Array.prototype.unshift.apply(arr1, arr2)`

   结尾插入：`var list1 = [...list1, ...list2]` ==  `for( const item of list2) { list1.push(item); }`

#### 在对象中的应用

​	已有 <u>对象的所有可枚举 (enumerable) 属性</u> 拷贝到新构造的对象中

​	`var mergedObj = { ...obj1, ...obj2 };`   **浅拷贝**

#### 对DOM节点操作

· document.querySelectorAll(" ")获取节点为集合，一个类数组，使用map得转化为数组

·  **`Array.from()`** 方法对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。

```javascript
Array.form(document.querySelectorAll("")).map(function(item){})
```

· 使用节点原型链上的map函数 **call()**

```JavaScript
Array.prototype.map.call(div,function(item){})
```

· 展开语法

```JavaScript
[...div].map(function(item){
    item.addEventListener("click",function(){
        this.classList.toggle("hide");
    });
});
```

#### 剩余参数

​	允许我们将一个不定个数的参数表示为一个数组，结合解构语法将剩余变量全部吸收过来，`...args`需放在结构的最后一个

```javascript
funcion sum(first, ...args){
    console.log(first); // 1
    console.log(args); 	// [3,4,5]
    let total = 0;
    args.forEach(item => total += item);
    console.log(total) // 3 + 4 + 5 = 12
}
sum(1,3,4,5);
// 剩余参数 & 解构函数
let [s1, ...s2] = [1,3,4,3,5,6]; // s1 = 1, s2 = [3,4,3,5,6]
```

### 结合使用

```javascript
let {name:myName} = {name:[1,2,3,4],age:'20',sex:'男'}
console.log(myName); // [1,2,3,4]

let {name:myAge} = {name:[1,2,3,4],age:'20',sex:'男'}
console.log(myAge); // '20'
```

#### 数组去重

```js
let arr = [12,54,12,75,12]
let item = [...new Set(arr)]
console.log(item)
```

### 解构语法

​	对象解构：使用与对象匹配的结构来实现对象属性赋值

​	**当元素存在引用对象时，出现浅拷贝的问题**

```javascript
// 1. 左侧的数组、对象 批量赋值给 右边的变量
let [name,age] = ["张三","20"];

let person = { name:'Matt', age:27}
let {name:name1, age:age1} = person; // name1 = 'Matte',age1 = 27
let {name, age} = person; // name = 'Matte',age = 27

// 2. 为个别元素添加默认值
let [name,age=20] = ["张三","20"];

// 3. 仅取其中某个值
let [,age] =  ["张三","20"]
```

​	在内部使用函数 `ToObject()` （不能在运行环境中直接访问）把数据源结构转为对象 —— 原始值会被当成对象。`Null & undefined` 不能被解构，否则会抛出错误。

​	**如果给事先声明的变量赋值，则赋值表达式必须包括在括号内。** 

```javascript
let name, age, page;
let person = {
    personName : 'matt',
    personAge : 27,
    personPage:{ title: 'my life'}
}
let copy = {}
// 嵌套解构
({personPage: copy.personPage} = person); //  coye = {personPage:{ title: 'my life'}
({personJob: job} = person); // 报错! 外部未声明job，内部未声明personJob，不能使用嵌套解构

// 参数上下文匹配： 在函数签名中声明函数提内使用的局部变量
function printPerson(foo, {personName:name}, bar){
	console.log(name)
}
```

​	解构表达式涉及多个赋值，自赋值出错后面都会失败；则整个解构赋值只会完成一部分。