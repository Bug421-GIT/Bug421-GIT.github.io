---
title: 2.9.基本引用类型（Array）
author: Ana-Ana
date: 2022-08-12
tags: [javascriptBase]
categories: ["JavaScript","引用类型"]
render_with_liquid: true
layout: post
pin: true
---
## Array

 1️⃣ 有序； 2️⃣ 每一个项可以保存任何类型的数据； 3️⃣ 动态大小，自动增长

### 基本操作

1. 创建： 
   - `new Array`  可以忽略`new`声明数组，效果一样
   - `['value1', 'value2']`  与Object一样，不会调用构造函数
   - `Array.from(arrayLike, mapFun, thisArg)`  类数组结构 → 数组实例 （浅复制）
     - arrayLike — 想要转换成数组的伪数组对象或可迭代对象
       - 伪数组对象（拥有一个 `length` 属性、可索引元素结果的对象）
       - 可迭代对象（Set Map等）
     - mapFun — [可选] 新数组中的每个元素会执行该回调函数
     - thisArg — [可选] 执行回调函数`mapFun`时的`this`对象
   - `Array.of()` 一组参数 → 数组实例
     - 代替 `Array.prototype.slice.call(arguments)` 将对象转为数组的方法
2. 取值：基于0开始的 数字索引
3. 长度 `length` （不仅是可读属性）
   - 0 ≤ length
   - 移动至 `length = length-1` 删除最后一个元素 
   - 移动至 `length = length+1`添加最后一个元素 
4. 判断： `isArray()`
   - 使用`instanceof` 判断是否处于同一个继承链中，在封装过Array构造函数后的情况下，数组会不相同
   - `isArray()` 不论哪个全局执行上下文中创建，也可能判断是否为数组

### 数组空位 <span id='ES-13'></span>

```js
const options = [,,,,,]; // 使用一串逗号来创建空位
```

ES6中， 会将空位视为 <u>存在的元素</u>，值为`undefined`

ES6之前，将空位忽略，或视为空字符串 —— 行为不同、存在与否，会导致不同平台出现问题

​	**如果需要空位，可以用显示的`undefined`值代替**

### 查找

严格相等查找 （`===`比较）

1. `indexOf('') `& `lastIndexOf('')`：从0开始，不存在返回 -1
2. `includes('', start)`： 返回true / false

断言函数查找（短路判断）

1. `find` & `findIndex`：短路查找，不存在返回undefined

过滤

1. `.some()` & `every()` ：短路遍历，返回Boolean
2. `filter` 
   - 对于引用类型，返回 false（比较地址）
   - 变量所有元素，返回 新数组
   - 返回值：true，将currentValue加入新数组；false，跳过currentValue

```js
const newList = array.filter( function( currentValue, index, arr ) {
	// ...
    // return currentValue % 2 === 0 返回偶数
    return
})
// 箭头函数
array.filter( (currentValue, index, arr) => current*2 )
```

### 填充 & 复制

🚩 连接：

1. `arr.concat()  `

   - 传值：添加到arr后面，返回新数组

   - 传数组：数组的每一项添加到arr后面，返回新数组

     - 打平：是去掉中括号 `Symbol.isConcatSpreadable`

     ```js
     arr = ['red','green']
     
     // 不打平追加
     arr1 = [1,2,3]
     arr1[Symbol.isConcatSpreadable] = false
     arr.concat('yellow',arr1) // ['red','green','yellow',[1,2,3]]
     
     // 打平追加
     arr2 = [4,5,6]
     arr2[Symbol.isConcatSpreadable] = true
     arr.concat('yellow',arr2) // ['red','green','yellow',4,5,6]
     ```

2. 展开语法 `arr[...arr, ...arr2]`

🚩 复制

1. `slice(start, end)` — 提取指定位置的数据，返回一个新数组（字符串也可用）
   - 结束位置 < 开始位置，返回空数组
2. `copyWithin(target, start, end) ` **（ES6 新增方法）**
   - **浅复制数组（对象复制引用）**一部分到同一数组中的另一个位置，并返回它
   - 参数说明：必须为整数
     - target：指定复制序列的位置；
       - 负数，从末尾计算；≥`arr.lenght`，不发生拷贝
       - target在start之后，复制序列复制的序列将被修改以符合`arr.lenght`
     - start： 开始复制元素的起始位置
       - 负数，从末尾计算；无值，从0开始复制
     - end：结束复制元素的位置
       - 负数，从末尾开始计算；无值，直至数组结束
   - <u>不会改变原数组的长度</u>：超过长度、零长度、方向相反，不报错且不处理

🚩 替换 

1. `array.fill(value, start, end)` —  固定值替换数组的元素
   - 参数说明：必须为整数
     - target：指定复制序列的位置；
       - 负数，从末尾计算；≥`arr.lenght`，不发生拷贝
       - target在start之后，复制序列复制的序列将被修改以符合`arr.lenght`
     - start： 开始复制元素的起始位置
       - 负数，从末尾计算；无值，从0开始复制
     - end：结束复制元素的位置
       - 负数，从末尾开始计算；无值，直至数组结束
   - <u>不会改变原数组的长度</u>：超过长度、零长度、方向相反，不报错且不处理

🚩 `splic(start, delectNum, end) `， 改变原数组，返回处理后的数组

- **删除** `splice(start, num)` 返回删除[start],[start+1]…[start+num]，无删除的数据返回空数组

- **插入** `splice(start,0,interItem)` 从开始位置，删除0项，插入数据

- **替换** `splict(start,num,iterItem)` 

### 转换

1. 字符串转为数组 — 字符串具有`length`属性
   - str.split('指定拆分符')
   - arr.from(str, mapFun)
   - `..."abcd"` == `['a','b','c','d']` 
2. 数组转为字符串
   - `toString()`、``valueOf()``、``alert()`` — 为数组每一项调用 `toString()`
   - `toLocaleString() `— 每一项调用`toLocalString()`
   - `join("指定连接符")` — 某一项是`null`、`undefind`，返回结果是以空字符串表示
3. 对象转为数组
   - 为对象添加`length`属性，key值改为数组下标相同

### 栈队方法

1. 栈
   - `push`推入 — 接受任意数量的参数，逐个添加到末尾，返回修改后的数组长度
   - `pop`弹出 — 移除末尾最后一项，减少length值，返回移除项
2. 队
   - `push` + `shift` — 移除第一项，减少length值，返回移除项
   - `pop` + `unshift` — 前端添加任意项，返回数组长度， 反方向模拟队列
3. 展开语法： `array = [...array,...hd];`

### 重排序

​	都返回调用数值的引用

- reverse() ： 反转数组项顺序
- sort() : 升序排列数组项
  - 默认情况下，调用每项的`toString()`，比较得到的字符串，所以可能出现$ 10<5 $ 的情况
  - 可以 <u>接受一个比较函数作为参数</u>：

```js
// 比较值为字符串
// a<b -1, a在前面； a>b 1,a在后面；a=b 0,ab相等
value.sort((a,b) => a < b? 1 : a > b? -1: 0)
// 比较值为数值
value.sort((a,b) => b-a)
```

### 循环

#### 1. for

```js
for(let i = 0; i < arr.length; i++){}
```

​	同理，还有while、do...while，常用于数组遍历

####  2. for … in

```js
let obj = {name:'zhou',age:'**'}
for(let i in obj) {
 console.log(i, obj[i])
}
```

- `i` 是对象的`key`值，是**字符串形式**，可能会发生 <u>字符串运算</u>
- 不仅仅遍历自身属性，还会找prototype上的属性；加判断`obj[i].hasOwnProperty(i)`，否则不遍历

####  3. forEach

```js
arr.forEach(function(item, index),this){}

let arr = [1,2,3];
arr.forEach(function(i,index){
 console.log(i,index)
})
```

- **没有返回值**
- 不能中断遍历（没有break语句）；使用`try...catch{return}`返回
- 只能遍历数组，不能遍历普通对象

####  4. map

```js
arr.map(function(item, index, arr),this){}
//item	[必须],当前遍历项
//index	[可选],当前遍历项的下标
//arr	[可选],当前元素所属的数组对象

let arr = [1,2,3];
let tt = arr.map(function(i){
 console.log(i)
 return i*2;
})
```

- 【与forEach一样】没有返回值
- 不能中断遍历（没有break语句）；使用`try...catch{return}`返回
- 只能遍历数组，不能遍历普通对象

####  5. **filter**

​	对于引用类型的比较，返回false，因为比较的是引用地址

​	回调函数中，返回值为 `true`，currentValue将加入新数组；`false`，跳过currentValue

```js
arr.filiter(function(item, index, arr){
    // ...
    // return currentValue % 2 === 0 返回偶数
    return
})

let arr = [1,2,3];
let tt = arr.filter(function(i) => i > 1)
// [2,3]
```

- 数组的内置方法，返回通过过滤的元素组成的新数组，不改变原数组

####  6. some & every

```js
let arr = [1,2,3];
// 【some】
let tt = arr.some(function(i){
 return i>1;
})
// true, 存在一个就为true，短路判断

// 【every】
let tt = arr.every(function(i){
 return i>1;
})
// false, 任意一个都需要满足，否则为false，短路判断
```

#### 7.  reduce & reduceRight

```js
arr.reduce(function(pre, cur, index, arr){}, this){}
//pre	[必须] 初始值，计算结束后返回的值，且作为下次循环调用的第一个参数
//cur	[必须] 当前元素
//index	[可选] 当前元素的下标
//arr	[可选] 当前元素所属的数组
//this	[可选]

let arr = [1,2,3];
let ad = arr.reduce(function(i,j){
 return i+j;     //就是计算从左到右 1+2+3
})
// 6
```

- reduce（从左到右）计算数组中的每一个值，最终计算为一个值。
- reduceRight （从右到左）

#### 8. for … of 

```js
for (variable of iterable) {
    //statements
}
```

- [可迭代对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols)（包括 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)，[`Map`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map)，[`Set`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)，[`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String)，[`TypedArray`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)，[arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments) 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句 <span id='ES6-5'></span>

#### 9. 迭代器 iterator

​	表示"集合"的数据结构，有一个统一的接口机制完成遍历操作（依次处理该数据结构的所有成员），叫做**Iterator接口**。

- 迭代器对象的本质是一个 **指针对象**，使用`.next()`移动指针，会有两个结果
  - 下一项，返回对象
    - 当前成员数据信息(`value`) 
    - 是否完成遍历(`done` — Boolean)
    - `value:undefined` + `done:fale`  都是可以省略的
  - 引起`stopiteration` 异常
- Iterator接口在ES6规定中，定义在`Symbol.iterator`上
  - 具有这个`iterato`属性，可以认为是"可遍历的"
  - 调用`Symbol.iterator`会得到当前数据结构默认的遍历器生成的函数
  - `Symbol.iterator`本身是一个表达式，返回`iterator`属性

```js
while( ({value, done} = values.next())  && done === false) {}
// ({value, done} = values.next()) 在括号内，先执行，获得done，判断是否已经完成迭代，避免死循环
```

#### 10.迭代器 entries

​	`Object.entries(obj)`方法

- 将一个给定对象`obj`自身，可枚举属性的键值对以**数组**的形式返回出来，
- 其排列与使用 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环遍历该对象时返回的顺序一致
- （区别在于 for-in 循环还会枚举原型链中的属性）而entries不会。

```js
const obj = {'a':'3',b:'39'};
let objEntries = Object.entries(obj); //[ [ 'a', '3' ], [ 'b', '39' ] ]

const arr = [2,9,38,30]
console.log(Object.entries(arr)); //[ [ '0', 2 ], [ '1', 9 ] ]
```

`Array.prototype.entries()`方法

- 返回一个新的Array迭代器对象**`Array Iterator`**对象，该对象包含数组中每个索引的键/值对
- `Object [Array Iterator] {}`
- `Array Iterator`原型是有一个`next`方法，可以用于遍历迭代器取得的原数组的[key, value]

```js
const arr = [2,9]
// Array.prototype.entries() 
let entries = arr.entries(); 

// 返回Object [Array Iterator] {}
let {done, value} = entries.next(); 
// { value: [ 1, 9 ], done: false }

// 数组遍历循环
for(const [key,value] of arr.entries()){
    console.log(`${key}+${value}`);
    //0+2 1+9
}
```

### 清空数组

1. `splice(0, arr.length)` — 从零开始，删除至最后一个
2. `arr.length == 0`
   1. `== lenght+2`， 多出来的2个元素 ，赋值为undefined
   2. `== lenght-2`，减少的2个元素，后面的2个元素被删除
3. `arr = []` — 重置引用，之前的数组等待垃圾回收
4. `while(arr.pop())` — 非0的值，都为true

## Typed Array