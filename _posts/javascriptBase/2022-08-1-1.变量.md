---
title: 1. 变量
author: Ana-Ana
date: 2022-08-01
tags: [javascriptBase]
categories: ["JavaScript"]
render_with_liquid: true
layout: post
pin: true
---

## 数据类型

### 基本和引用类型区别

|                | 基本数据类型           | 引用数据类型                         |
| -------------- | ---------------------- | ------------------------------------ |
| 声明的存储分配 | 栈                     | 堆                                   |
| 不同的访问机制 | 可以直接访问到         | 只能操作对象在栈中的引用             |
| 复制变量时     | 值存放到新变量内存中，两个变量互不干扰   | 引用存放到新变量栈中，操作同一个地址 |
| 分配机制       | 自动分配，大小固定     | 动态分配，可指向同一块引用           |
| 回收机制       | 回收及时，生存时间固定 | 根据引用次数交给回收器回收           |


- 变量声明方式，会影响其数据类型
    
    使用`new`关键字会创建一个Object类型对象，其行为类似原始值

```js
let name = 'username' // typeof = string
name.age = 18
console.log(name.age) // undefined

let name = new String('username') // typeof = object
name.age = 20
console.log(name.age) // 20 
```

- 传递参数时，按值传递（与复制变量一样，引用类型仅传递地址）

    但在函数内部重写对象obj时，变成一个指向本地对象的指针，与外部对象断联。且这个指针在函数结束调用时，销毁掉了，对外部对象没有影响。

```js

function setName(obj){
    obj.name = 'nicholas'
    obj = new Object()
    obj.name = 'greg'
}

let person = new Object()
setName(person) // person.name = 'nicholas'
```

## 变量声明（es6 特性）

作用域又称为“执行上下文”，每个上下文都有一个关联的变量对象（varialbe object），定义的所有变量和函数都存在与此，在后台处理数据时可以读取到。上下文在其所有代码都执行完毕后会销毁，包括定义的变量和函数。

全局上下文是最外层的上下文，根据ECMAscript实现的宿主环境不同，表示全局上下文的对象可能不一样。在浏览器中，全局上下文指“window对象”。只有在退出浏览器或关闭页面时，window对象会销毁。

<b>ECMAscript程序执行流通过<u>上下文堆栈</u>进行控制。上下文执行代码时，创建变量对象的一个作用域链(scopt chain)，决定各级上下文代码访问变量、函数的顺序。正在执行的上下文位于堆栈最上面，其代码始终位于链条最前端；全局上下文变量始终位于链条最后面。执行标识符短路查找变量定义。</b>

上下文是函数，其活动对象（activation object）作为变量对象，最初只有一个定义变量`argument`；全局变量不包含。

### 块作用域

- 未定义声明变量类型，同样可以使用到该变量 -- 污染全局：可能修改到引用的文件内的变量

- 使用严格模式`"use strict"`要求必须声明

1. `for`没有块作用域，临时变量`i`定义使用`var`与全局变量同名时，将修改全局变量；推荐使用`let`声明，产生块级作用域

2. 立即执行函数： 避免对全局变量的污染，强制在函数内部使用

- 花括号`{}`内使用`let`产生块级作用域

· const 在同一作用域内不可改，函数内的局部作用域可再次声明

### var

1. 存在**变量声明提升**的缺陷： 未声明可使用，就是没有定义；js 所有声明提到函数体顶部，赋值操作留在原来的位置
2. 变量覆盖：多次声明定义无报错，使用最近定义的变量
3. 没有块级作用域；是函数级作用域

· var 声明的变量会保存到 Window 中，若与 Window 内已有全局对象同名，会修改到 DOM 的值

### const let

- ！块级作用域，不存在变量提升
- let 定义变量；
- const 定义常量，声明时必须赋值，值和引用地址不可更改，引用的值可以改

避免变量体现的缺陷，形成**TDC 暂时性死区**： 使用前必须先声明

- 变量名对内存地址的引用，引用不可更改；对象等同一个内存空间修改可以

  - 修改变量值会重新开辟一个内存空间，相当于修改地址引用

- 同一作用域中 不可重复声明

### 冻结变量 Object.freeza

· const 定义对象的内容可以改变，此时用到冻结变量

```javascript
const HOST = {
  url: "https://www..com/api",
  port: 442
};
Object.freeze(HOST);
HOST.port = 80; //在严格模式下报错：重复声明
```

### 共同点

- 函数中变量可访问到外部的全局变量（无论是哪种变量）

- 在块级作用域找不到时，往外查找定义

### 作用域链延长

1. try/catch 语句中的 catch块。   在catch语句之前，创建新变量对象，包含将要抛出的错误对象声明。

2. with 语句。   向作用域链前端添加指定对象

> 在IE8之前，catch捕捉到的错误添加到执行上下文的变量对象上，而不是catch语句的变量对象上，导致在catch外部也可以捕获到错误。

## 回收机制

​	JavaScript的执行环境在代码执行期间管理内存：确定哪个变量不再使用，回收它并释放内存。周期性执行。

​	最主要的标记策略：标记清理和引用计数

- 回收对象 —— 当一个变量没有被其他变量或属性引用的时候
  - 全局变量 ：持续到浏览器页面关闭
  - 局部变量 ：函数执行结束后

### 数据存储

- 基本数据类型 —— 栈

- 引用数据类型 —— 堆，在栈中存储实际对象引用

  当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾

### 两种常用方法

   ​	垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数

   #### 1. 标记清除法（大部分浏览器） Mark-Sweep 

   两个阶段：

   1. 标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达

      <p style="color:#ccc">（标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）</p>

   2. 清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）

   优点：实现简单

   缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）

   优化方案：**标记-整理法  Mark-Compact **

   ​	清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理

   #### 2. 引用计数法 Reference counting

   ​	追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：

   - 赋值给引用值时，引用数 +1；
   - 保存引用的变量被覆盖了，引用数 -1

   缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。

      b **循环引用**无法收回，导致内存泄漏。

   **3. 循环引用**

   在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 <u>循环引用</u> 的问题：

   - BOM 和 DOM 中对象是C++实现的COM对象，使用 <u>引用计数</u> 实现垃圾回收。即使引擎使用 <u>标志清理</u>，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。

   ```js
   let element = document.getElementById('one'); // com对象
   let obj = new Object() // 原生obj对象
   obj.element = element;
   element.obj = obj;
   
   // 避免：确保两者没有联系
   obj.element = null;
   element.obj = null;
   ```

   在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。

### 分代式垃圾回收机制

   - 新生代：对象存活时间短，通常支持 1~8M 
   - 老生代：对象存储 存活时间长、常驻内存的对象

   两个内存区域回收频率不同，V8才有两个垃圾回收器管控：

   ![新老生代视图](../assets/img/JavaScriptBase.assets/新老生代视图.png)

#### 新生代垃圾回收

   ​	Cheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为**使用区**（From 空间）。一个处于闲置状态的空间称为**空闲区**（To 空间）

##### 垃圾回收机制——翻转 （Scavenge）

   - 先对使用区中的活动做标记
   - 标记完成后，将使用区的<u>活动对象</u>复制进空闲区并进行排序
   - 将原先使用区对象占用的空间释放
   - 最后进行角色互换，把空闲区变为使用区，使用区变为空闲区


   缺点：由于只能使用堆内存的一半，所以<u>不适用大规模</u>的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）

##### 并行回收

   Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。

   那当GC时间过长就会造成页面卡顿问题。

   那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过

   并行回收机制：引入多个辅助线程来同时处理
   新生代对象空间就采用并行策略。在垃圾回收过程中，

   启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22

   由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。

##### 新生代何时会到老生代

   1. 多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理
   2. 复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配

#### 老生代垃圾回收

   ​	老生代数据大多是存活的对象，不需要时常更新，可以使用 <u>标记清收法</u> 回收。在V8中使用 **标记整理法** 解决标记清除后产生的大量内存碎片。

##### 增量标记 （incremental marking）

   ​	代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题

   - 一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。
   - 应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成

   >存在问题：
   >
   >​	小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法
   >
   >​	如何进行下一次小GC 标记？—— 惰性清理
   >
   >​	如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障

##### 三色标记法

   - 黑色表示对象自身及对象的引用都被标记（已检查状态）
   - 白色表示未被标记的对象（初始状态）
   - 灰色表示自身被标记，自身的引用未被标记（待检查状态）

   执行流程：

   1. 初始所有对象都是白色
   2. 从root对象开始、标记为灰色，并推入标记工作表中；
   3. 当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色
   4. 将自身的下一个引用对象标志为灰色

   一直执行，直到<u>没有可以被标记为灰色</u>的对象，剩下的白色对象都是不可达的，进入清除阶段；

   恢复时，从灰色标记对象开始执行

##### 写屏障

   目的：

   - 解决黑色对象在程序执行中被新添加引用
   - 已经标记黑色的被引用对象不再被引用了

   写屏障就有了以下两个变化：

   ​	1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。

   2. Write-barrier 机制强制不变黑的对象指向白色对象。
      - 这个也被称作<u>强三色不变性</u>。所以
      - 一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色
      - 从而保证下一次增量 GC 标记阶段可以正确标记

##### 惰性清理 （lazy sweeping）

   ​	增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。

## 优化回收 

### V8 script 隐藏类

   [JS 性能优化 ----- V8 隐藏类](https://zhuanlan.zhihu.com/p/591353951?utm_id=0)

   ​	“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中<u>一次性声明所有属性</u>

   ​	“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 `= null`

### 优化程序回收，提高性能

   1. 手动回收（不建议）：`window.ColloectGarbage()`（IE）、`window.opera.collect()`（opera7以上）立即启动垃圾回收；
   2. 解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。
   3. 使用 <u>块级作用域</u> ，尽早让垃圾回收程序介入。