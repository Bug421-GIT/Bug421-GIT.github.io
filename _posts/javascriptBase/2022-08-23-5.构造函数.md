---
title: 5. 构造函数
author: "Ana-Ana"
date: 2022-08-23
tags: [javascriptBase]
categories: ["JavaScript","Object","原型链"]
render_with_liquid: true
layout: post
pin: true
---
## 构造函数

​	定义： 与普通函数差别在于——使用了`new`调用

```javascript
function Person(name, age, job){
    this.name = name; 
    // ...
    this.sayhello = funciton(){ 
    	console.log('my name is' + this.name)
    }
}
// 使用new定义Person的子类，会自己返回对象

// 自定义构造函数： 确保被识别为特定类型
```

**new执行时做的四件事情** <span id="newOperate"></span>

1. 内存中创建对象
2. 指定构造函数：新对象内部的`[[Protorype]]` = 构造函数的`prototype`属性
3. 实例化对象：构造函数的`this` 指向这个新对象
4. 执行构造函数；给新对象添加属性和方法
5. 返回这个新对象 `this? this : {}`

### 原型

​	使用构造函数创建对象，其定义的方法和属性在每个实例上都备份了一次，但其有些只需要维护一份。

​	为每个函数的**`prototype`属性**下包含特点引用类型的 <u>实例共享方法和属性</u>。—— 原来在构造函数中赋予对象实例的值，都可以直接赋值给它们的原型

```javascript
function Person(name) {
    this.name = name;
}
Person.protorype.sayHello = function(){
    console.log('my name is' + this.name)
}
person1 = new Person('小芳');
person2 = new Person('小福');

person1 === person2 // false
person1.name == person2.name // false
person1.sayHello === person2.sayHello // true
```

#### construct.prototype 

- `prototype` 是一个对象，又称原型对象
- 其属性和方法都归构造函数所有
- 所有的对象都共享原型对象

#### instance.`__proto__`

- 又称为 对象的原型
- 每个对象都有这个属性

构造函数 `Person.prototype`和 对象`person.__proto_`是指向是等价的

#### 原型的其他构造语法

```javascript
function Person() = {}
// 重新定义属性
Person.protorype.sayHello = function(){
    console.log('my name is' + this.name)
}
// 1. 对象字面量
Person.prototype = {
    constructor: fatherClass, // 使用构造函数，指回原来的原型
    name: 'humen',
    sayHello() {
        console.log('My name is '+ this.name);
    }
}
```

- 对象字面量方式，需要重写`constructor`属性，使得`[[Enumerabele]]`键值为`true`。
- 原生的`constructor`属性默认不可枚举，需要使用`Object.defineProperty()`修改回来

```javascript
// 2. 修改 Object.defineProperty()
Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person	
})
```



### 原型链

​	**对象的原型属性，指向创建它的构造函数`object.__proto__.constructor`的原型属性 `__proto__`所指向的原型对象 **

![原型链.drawio](../assets/img/JavaScriptBase.assets/原型链.drawio.png)

​	修改实例所在的原型链，可以使用`Object.setprototypeOf()`但不建议。应该通过`Object.create(construct)`为新对象指定构造函数。

### 成员查找机制

（就近原则）

1. 这个对象自身有没有 这个属性（或方法）
2. 没有，查找它的原型 （`__proto__`指向的`prototype原型对象`）
3. 还是没有，查找原型的原型（Object的原型对象）
4. 一次类推，直至找到 `null` 为止

**实例只有指向原型的指针，没有指向构造函数的指针。** 

​	实例在**原型**更改前已经存在，依然可以在原型更改后查找到最新的。因为搜索值的过程是动态的。实例与原型之间的松散关系。

​	实例在**构造函数重写**前已经存在，依然引用的是最初的原型；重写会切断最初原型与构造函数的联系。

### in操作符

#### 单独使用 `in`操作符

​	通过对象访问指定的属性时，返回`true`，无论这个属性是在实例还是原型上。

​	需要使用`.hasOwnProperty('..')` ，才可以判断是否存在于自有的属性上。

```javascript
function hasPrototyperty(object, name){
    return !object.hasOwnProperty(name) && (name in object)
}
```

#### `for-in` 循环中使用

​	可以通过对象访问、可以<u>被枚举</u>的属性，都会返回。包括实例属性、原型属性。

```javascript
function Person(name) {
    this.name = name;
}
Person.prototype.local = 'shanhai';
Person.prototype.sayHello = function(){
    console.log('my name is' + this.name)
}
let p1 = new Person();

// 获取对象上所有可枚举的实例属性
Object.keys(Person.protorype); // ['local', 'sayHello']
Object.keys(p1);	// ['name']

// 获取对象上所有实例属性，无论是否可以枚举 (constructor 为不可枚举)
Object.getOwnPropertyNames(Person.prototype); //  ['constructor', 'local', 'sayHello']
Object.getOwnPropertyNames(Person); // ['length', 'name', 'arguments', 'caller', 'prototype']

// 获取对象上所有的实例属性，键位符号
Object.getOwnPropertyNames()
```

​	**它们枚举顺序是确定的。:one: 先以升序枚举数值键，:two: 插入顺序枚举字符串和符号键 :three: 对象字面量定义的键，以逗号分隔顺序插入**

### 继承 6 种方法

#### 1、**原型链继承；**

- 通过将**一个类型A的实例**赋值给另一个B**构造函数的原型**实现的 -- B 继承 A

- 重点：让新实例的原型等于父类的实例 —— **子类的.prototype = new 父类()**，子类的实例也是父类的实例

  特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。

  缺点：

  1、新实例**无法向父类构造函数传参**。

  2、继承单一。 

  3、所有新实例都会**共享父类实例的属性**。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！）

  4、子类.prototype 添加属性必须在 指向了父类之后，否则会被覆盖

- 查看私有属性：hasOwnProperty() — 包括查找原型链中的 [*prototype*] 的Property

#### 2、**借用构造继承**

（也称伪造对象或经典继承）；

- `function Child(name){ Parent1.call(this，name), Parent2.call(this，name)}` 
- 优点 
  - 实现多继承，通过call改变父类的this
  - 创建的子类实例可以向父类传递参数
  - 解决了原型链继承中，所有子类的实例共享父类实例的属性。
- 缺点
  - 实例是子类的实例，不是父类的实例。
  - 只能继承父类实例属性、方法；不能继承父类原型上的方法
  - 子类实际上是复制了父类的方法当作自己的方法，多个相同的子类占用较大内存
  - 父类的方法改变时，已经存在的子类实例并不能更新方法

#### 3、组合继承

组合：原型链继承 + 借用构造函数继承

**.call** (调用函数者， 参数1， 参数2);

改变this的指向

```javascript
function fn(x, y) { console.log(this); }
let o = {}
fn(1, 2); // this指向window
fn.call(o, 1, 2); // this指向o
```

- 主要应用：组合继承

构造函数 + 原型对象（ES5）

```JavaScript
// 构造继承：借用父构造函数，继承其属性
function Father(name, age){
    this.name = name;
    this.age = age;
}
function Son(name, age){
    // this指向Son  调用Father的构造函数，
    // 将son.this 替换掉 father.this，于是son就拥有了father的属性
    Father.call(this, name, age);
    // ... 子类的属性和方法
}

// 原型对象 继承其方法
// 【错误示范】
Son.propototype = Father.prototype;
Son.propototype.exam = function() {}; // 修改Son构造函数的 方法
// console.log(Father) 也存在Son的方法 ———— prototype是对象，赋值传递是引用，两者指向同一个内存空间；继承应执行父类的实例而不是父类对象
// 【正确示范】
Son.prototype = new Father();  // 新建一个Father实例，既有属性、又有方法； 使用对象的方式修改prototype，会使修改原型链
Son.prototype.construcor = Son; // 利用construcor 指回原来的原型对象

let son = new Son("sonName","sonAge");
```

​	核心思想：使用原型链继承原型上的属性和方法，通过借用构造函数继承实例属性。

![组合继承.drawio](../assets/img/JavaScriptBase.assets/组合继承.drawio.png)

​	组合继承仍然保留了`instanceof`操作符和`isPrototypeOf()`方法识别对象的能力 —— 关注类型和构造函数的场景。

​	存在问题：**父类的构造函数始终会被调用两次**，导致性能浪费

​	:one: 创建子类原型时调用：获取原型属性 —— 父类实例属性成为子类原型属性

​	:two: 子类构造函数中调用 —— 新对象上创建实例属性，覆盖父类实例属性

​	[**寄生式组合继承**](#parasiticCombinationInheritance)可以解决这个问题

#### 4、**原型式继承**

​	`object()`方法通过对传入对象执行了一次浅复制——新对象的原型上既有原始值属性，又有**引用值**属性。<u>子类对于引用值属性的修改，都会同步影响</u>。

​	适用于：不需要单独创建构造函数，但仍然需要在对象间共享信息。	

```javascript
// 06年，Douglas Crockford 所著文章提出的一个函数：
function object(o){
    function F() {}	// 创建一个临时构造函数
    F.prototype = o; // 将传入的对象作为这个构造函数的原型
    return new F;	// 返回这个修改过原型的对象
} // F extends o，再对返回的F对象进行修改

// ES5 通过新增 Object.create() 方法，将原型式继承的概念规范化了
let Person = {
    name: "Nicholas",
    friends: ['sell','court','bar']
}
let onePerson = Object.create(Person,{ // 仅有第一个参数，效果与第一个函数一样
    name:{
        value: "Gred"; // 第二个参数与 Object.defineProperties() 第二个参数一样，新增属性要通过自己描述符
    }
})
```

#### 5、**寄生式继承**

​	思路类似于 <u>寄生构造函数和工厂模式</u>： 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。

```javascript
function createSub(original){
    let clone = object(original); // 创建一个父类实例
    clone.sayHi = function(){
        console.log("hi!")
    };
    return clone;
}
```

​	返回的 `clone` 对象相较于 `original`对象而言，除了拥有其所有属性和方法，还拥有自己的方法。<u>但是会导致函数难以重用</u>。

​	适用范围： 与原型链继承一样，关注对象而不在乎类型和构造函数的场景

#### 6、**寄生组合式继承** <span id='parasiticCombinationInheritance'></span>

​	**借用构造函数继承属性**（取得父类原型的副本），**组合继承方法**（给副本设置`constructor`属性，解决重写原型修改到默认构造函数）。

```javascript
function inheritPrototype(subType, superType){
    let prototype = object(superType.prototype); // 取得父类原型的副本
    prototype.constructor = subType; // 恢复默认构造函数
    subType.prototype = prototype; 	// 新创建的对象作为子类的原型
}
```

​	仅调用一次`superType`构造函数，避免`subType.prototype`上获得不必要也用不到属性。

​	原型链仍然保持不变，因此仍然保留了`instanceof`操作符和`isPrototypeOf()`方法识别对象的能力 —— 关注类型和构造函数的场景。