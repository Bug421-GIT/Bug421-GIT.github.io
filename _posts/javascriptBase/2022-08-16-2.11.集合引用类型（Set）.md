---
title: 2.11.集合引用类型（Set）
author: Ana-Ana
date: 2022-08-16
tags: [javascriptBase]
categories: ["JavaScript","引用类型"]
render_with_liquid: true
layout: post
pin: true
---
## Set & WeakSet

- Set类数组，不可放重复数据，不约束不同类型的数据

- 对象，约束不同类型的数据（原始值还是对象引用，统统转换为字符串存储），同名属性会覆盖

- Set 使用 `key:key` 方式存储：

  ```javascript
  set.values === set[Symbol.iterator] // true
  set.keys === set[Symbol.iterator] 	// true
  set.values() === set.keys() // false
  
  set.entries(); // 返回集合中的每个值重复出现
  // 0: {"李四" => "李四"}
  // 1: {"王五" => "王五"}
  // 2: {"吴六" => "吴六"}
  ```

## 定义

```javascript
const m = new Set() // 空映射，可用const定义

// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组
// 每个键值对按顺序插入到新映射实例中
let Set = new Set(["李四", "王五", "吴六"]);
console.log(Set); // 3
```

```javascript
// 使用自定义函数初始化
const Set2 = new Set({
    [Symbol.iterator]: function*() {
        yield 'value1';
        yield 'key2','value2';
        yield 'key3','value3';
    }
})
console.log(mep2.size); // 3
```

```javascript
const set = new Set([1,2,3,4,6,4,2,1]);  // Set(5) {1, 2, 3, 4, 6} 自动去重

// 声明时变量为字符串，将字符串展开为单个字符赋值成对象,，并自动去重
const set = new Set('hello');  // Set(4) {'h', 'e', 'l', 'o'} 自动去重
```

## 增删改查

```javascript
const set = new Set([['firstName','matter'],['lastName','petter']]);

// 新增值,返回Set对象,可以链式定义
set.add("name","张三").add('age',10)

// 查询值 
// 1. 通过键查找: set.has(key)
set.has('firstName'); // true
set.has('matter'); //false
// 2. 返回所有键 
set.keys(); // SetIterator {'李四', '王五', '吴六'}
// 3. 返回所有值
set.values(); // SetIterator {'李四', '王五', '吴六'}
// 4. 返回所有键值对
set.entries(); //SetIterator {'李四' => '李四', '王五' => '王五', '吴六' => '吴六'} 

// 查询个数
set.size() // 3

// 删除
// 1. delete(key) 是否成功删除 
set.delet('firstName'); // ture
set.delet('firstName'); // false
// 2. clear() 全删,无返回值
set.clear(); // undefined Set.size=0
```

## 转换

1. set换数组：

   - Array.from(set);

   - `[...set]`

2. 数组换set：去重复

   ```javascript
   // 数组去重
   const set = new Set(['a','b','a','b']);
   const ary = [...set]
   
   [... new Set(array)]
   ```

## 遍历

1. 取值：	`set.value` / `set.entries`
2. `forEach( function(value, key, arr))：value = key`
3. `for-of： set.value`

## 自定义操作：交并差

​	Set 和 Map 一样可以存放各种数据类型作为值，使用 SameValueZero 操作判断是否相等（类似于严格相等`===`）

- 并：合并多个set，去重

```javascript
const a = new Set([1,2,3,4,5,3,2,4])
const b = new Set([1,2,3,4,5,7,8,9])

// 第一种方法
new Set([...a,...b]) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}
// 第二种方法

function union(a, ...bSets){
    const unionSet = new Set(a);
    for (const b of bSets){
        for(const bValue of b){
            unionSet.add(bValue);
        }
    }
    return unionSet;
}
unionf(a, b) // Set(8) {1, 2, 3, 4, 5, 7, 8, 9}
```

- 差： 展开[a]每个元素过滤掉 b**存在** 的元素

```javascript
// 第一种方法
new Set(
	[...a].filter(function(item){
        return !b.has(item);
    })
)
// 第二种方法
function difference(a, b) {
    const differenceSet = new XSet(a);
    for(const bValue of b){
        if(b.has(aValue)) differenceSet.delete(bValue);
    }
    return differenceSet;
}
```

- 交：展开[a]每个元素过滤掉 b**不存在** 的元素

```javascript
// 第一种方法
new Set(
	[...a].filter(function(item){
     	return b.has(item);   
    })
)
// 第二种方法: 返回两个或更多集合的交集
function intersetion(a, ...bSets) {
    const intersectionSet = new XSet(a);
    for (const aValue of intersectionSet){
        for(const b of bSets){
            if(!b.has(aValue)) intersectionSet.delete(aValue);
        }
    }
    return intersectionSet;
}
```

- 对称差集 ： 所有不属于A∩B的元素的集合，$A△B = {x|x∈A∪B,x∉A∩B} = (A∪B) — (A∩B)$ 

```javascript
function symmetricDifference(a, b){
    return a.union(b).difference(a.intersection(b));
    // a.union(b) 取全集
    // a.intersection(b) 取同时属于a、b交集
    // c.difference(d) 	// 全集下不属于交集的部分
}
```

- 笛卡尔积 ：X×Y，第一个对象是*X*的成员而第二个对象是*Y*的所有可能[有序对](https://baike.baidu.com/item/有序对/0?fromModule=lemma_inlink)

```javascript
function cartersianProduct(a, b){
    const set = new Set();
    for(const aValue of a){
        for(const bValue of b){
            set.add([aValue, bValue]); // 数组的集合
        }
    }
    return set;
}
```

- 集合的幂集 ：集合中所有的子集（包括全集和空集）构成的集族

```javascript
function powerSet(a){
    const powerSet = new Set();
    powerSet.add(new Set()); // 包含空集
    for(const aVal of a){
        for(const set of new Set(powerSet)){
            powerSet.add(new Set(set).add(aVal))
        }
    }
}
```

## WeakSet

值必须是引用类型，保存对象数据。 不是正式引用，不会影响垃圾回收机制。

对DOM操作时，DOM节点删除后无需修改WeakSet的引用

**弱引用类型的特性**

1. 强引用类型的特性

   对象、数组对同一块内存空间引用时，会将空间引用数+1

   当所有对该内存空间引用被置为null时，JavaScript对该内存数据当作垃圾处理，回收空间

2. 弱引用类型的特性

   WeakSet作为弱引用类型使用内存空间时，不会将空间引用数+1

   当该内存空间引用数为0时，JavaScript对内存回收不会通知WeatSet引用数据不存在

   WetSet访问为No propertise

- 无法使用循环
- 无法访问`.value` `.key` `.size`等属性
- 无需将引用赋值为null