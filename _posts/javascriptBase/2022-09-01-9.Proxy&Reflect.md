---
title: 9. Proxy & Reflect
author: "Ana-Ana"
date: 2022-09-01
tags: [javascriptBase]
categories: ["JavaScript","Object"]
render_with_liquid: true
layout: post
pin: true
---

## Proxy & Reflect

- 代理 — 改变某些操作的默认行为， — Reflect确保原有默认行为正常
- [实现元编程]([Reflect Metadata | 深入理解 TypeScript (jkchao.github.io)](https://jkchao.github.io/typescript-book-chinese/tips/metadata.html#基础)) — 对编程语言进行编译（在语言层面编程）
- `var proxy = new Proxy( target, handler )`
  - target — 所要拦截的 目的对象
  - handle — 定制拦截对象
- `Proxy.prototype = undefined` ，所以不能用`instanceof`操作符
- **不可配置、不可读写的属性不能代理**

```js
var proxy = new Proxy({},{
    get:function(target, key, receiver){ // obj.p时，触发p作为target
        return Reflect.get(target, propKey, receiver);
    },
    set:function(target, key, value, receiver){
        return Reflect.set(target, propKey, value, receiver);
    }
})
let obj = Object.creat(proxy); // 将proxy添加到obj的原型上，实现Proxy的继承，读取【原型属性】会被拦截

var object = {proxy: new Proxy(target, handler)}; // object 可以调用proxy
```

要使Proxy起作用，必须针对Proxy实例proxy操作，而不是针对目标对象操作 —— 直接操作会绕过代理施予的行为

```js
const targetObj = {
    where:function(){
        console.log("I am in target");
    }
};
var proxy = new Proxy(targetObj,{
    get:function(target, propKey){
        if(propKey === "where"){ // targetObj 里面的属性名 === where进行拦截
            console.log("I am in proxy");
        }
        return target[propKey]; // 返回targetObj原有的属性

    }
});
proxy.where();  //I am in proxy + I am in target
target.where(); //I am in target
```

若handler是一个空对象，则没有任何拦截效果，访问 Proxy = 访问 target

### Reflect

​	`Reflect`一个全局内置对象，将默认操作从处理器转发到 `target`。处理器对象中所有可以捕获的方法都有对应的**反射（Reflect）**API方法。Reflect 与 targe 方法具有相同的名称和签名属性，且具有相同的方法行为。

​	`Reflect`不是一个函数对象、构造函数，无法像对象一样调用和使用`new`创建实例；内部所有的属性和方法都是静态。

```javascript
// 1. 安全调用函数
// 使用 apply 调用函数时，target 可能自定义了自己的 apply 属性，可以使用 Function.prototype 规避这个问题
Function.prototype.apply.call(Math.floor, undefined, [1.75]); // 1
Reflect.apply(Math.floor, undefined, [1.75]); // 1;
```

​	根据一些反射方法返回"状态标记"的布尔值，可以检查意图操作是否成功。<u>但如果是语法出现问题，无法拦截错误</u>。

```javascript
// 2. 使用“状态标志”替换属性定义异常捕获处理
try{
    Object.defineProperty(obj, prop, attr);
}catch(e) {
    // Fail
}
	// 
// if (Reflect.defineProperty(obj, prop, attr)) 
if (Reflect.defineProperty(o,'foo',{value:'bar'})){
    console.log("1")
}else{
    console.log("2")
}
```

| Reflect API                 | 返回值       | 与操作符相比                                                 |
| --------------------------- | ------------ | ------------------------------------------------------------ |
| Reflect.defineProperty()    | 提供状态标志 |                                                              |
| Reflect.deleteProperty()    | 提供状态标志 | 代替`delete`操作符                                           |
| Reflect.setPrototyoeOf()    | 提供状态标志 |                                                              |
| Reflect.has()               |              | 代替`in`、`with`操作符                                       |
| Reflect.set()               | 提供状态标志 | 代替`=`操作符                                                |
| Reflect.get()               |              | 代替对象属性访问操作符                                       |
| Reflect.preventExtensions() | 提供状态标志 | 类似`Objext.preventExtensions`（可强转为对象），但操作对象只能是对象 |
| Reflect.construct()         |              | 代替`new`操作符                                              |

```javascript
// 3.Reflect API 与 一等函数 替换使用
Reflect.has(Object, "assign"); // true
"assign" in Object // true
```

​	**在代理中简化使用Reflect**

```javascript
const handler = {
    get() {
        const someString = "修饰返回值"
        return Reflect.get(...arg) + someString;
    }
}
new Proxy(target, handler)

const handler = {
    get:Reflect.get;
}
new Proxy(target, handler)

// 捕获所有方法，并转发给对应反射API的空代理，可以不定义Handler，直接使用Reflect
new Proxy(target, Reflect)
```

### this的问题

1. 目标对象内部的this，指向Proxy代理
   1. Proxy无法代理目标对象
   2. 通过this区分的内部函数，指向proxy后可能取不到
   3. 【使用目标对象调用自身属性方法】Reflect.get()
2. 拦截函数的this，指向handler对象

### get

`get(target, propKey, receiver)`

- propKey — 属性名
- receiver — 操作行为所针对的对象 [可选] （）

1. [目标对象不存在的属性，访问时抛出指定的错误](#proxy_get-1)
2. [数组读取负数的索引](#proxy_get-2)
3. [读取属性返回函数，实现链式操作](#proxy_get-3)
4. [生成各种DOM节点的通用函数](#proxy_get-4)

<span id='proxy_get-1'> 目标对象不存在的属性，访问时抛出指定的错误</span>

```js
// 目标对象不存在的属性，访问时抛出指定的错误
var person = {
    name: '张三'
}
var proxy = new Proxy(person, {
    get: function (target, propKey) {
        if (propKey in target) {
            return target[propKey]
        } else {
            throw new ReferenceError(`属性名${propKey}不存在`)
        }
    }
})
proxy.name
proxy.age
```

<span id='proxy_get-2'>数组读取负数的索引</span>

```js
// 数组读取负数的索引
function createArray(...elements){
    let handle = {
        get(target, propKey, recevier){
            let index = Number(propKey);
            if(index < 0) propKey = String(target.length + index); // 倒序
            return Reflect.get(target, propKey, recevier) // 结束代理处理，使用target原生处理函数
        }
    }
    let target = [];
    target.push(...elements);
    return new Proxy(target, handle)
}
let arr = createArray('a','b','c','d','f');
console.log(arr[-1]); // f
```

<span id='proxy_get-3'>读取属性返回函数，实现链式操作</span>

```js
var pipe = function(value){
var funcStacke = []; // 函数堆
var oproxy = new Proxy({},{
    get: function(pipObject, fnName){
        /* 如果当前函数为get，则链式传递到最后一个函数，返回堆栈内函数的计算结果
           否者，不为get，链式传递后面还有函数，将当前函数推入funcStrcke，返回Proxy，继续推入函数 */
        if(fnName === 'get') {
            /* reduce 中的每一项都递归传入，
            指定val（第一个参数）为pipe的参数；fn是funcStacke的第二个函数，
            返回计算的结果值 */
            return funcStacke.reduce(function(val, fn){
                return fn(val)
            },value)}
        funcStacke.push(window[fnName]); //
        return oproxy;
    	}
	});
    return oproxy;
}
var double = n => n*2;
let number = pipe(2).double.get;
// 1.pipObject = {}; fnName = double,  funcStacke = ['n => n*2']
// 2.pipObject = {}; fnName = get;      
console.log(number);
```

<span id='proxy_get-4'>生成各种DOM节点的通用函数</span>

```js
// 1. target:obj -- property:p -- attrs:href: '//example.com' -- children: ['Mark']
// 2. target:obj -- property:a -- attrs:{} -- children:['The web']
// 3. target:obj -- property:ul - attrs:{} -- children:['Food']
// 4. target:obj -- property:li - attrs:{} -- children:["…actually that's it"] 
// 5. target:obj -- property:li - attrs:{} -- children:[li, li, li]    
// 6. target:obj -- property:li - attrs:{} -- children:['Hello, my name is ', a, '. I like:', ul] 
const dom = new Proxy({}, {
    get(target, property) {
        return function (attrs = {}, ...children) {
            const el = document.createElement(property); // 传入的属性值创建节点
            for (let prop of Object.keys(attrs)) {
                el.setAttribute(prop, attrs[prop]); // 节点添加属性
            }
            for (let child of children) { 
                if (typeof child === 'string') { // 孩子节点是字符串，添加节点文字
                    child = document.createTextNode(child);
                }
                el.appendChild(child); // 父节点添加孩子
            }
            return el;
        }
    }
});
const el = dom.p({},
                 'Hello, my name is ',
                 dom.a({ href: '//example.com' }, 'Mark'),
                 '. I like:',
                 dom.ul({},
                        dom.li({}, 'The web'),
                        dom.li({}, 'Food'),
                        dom.li({}, '…actually that\'s it')
                       )
                );

document.body.appendChild(el);
```

### set

​	`set(target, propKey, propValue, receiver)`

- propKey — 属性名
- propValue — 属性值

1. [数据验证 — 不符合要求的设定值，抛出异常](#proxy_set-1)
2. [数据绑定 — 当对象发送变化是，自动更新DOM](#proxy_set-2)
3. [结合set、get，实现属性名第一个字符使用下划线，不允许外部使用](#proxy_set-3)

<span id="proxy_set-1">数据验证 — 不符合要求的设定值，抛出异常</span>

```js
let validator = {
    set: function (obj, prop, value) {
        if (prop === 'age') {
            if (!Number.isInteger(value)) {
                throw new TypeError('The age is not an integer');
            }
            if (value > 200) {
                throw new RangeError('The age seems invalid');
            }
        }
        // 对于满足条件的 age 属性以及其他属性，直接保存
        obj[prop] = value;
        return true;
    }
};

let person = new Proxy({}, validator);

person.age = 100;
person.age = 'young' // 报错
person.age = 300 // 报错
```

<span id="proxy_set-2">数据绑定 — 当对象发送变化是，自动更新DOM</span>

```html
<body>
    <input type="text" id="model">
    <p id="words">222</p>
</body>
```

```js
const model = document.getElementById("model");
const words = document.getElementById("words");

const proxy = new Proxy({}, {
    get(target, propKey, receiver) {
        return Reflect.get(target, propKey, receiver)
    },
    set(target, propKey, propValue, receiver) {
        if (propKey === 'key') { // 修改的属性名是key，则修改对应的值
            model.value = propValue;
            words.innerHTML = propValue
        }
        return Reflect.set(target, propKey, propValue, receiver)
    }
})

// 给输入框添加点击事件
model.addEventListener('keyup', (e) => {
    proxy.key = e.target.value;
})
```

<span id="proxy_set-3">结合set、get，实现属性名第一个字符使用下划线，不允许外部使用</span>

```js
const handler = {
    get(target, key) {
        invariant(key, 'get');
        return target[key];
    },
    set(target, key, value) {
        invariant(key, 'set');
        target[key] = value;
        return true;
    }
};
function invariant(key, action) {
    if (key[0] === '_') {
        throw new Error(`Invalid attempt to ${action} private "${key}" property`);
    }
}
const target = {};
const proxy = new Proxy(target, handler);
proxy._prop
// Error: Invalid attempt to get private "_prop" property
proxy._prop = 'c'
  // Error: Invalid attempt to set private "_prop" property
```

### apply(target, this, args)

​	`apply(target, this, args){}`

- this，目标对象的上下文

- args，目标对象参数数组

  拦截函数 — call、apply — 触发调用

###  has (target， key)

- key ，需要查询的属性名
- 拦截 **HasProperty()**
  - has() 不判断一个属性是对象自身的，还是继承的
  - 只对 in运算符生效，而不对`for... in`生效

### construct (target, args, newTarget)

- newTarget， 创建实例对象，new命令作用的构造函数
- :warning: target必须是函数
- :warning: 返回的必须是对象

### 存在问题

#### 目标对象方法依赖于调用对象标识

```javascript
const wm = new WeakMap() // 类外部定义，所有实例共享一个 WeakMap
class User{
    constructor(id){
        wm.set(this,id)
    }
    get id(id) return wm.get(this);
    set id(newid) 	wm.set(this,id)
    // ... get() set()
}

const user = new User(123);
const userProxy = new Proxy(user,{}); 
// wm: {user {}: 123}
wm.get(User)	// undefined
user.id 		// 相当于 wm.get(user), 返回 123
userProxy.id 	// 相当于 wm.get(userProxy), 返回 undefined
```

​	`wm.get(this)` 方法依赖于调用的对象，暴露了`this`指向问题，使得返回值不正确；把**代理User实例改为代理User类本身**，再创建代理实例，就会以<u>代理实例</u>作为WeakMap的键了。

```javascript
const UserClassProxy = new Proxy(User,{});
const proxyUser = new UserClassProxy(456);
const proxyUser2 = new UserClassProxy(789)
// wm: WeakMap {User => 456, User => 789}
wm.get(User) // undefined
user 	// undefined 类没有创建实例，而是直接使用类代理，创建代理的实例
proxyUser.id // 456
proxyUser2.id // 789
```

#### 代理与内部槽位

​	当ECMAScript内置类型可能会依赖某些代理无法控制（访问器无法访问到的方法）的机制，会导致使用代理调用时出现问题。

​	例如`Date` 类型方法的指向依赖`this`值上的内部槽位`[[NumberDate]]`，值不能通过普通的`get()`和`set()`操作访问到，且代理对象不存在这个内部槽位。于是代理拦截后本应该转发给目标对象的方法，会抛出异常 `TyperError`。

```javascript
const target = new Date();
const proxy = new Proxy(target, {});
proxy instanceof Date; // true
proxy.getDate(); // 'this' is not a Date object;
```