---
title: 8. 闭包
author: "Ana-Ana"
date: 2022-08-29
tags: [javascriptBase]
categories: ["JavaScript","闭包"]
render_with_liquid: true
layout: post
pin: true
---
## 闭包

### 作用域

- 在执行上下文中，存在两种变量：

1. 变量对象（全局变量）：全局上下文，在代码执行期间始终存在，保存在`scope-script`里
2. 活动对象（局部变量）：执行上下文，只在函数执行期间存在

- 生成的时机：

1. 在定义函数时，会为它创建作用域链，申请空间，预装载全局变量，并保存在内部的`[[scope]]`中。
2. 预编译不会执行函数里面的内容
3. 在调用函数时，创建相应的执行上下文，并通过复制函数的`[[scope]]`创建其作用域链；并创建函数的活动对象，推入作用域链的前端。

​	作用域链：包含指针的列表，执行每一个变量对象；标识所在位置越深，读写速度就会越慢（全局总是在最末端）

​	在一个函数内部定义的函数，会把其包含函数的活动对象（所有外部的局部变量）添加到自己作用域链中



​	多次调用同一个函数，占用不同的空间，多个内存地址，之间的数据不会共享

### 函数生命周期延长

1. 普通函数创建实例

   return 内部函数（引用类型）给外部使用`let a = func()`。只要外部使用不停止，函数就不会被回收

   外部变量`a`重复调用时，函数变量内部变量值不变，在原有的基础上继续进行处理；而不是重新开始

   使用另一个外部变量调用函数，又会重新在内存空间开辟新地址，所有变量初始化（函数调用开辟新开机）；此变量之后的重复使用，在原有的基础上继续处理（变量保存函数空间的地址）

2. 构造函数，默认返回引用；每个实例一个内存空间

### 什么是闭包

闭包（Closure）：指一个函数可以访问到其外层函数中的数据（作用域）—— 闭包是函数

作用：

- 延长变量的生命周期：全局变量不会被回收
- 创建私有变量空间：私有变量不会污染全局

弊端：闭包会保留包含它们函数的作用域，比其他函数更占用内存



暴露一个访问器，返回出去的变量可通过该函数间接范围；**在javascript语言中，内层函数可以访问到外层函数的数据（即使外层函数不再存在引用），即为闭包**

![闭包延长生命周期的原理.drawio](../assets/img/JavaScriptBase.assets/闭包延长生命周期的原理.drawio.png)

​	**内部函数永远不能直接访问到外部函数 `this` 和 `arguments` 这两个变量。**箭头函数中的`this`非严格模式下执行`window`；严格模式下值为`undefined`。想要访问，可以使用 [变量存this](#that)，将其引用保存到闭包能够访问得到的变量中。

```javascript
window.getIdentity = "the window"
let object = {
    identity : "the object",
    getIdentity(){
        return function(){
            this.identity;  // "the window" 内部函数无法访问外部函数的this，内部this不存在这个变量往全局找
        }
    }
}
let object = {
    identity : "the object",
    getIdentity(){
        let that = this;
        return function(){
            that.identity;  // that 是外部函数变量，闭包可以访问到
        }
    }
}
```

​	对象内部使用了`this`

```javascript
let object = {
    identity : "the object",
    getIdentity(){
        return this.identity;  // 对象方法内部直接使用this
    }
}
object.getIdentity(); // “the object"
(object.getIdentity = object.getIdentity)(); // the window
// 执行了一次赋值，然后再调用赋值后的结果；表达式的值是函数本身(getIdentity())，this值不再于任何对象绑定，返回全局变量
```

### 内存泄漏

​	闭包一直持有可能已经销毁的外部变量，可能导致内存泄漏。匿名闭包将可能难以清除。

```javascript
function assignHandler(){
	let ele = document.getElementById("elementId");
    ele.onclick = () => { console.log(ele.id); }
}
```

​	内部函数形成了一个闭包，这个匿名函数一直持有着 `assignHandler` 中的活动对象，即DOM元素的引用。只有匿名函数存在，`ele`的引用数就至少为1，内存永远不会被回收。

```javascript
function assignHandler(){
	let ele = document.getElementById("elementId");
    let id = ele.id
    ele.onclick = () => { console.log(id); }
    el
}
```

​	:one: 消除循环使用，只保存外部函数变量，而不是外部函数获取到的其他元素

​	:two: 闭包会引用外部函数的活动对象，其中仍然包含DOM元素的引用，所以需要把外部引用设置为null

​	至此，闭包与外部函数获取的其他元素无关。