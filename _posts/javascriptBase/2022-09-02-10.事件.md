---
title: 10. 事件
author: "Ana-Ana"
date: 2022-09-02
tags: [javascriptBase]
categories: ["JavaScript","Event"]
render_with_liquid: true
layout: post
pin: true
---

- JavaScript 与 HTML 交互通过 **事件** 实现；代表文档`document` 或 浏览器窗口中某个意义的时刻
- **监听器** ，订阅事件（处理程序） 监听事件发生时执行
- **触发事件以测试：**`dispatchEvent()`

### 事件流

​	事件流描述了页面接受事件的顺序

- IE 支持事件冒泡流
  - IE事件流被称为**事件冒泡**
  - 事件从最具体的元素（文档树中最深的节点）开始出发，然后向上传播到没有那么具体的元素（Document）
  - IE5.5及早期版本跳过`<html>` (`<body> -> <document>`)
- Netscape Comuunicator 支持事件捕获流
  - **事件捕获**：为在事件达到最终目标前拦截事件（新版本浏览器都支持事件捕获，但旧版本不支持）
  - 最不具体的节点最先收到事件，而具体的节点最后收到事件；
  - 从`window`对象开始捕获对象，`DOM2 Events`从`document`开始
- DOM 事件流
  - DOM2 Events 规定事件分为三个阶段；事件捕获、到达目标、事件冒泡
  - IE9 之后的浏览器都支持DOM事件流，但会在捕获阶段在事件目标上触发事件 —— 事件目标有两个时机处理事件。

### 事件处理程序

​	为响应事件而调用的函数被称为 **事件处理程序（事件监听器）**，名字常以`on`开头，集合多个处理程序名称以`handle`结尾

#### HTML 

​	属性值是JavaScript代码，需要经过转义的情况下使用HTML语法字符

```html
<input type="button" value="点击按钮触发事件" onclick="console.log('Clicked!')"/>

<!-- 转义 添加空格 -->
<input type="button" value="点击按钮触发事件" onclick="console.log('&quote;Clicked!&quote;')"/>

<!-- 调用其他地方脚本 -->
<input type="button" value="点击按钮触发事件" onclick="showMessage()"/>
```

  💬 调用外部脚本`showMessage`，存在以下**特殊的局部变量**：

1. 特殊局部变量 `event`对象
2. `this`值相当于事件的目标元素
3. 扩展作用域链：`document` 和 元素自身成员

  💬 在 HTML 中指定事件处理程序，存在以下问题：

1. 作用域扩展在不同浏览器中可以导致不同结果，范围无限定的对象可能导致错误

2. 调用时机：元素生成在前，监听器定义在后，用户已经交互过，不会触发监听器，会发生错误；

   为此，HTML 事件处理程序会封装到`try/catch`块中，使这种情况静默失败 —— 捕获在先，元素响应在后

```html
<input type="button" value="点击按钮触发事件" onclick="try{
                                                    showMessage();
                                                   } catch(ex){}                                              
                                               "/>
```

#### DOM0

​	将一个函数赋值给（DOM元素的）一个事件处理程序的属性 —— JavaScript指定之前必须先取得操作对象的引用

​	在运行之后才会给事件处理程序赋值，**注册在事件流的冒泡阶段**

```javascript
let btn = document.getElementById('myBtn'); 
btn.onclick = function(){ 	// 函数被视为元素的方法，在元素作用域中运行；this = 元素
    console.log('Clicked!')
}
// 将属性值设置为null，移除DOM0方式添加的事件处理程序
btn.onclick = null;
```

#### DOM2

​	提供两个方法处理程序：**新增 `addEventListener()` 移除`removeEventListener`**，暴露在所有DOM节点上。

​	接受三个参数：事件名（`click`）、事件处理函数、布尔值（`false` 默认值，冒泡阶段调用；`true` 捕获阶段调用）

​	使用`addEventListener`添加的监视器，必须使用`removeEventListener`并传入添加时相同参数来移除 —— 匿名函数无法移除。

​	主要优势：**可以为同一个事件添加多个事件处理程序**，**顺序触发。**

​	<u>事件处理程序通常会被添加到事件流的冒泡阶段（主要原因是跨浏览器兼容性好），注册到捕获阶段参与于事件到达指定目标之前拦截。</u>

#### IE

​	提供两个方法处理程序：**新增  `attachEvent` 移除 `detachEvent`**，暴露在所有DOM节点上。

​	接受两个参数：事件名（`on`+ `click`）、事件处理函数 —— IE8及之前只支持事件冒泡，所有会添加到事件冒泡阶段。

​	使用 `attachEvent`添加的监视器，必须使用`detachEvent`并传入添加时相同参数来移除、或传入监视器引用—— 匿名函数无法移除。

​	与`DOM0`区别在于：`this = window`，程序在全局作用域中运行；

​	同`DOM2`同样**可以为同一个事件添加多个事件处理程序**，**顺序方向触发**

#### 跨浏览器事件处理程序

```javascript
var EventUtil = {
    addHandler: function(element, type, handler){
        if(element.addEventListener){ // DOM2
            element.addEventListener(type, handler, false)
        }else if(element.attachEvent){ // IE
            element.attachEvent('on'+type, handler)
       	}else{ // DOM0
            element['on'+type] = handler;
        }
    },
    removeHandler: function(element, type, handler){
        if(element.removeEventListener){ // DOM2
            element.removeEventListener(type, handler, false)
        }else if(element.delactEvent){ // IE
            element.delactEvent('on'+type, handler)
       	}else{ // DOM0
            element['on'+type] = null;
        }
    },
}
```

❗ 依然未解决以下问题：

1. IE的作用域问题
2. 多个事件处理程序顺序问题
3. DOM0 只支持一次添加一个事件处理程序

### 事件对象

​	事件发生时，所有相关信息会存储在`event`对象中。包含：事件元素、事件类型、可能与特点事件相关的任何其他数据。

#### DOM 事件对象

​	在DOM中（无论是`DOM0` 或 `DOM2`），`event`对象是传递给事件处理程序的唯一参数。

​	`event`对象只在事件处理程序执行期间存在，执行完毕就销毁。包含以下公有的属性和方法：

1. **target 相关的属性**

​	在事件处理程序内部，`this = currentTarget`，而`target`只包含事件实际目标。

​	如果处理程添加到了意图的目标，则`this = currentTarget = target`

![event公有属性.drawio](../assets/img/JavaScriptBase.assets/event公有属性.drawio.png)

2. **阻止默认动作**

​	`preventDefault()` 用于阻止特定事件的默认动作，且不影响事件后续传播；前提是其对象的`cancelable = true`（允许取消）

​	`stopPropagation()` 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获**和**冒泡。

3. **`eventPhase` 属性**可以确定事件流当前所处的阶段：

- 1 —— 事件在捕获阶段被调用

- 2 —— 事件在目标上被调用

- 3 —— 事件在冒泡阶段被调用

#### IE 事件对象

​	IE中的事件对象`event`是基于事件处理程序被指定的方式以不同方式访问。

```javascript
// DOM0方式指定，event对象是window对象的一个属性。
var btn = document.getElementById('myBtn');
btn.onclick = function(){
	let event = window.event; // event.type = 'click'
    this === event.srcElement; // true 运行在函数内部
}

// IE 方式指定，event对象仍然是window对象的属性
var btn = document.getElementById('myBtn');
btn.attachEvent('onclick',function(event){
    event.type; // 'click'
    this === event.srcElement; // false 运行在全局作用域下
})
```

```html
<!-- HTML 方式指定，同样可以使用event对象访问 -->
<input type="button" value="点击触发事件" onclick="console.log(event.type)"/> 
```

1. **this的指向问题**

   事件处理程序的作用域取决于指定的方式，所以`this`值并不总是等于事件目标。在IE事件对象中存在一个属性`srcElement`，只读，指向事件目标（同`DOM`中的`target`）可以代替`this`。

2. **阻止默认动作**

​	`returnValue = false` 等同于 `DOM`中的`preventDefault()`，取消事件默认行为。

​	`	cancelButton = true` 属性阻止事件冒泡（IE 中只有冒泡）。

​	`stopPropagation()` 用以立即阻止事件流在DOM结构的传播，取消后续事件的捕获**和**冒泡。

#### 跨浏览器事件对象

```javascript
var EventUtil = {
    // addHandler() 
    getEvent: function(event){
        return event? event : window.event;
    },
    getTarget: function(event){
        return event.target || event.srcElement;
    },
    preventDefault: function(event){
        if(event.preventDefault) event.preventDefault();
        else	event.returnValue = false;
    },
    // removeHandler()
}
```

### 内存和性能

​	在JavaScript中，页面的处理程序数量与页面整体性能相关。 

​	:one: 每个处理程序都是一个对象，都占用内存空间；

​	:two: 处理程序需要访问`DOM`次数造成页面交互延长； 

​	:three: 不正当清理处理程序，会导致DOM元素被引用次数过多而无法释放内存。

#### 事件委托

​	给所有元素的 **共同父节点添加一个事件处理程序，**利用冒泡向上传递的性质，根据传入的事件类型决定执行的处理程序。

​	👍随时可用。只有页面渲染出可以交互的元素，可以无延迟起作用（无需要等待`DOMContentLoaded`和`load`事件）

​	👍节省引用、代码数量。减少整个页面需要的内存，提供性能。

#### 删除事件处理程序

​	直接删除带有事件处理程序的元素，因为存在着元素的引用和程序的引用，所以不会被垃圾收集程序正常清理。

```javascript
// 正确处理：
let btn = document.getElementById('myBtn');
btn.onclick = funciton(){
    //
    btn.onclick = null; // 删除事件处理程序
    document.getElementById('myDiv').innerHTML = '父节点替换掉按钮的内容'
}
```

​	页面卸载后，事件处理程序没有被清理，则仍然会驻留在内存中；随着页面每次加载、卸载，越来越占用内存。应该在 `onunload` 之前，删除事件处理程序；在`onload` 事件处理程序中做了什么，就应该在 `onunload`事件处理程序中恢复。