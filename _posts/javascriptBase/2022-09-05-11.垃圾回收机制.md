---
title: 11. 垃圾回收机制
author: "Ana-Ana"
date: 2022-09-05
tags: [javascriptBase]
categories: ["JavaScript","Object"]
render_with_liquid: true
layout: post
pin: true
---

- 回收对象 —— 当一个变量没有被其他变量或属性引用的时候
  - 全局变量 ：持续到浏览器页面关闭
  - 局部变量 ：函数执行结束后

### 数据存储 

- 基本数据类型 —— 栈

- 引用数据类型 —— 堆，在栈中存储实际对象引用

  当引用数据类型引用目标改变时，旧的栈实际对象失去引用，这变成需要回收的垃圾

1. ### 两种常用方法

   ​	垃圾回收并不是实时的，因为开销比较大，所以垃圾回收器会周期性的释放程序中已经不在被引用的垃圾对象。浏览器常使用到两种标准策略：标记清理、引用计数

   #### 1. 标记清除法（大部分浏览器） Mark-Sweep 

   两个阶段：

   1. 标记：从根节点遍历，给每个可访问的对象打上标记，表示对象可达

      <p style="color:#ccc">（标记打法可以是维护俩个“在不在上下文”的堆栈；也可以是活跃时反转某一位，不活跃时恢复）</p>

   2. 清除：在没有可用分块空间时（或某个固定频率），对堆内存遍历，回收没有标记的对象（清除无引用对象）

   优点：实现简单

   缺点：内存过于碎片化（标记-整理法）；分配速度慢（遍历）

   优化方案：**标记-整理法  Mark-Compact **

   ​	清除时对堆内存遍历时，先将被引用的对象移动到一起，然后再清理

   #### 2. 引用计数法 Reference counting

   ​	追踪每个变量被引用的次数，当引用为0时回收；（回收效率高）：

   - 赋值给引用值时，引用数 +1；
   - 保存引用的变量被覆盖了，引用数 -1

   缺点：a 计数器的增减处理频繁，会导致空间的使用效率降低。

      b **循环引用**无法收回，导致内存泄漏。

   **3. 循环引用**

   在IE9之前，涉及到COM对象（组件对象模型，Component Object Model），就无法避免 <u>循环引用</u> 的问题：

   - BOM 和 DOM 中对象是C++实现的COM对象，使用 <u>引用计数</u> 实现垃圾回收。即使引擎使用 <u>标志清理</u>，设计到COM对象依然可能形成循环引用，即使在页面中删除DOM元素内存也一样。

   ```js
   let element = document.getElementById('one'); // com对象
   let obj = new Object() // 原生obj对象
   obj.element = element;
   element.obj = obj;
   
   // 避免：确保两者没有联系
   obj.element = null;
   element.obj = null;
   ```

   在IE9之后，BOM 和 DOM 对象都变成了JavaScript对象，避免了循环引用问题，及常见的内存泄露问题。

   ### 分代式垃圾回收机制

   - 新生代：对象存活时间短，通常支持 1~8M 
   - 老生代：对象存储 存活时间长、常驻内存的对象

   两个内存区域回收频率不同，V8才有两个垃圾回收器管控：

   ![新老生代视图](../assets/img/JavaScriptBase.assets/新老生代视图.png)

   #### 新生代垃圾回收

   ​	Cheney算法，将堆内存分为两个区（semispace 半空间）：一个使用状态的空间我们称为**使用区**（From 空间）。一个处于闲置状态的空间称为**空闲区**（To 空间）

   ##### 垃圾回收机制——翻转 （Scavenge）

   - 先对使用区中的活动做标记
   - 标记完成后，将使用区的<u>活动对象</u>复制进空闲区并进行排序
   - 将原先使用区对象占用的空间释放
   - 最后进行角色互换，把空闲区变为使用区，使用区变为空闲区


   缺点：由于只能使用堆内存的一半，所以<u>不适用大规模</u>的垃圾回收机制中，是典型的牺牲空间换时间的算法。 —— 新生代内存空间较小、生命周期短（活对象少）

   ##### 并行回收

   Javascript是一门单线程语言，它是运行在主线程上的，而在进行垃圾回收的时候就会阻塞Javascript脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，这种行为叫全停顿。

   那当GC时间过长就会造成页面卡顿问题。

   那一个人干活慢，n个人一起速度便会是一个人的n倍。程序也一样，我们可以通过

   并行回收机制：引入多个辅助线程来同时处理
   新生代对象空间就采用并行策略。在垃圾回收过程中，

   启动多个线程来负责新生代中的垃圾清理，这些线程同时将对象空间中的数据移到空22

   由于这个过程中数据地址会发生改变，所以还需要同步更新引用这些对象的指针。

   ##### 新生代何时会到老生代

      1. 多次复制后依然存活的对象，可以认为是生命周期教强的对象，移到老生代管理
      2. 复制一个对象在空闲区时，占用空闲区空间的25%，则移到老生代管理 —— 当完成Scavenge回收，空间区变为使用区，会继续参与内存分配，比重过大影响后续内存分配

   #### 老生代垃圾回收

   ​	老生代数据大多是存活的对象，不需要时常更新，可以使用 <u>标记清收法</u> 回收。在V8中使用 **标记整理法** 解决标记清除后产生的大量内存碎片。

   ##### 增量标记 （incremental marking）

   ​	代替 并行策略的全停顿式 的垃圾回收，节省清除较大对象的老生代的时间问题

   - 一次GC分成多步小GC标记，让JS和小GC标记交替执行，直到标记完成。
   - 应用逻辑执行一会，垃圾回收与应用逻辑交替执行直到标记阶段完成

   >存在问题：
   >
   >​	小GC标记执行完后是如何暂停执行JS任务？—— 三色标记法
   >
   >​	如何进行下一次小GC 标记？—— 惰性清理
   >
   >​	如果执行JS任务时刚被标记好的对象引用又被修改了该当如何？ —— 写屏障

   ##### 三色标记法

   - 黑色表示对象自身及对象的引用都被标记（已检查状态）
   - 白色表示未被标记的对象（初始状态）
   - 灰色表示自身被标记，自身的引用未被标记（待检查状态）

   执行流程：

      1. 初始所有对象都是白色
      2. 从root对象开始、标记为灰色，并推入标记工作表中；
      3. 当收集器从标记工作表中弹出对象，并访问它所有引用对象时，自身灰色就会变换成黑色
      4. 将自身的下一个引用对象标志为灰色

   一直执行，直到<u>没有可以被标记为灰色</u>的对象，剩下的白色对象都是不可达的，进入清除阶段；

   恢复时，从灰色标记对象开始执行

   ##### 写屏障

   目的：

   - 解决黑色对象在程序执行中被新添加引用
   - 已经标记黑色的被引用对象不再被引用了

   写屏障就有了以下两个变化：

   ​	1. 不对已标记的黑色对象做处理，因为在之后的GC中也会被清理。

      2. Write-barrier 机制强制不变黑的对象指向白色对象。
         - 这个也被称作<u>强三色不变性</u>。所以
         - 一旦有黑色对象引用白色对象，该机制会强制将引用的白色对象改为灰色
         - 从而保证下一次增量 GC 标记阶段可以正确标记

   ##### 惰性清理 （lazy sweeping）

   ​	增量标记完后，如果当前内存足以支持代码的快速运行，也没必要立即清理，可让程序先运行，也无需一次性清理完所有垃圾对象，可以按需清理直到所有垃圾对象清理完后再继续增量标记。

   ### V8 script 隐藏类

   [JS 性能优化 ----- V8 隐藏类](https://zhuanlan.zhihu.com/p/591353951?utm_id=0)

   ​	“一次性声明”：避免生成不同的隐藏类，“先创建再补充”式动态属性赋值，并在构造函数中<u>一次性声明所有属性</u>

   ​	“置空不删除”：动态删除属性和新增属性一样，使得同一个构造函数出来的实例不再共享隐藏类。最佳方案是 `= null`

   ### 优化程序回收，提高性能

      1. 手动回收（不建议）：`window.ColloectGarbage()`（IE）、`window.opera.collect()`（opera7以上）立即启动垃圾回收；
      2. 解除引用：将不需要的数据设置为null，释放其引用，在下次回收时释放内存。
               1. 使用 <u>块级作用域</u> ，尽早让垃圾回收程序介入。