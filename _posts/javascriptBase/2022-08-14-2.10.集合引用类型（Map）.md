---
title: 2.10.集合引用类型（Map） 
author: Ana-Ana
date: 2022-08-14
tags: [javascriptBase]
categories: ["JavaScript","引用类型"]
render_with_liquid: true
layout: post
pin: true
---
### Map & WeakMap

不同于Set、对象，Map元素键值对可以为对象、字符串、函数、数字等，但必须是可迭代的数据类型

#### 定义

```javascript
const m = new Map() // 空映射，可用const定义

// 同时初始化实例，需要传入一个可迭代对象——包含键值对的数组
// 每个键值对按顺序插入到新映射实例中
let map = new Map([
    [function(){},"李四"],
    [{},"王五"],
    [1,"吴六"]
]);
console.log(map); // Map(3)
```

```javascript
// 使用自定义函数初始化
const map2 = new Map({
    [Symbol.iterator]: function*() {
        yield ['key1','value1'];
        yield ['key2','value2'];
        yield ['key3','value3'];
    }
})
console.log(mep2.size); // 3
```

#### 增删改查

```javascript
const map = new Map([['firstName','matter'],['lastName','petter']]);

// 新增值,返回Map对象,可以链式定义
map.set("name","张三").set('age',10)

// 查询值 
// 1. 通过键查找: map.has(key)
map.has('firstName'); // true
map.has('matter'); //false
// 2. 返回所有键
map.keys();
// 3. 返回所有值
map.values();
// 4. 返回所有键值对
map.entries();

// 查询个数
map.size() // 3

// 删除
// 1. delete(key) 是否成功删除 
map.delet('firstName'); // ture
map.delet('firstName'); // false
// 2. clear() 全删,无返回值
map.clear(); // undefined map.size=0
```

#### 循环

`Map` 实例会维护插入顺序，提供一个迭代器（Iznterator）生成 `[key, value]`形式的数组。

可以使用`entries()` / `Symbol.iterator` 获得这个迭代器。

因为 `entries()` 是默认迭代器，所以可以调用 <u>展开操作符</u>，将Map对象转换为数组对象

- `for`循环

```javascript
for(const [key,value] of map.entries()){
    console.log(value,key);
}

for(const pair of map[Symbol.iterator]){
    console.log(pair);
}

map.entries() === map[Symbol.iteratror] // true
```

- `forEach`循环      

```JavaScript
map.forEache((value,key) => {
    console.log(value,key);
},this)
```

#### 修改值 

​	—— 键是引用类型时，修改内部数据不影响映射的值

```javascript
// 键为字符串时，修改无效
const strMap = ([
    ['key1','val1']
])
for (let key of strMap.keys()){
    key = 'newKey';
    console.log(key); // newKey
    console.log('newKey'); // undefined
    console.log(strMap.get('key1')); // val1
}
```

```javascript
// 键为对象属性时，内部映射依然引用相同的地址
const objKey = {id:1};
const objMap([
    [objKey,'val2']
])

for (let key of objKey.keys()){
    key.id = 'newKey';
    console.log(key); // {id:"newKey"}
    console.log(objKey.get(objKey)); // 'val2'
}
```

#### 转换

- 数组 `...map` 或者 `[... map]`

- 利用数组过滤器 

  `[... map].filter(item => {return item[1].include("111")} )` // item[1] 指键名

- 转换回map类型 

#### 与`Object`相比的优势

1. 内存占用（多存储）：在给定固定内存大小里，Map 可以比 Object 多存储 50% 的键值对
2. 插入性能（快）：消耗大致相当
3. 查找速度（性能差异小）：Object 在类数组使用的情况下，更快
4. 删除性能
   - 删除 `object`  只能使用 <u>伪删除对象属性的操作</u>， 值设置为undefined 或者 null
   - 删除 `map` ，delete() 操作比插入和查找更快 

使用场景

- ​	表单提交前，检查某些元素的状态，当返回值是false时，阻止提交并跳出弹窗

```js
function post(){
    let map = new Map();
    let inputs = document.querySelectorAll("[error]");
    inputs.forEach(item => {
        map.set(item,{
            error:item.getAttribute("error"),
            status:item.checked
        })
    })
}
return [...map].every(([elem,config])=>{
    config.status || alert(config.error); // 或 短路运算
    // 已勾选status=true，退出判断；
    // 否则，未勾选status=false，执行第二个语句，跳出弹窗
    return config.status;
})
```


#### weakMap

键只能是 `Object` 或者 Object类型，其他非对象设置为键会抛出 TypeError； 值的设置没有限制

```javascript
// 初始化 是一个全有全无的操作
const wm = new WeakMap([
    [key1, 'val1'], [key2, 'val2'], ['errkey', 'val3'] // 'errkey' 将导致初始化失败
])

// 但可以先把原始值包装成对象再作为键
const objStr = new String('errKey');
wm.set(objStr, 'val3')

// weakMap 拥有于 Map 相似的方法；但没有 clear() —— 随时都可以被销毁
```

1. **弱键**： 键不属于正式引用，不会阻止垃圾回收； 值的引用，属于正式引用，影响垃圾回收
   只要存在键值对于映射中，并当作对值的引用，值就不会被垃圾回收。
2. **不可迭代键**：不能在不知对象引用的情况下从弱映射中获得值。
   之所以限制 只能用Object 作为键，是为了保证通过 <u>键对象引用（内存唯一值）</u>才能取得值

#### 使用weakMap

##### 私有变量

私有变量存储在弱映射中，以对象实例为键，以私有成员为值

```javascript
const User = (() => {
    const wm = new WeakMap(); // 闭包内的wakMap 不暴露在外，统一实例才使用同一个weakMap
    // 且生存时间与实例同步，而不是与类同步
    class User {
        // ...
        setPrivate(property, value){
            const privaterMembers = wm.get(this) || {}; // 获取当前实例
            privaterMembers[property] = value; // weakMap 新增键值对
            wm.set(this, privaterMembers); // 返回weakMap
        }
        getPrivate(property) {
			return wm.get(this)[property]
        }
        // ...
    };
    return User;
})();
// cosnt User = ()()

const user = new User('张三');
user.getPrivate(id);
```

不使用闭包，直接定义 class，外部可以通过对象实例的引用获得私有变量

```javascript
// wm 在 外部定义，使用同一个weakmap，可以通过实例获取
wm.get(user)[user.getPrivate];
```

但也是代码完全陷入ES6之前的 <u>闭包私有变量模式</u>

##### 操作DOM元素对象

```html
<div name="1">11</div>
<div name="2">22</div>
```

使用 `Map` 关联元数据：

```js
let map = new Map();
// 对应DOM中每个div元素对象，存入Map中，后续不需要操作DOM直接操作Map
document.querySelectorAll("div").forEach(item =>{
    map.set(item,{
        content1:item.getAttribute("name"),
        content2:item.innerHTML
    })
})
// map:Map(2) [[Entries]] 0:{div=> Object}
// 0:{key:div, value: {content:"1",content2:"11"}}
console.log(map);
map.forEach((config, elem)=>{
    // map.item --
        // this:undefined
        // config:{content1:"1", content2:"11"}
        // elem: div
    elem.addEventListener("click", ()=>{
        alert(config.content1)
    })
})
```

​	存在问题： 当关联的元数据从DOM树删除后，其值依然被 Map实例 引用而不能删除，所以对应的DOM节点依然滞留在内存中，除非明确销毁

​	使用弱映射是，代码执行完毕 weakmap 被回收，没有实例引用DOM节点，这其从DOM树删除后就可以立即释放内存

```javascript
let wm = new WeakMap();
const fistDIV = document.querySelector('div');
wm.set(firstDIV,{disable: true});
firstDIV.remove()
```