---
title: 5. 运输层
author: Ana-Ana
date: 2022-06-16
tags: [computerNetwork]
categories: ["计算机网络"]
render_with_liquid: true
layout: post
---
<!-- ## 运输层 -->

​	主机到主机的通信：物理层 + 数据链路层 + 网络层

​	主机进程间的通信：传输层

​	如果为运行在不同主机的 **应用进程的逻辑通信提供直接通信服务**，又称为端到端协议（端口）

​	向上层隐藏下面的网络服务核心细节，提供两种不同的运输协议

- 面向连接的TCP
- 面向无连接UDP

### 端口号

​	进程标识符PID，不同OS、不同进程的表示格式不同，使用统一的方法对TCP/IP体系的应用进程标识

​	16bit表示，取值范围0~65535；

- 熟知端口号：0~1023；FTP 21/20; HTTP 80; DNS 53

- 登记端口号：1024~49151；必须登记手续

- 短暂端口号：49152~65535；动态端口号

  【端口号只具有本地意义】不同OS、不同进程的端口号之间没有联系

1. 复用：多个线程利用一个 <u>IP+端口</u> 发送信息称为 复用；
2. 分用：多个线程利用一个 <u>IP+端口</u> 接收信息成为 分用；

### UDP

​	User Datagram Protocol 用户数据报协议

- 无连接的 — 支持单播、多播以及广播
- 面向应用报文：
  - 以报文为单位
  - 对应用层传输下来的报文既不合并也不拆分，保留报文的边界
- 不可靠服务
  - 运输层、网际层都是向上提供无连接、不可靠的传输服务
  - 当报文出现误码、丢失时，接收方仅丢弃而什么都不做
- 适用于IP电话、视频会议、直播等实时应用

#### 数据报格式

​	首部（仅8字节） + 数据部分

<img src="../assets/img/计算机网络.assets/UDP数据报首部格式.png" alt="UDP数据报首部格式" style="zoom: 33%;" />

### TCP

​	Transmission Control Protocol 传输控制协议

- 面向连接（逻辑上的连接，物理上仍然是无连接）— 仅支持单播
- 面向数据流：
  - 传送字节流
  - 不保证一次传完、只保证传输数据一致；
  - 要求应用层有能力处理乱序字节流、多次传输的数据流拼接完整还原
- 可靠的服务
  - 网际层可能出现传输差错，但TCP可以使其差错重传
  - 不会出现传输差错

#### 数据报格式

![TCP数据报格式](../assets/img/计算机网络.assets/TCP数据报格式.png){: width="972" height="589" .w-75 .normal}

- 源端口、目的端口：
  - 各16bit，用于识别发送、接受该TCP报文段的应用进程
  - 源端口：填写暂时端口号（？
  - 目的端口：填写该应用的熟知端口号（？
- 序号：
  - 32bit，增加到最后一个后又从0开始
  - 指出本TCP报文段数据载荷的第一个字节序号
- 确认号：
  - 32bit，增加到最后一个后又从0开始
  - 指出希望收到下一个数据载荷的第一个字节的序号；对之前收到的数据进行确认，收到数据的最后一个字节号+1
  - **！**需要搭配 <u>标志位 ACK<u>使用：
    - ACK=1时才有效，ACK=0时无效
    - TCP规定，在建立连接后TCP报文段必须把 ACK=1
- 数据偏移：
  - 4bit，以4字节为单位
  - 指出 数据载荷的起始 距离 TCP报文段的起始 处有多远
  - 指出TCP报文的首部长度
    - 首部固定长度为20字节，数据偏移量min = (0101) ~2~ = 5*4
    - 首部最大长度为60字节，数据偏移量max = (1111) ~2~ = 15*4
- 窗口：
  - 16bit，以字节为单位
  - 指出 <u>发送本报文段的一方</u> 的接受窗口
  - 根据接收方的接受能力 控制 发送方的发送能力，即流量控制
  - 接收方 让 发送方 设置其发送窗口的依据之一：[拥塞窗口，接受窗口]~min~
- 校验和
  - 16bit，检查 TCP报文段的首部 + 数据载荷 两个部分
  - 校验方式与UDP一样
- 标识符
  - SYN：建立连接的同步符
  - FIN：释放连接的终止符
  - RST：复位TCP连接
    - 表示连接出现异常，必须释放后重新建立连接
    - 拒绝非法报文段 、 拒绝打开一个TCP连接
  - PSH：推动标志位，该报文尽快推送上交应用进程，而不必等待接收缓存填满再上传
  - URG：紧急标志位，搭配 <u>紧急指针</u>使用
    - URG=1，紧急指针有效；URG=0，紧急指针无效
    - 发送方有紧急数据时，可插队到发送缓存的最前面，并立即封装一个TCP段发送
    - 紧急指针：数据载荷有多长的紧急数据，紧急数据之后的普通数据
    - 接收方根据紧急指针取出紧急数据，直接上交应用进程，而不必等待接收缓存填满再上传
- 选项（可选）
  - 最大报文段长度MSS选项：TCP报文的数据载荷最大长度
  - 窗口扩大选项：为扩大窗口（提高吞吐率）
  - 时间戳选项：
    - 计算往返时间RTT
    - 处理序号超范围情况，又称为凡是序号绕回PAWS
  - 选择确认选项
- 填充：使整个首部长度能被4整除，数据偏移字段以4字节为单位

#### 连接控制

​	TCP面向连接，三个阶段

1. 建立连接（三次握手）
2. 数据传送
3. 释放连接（四次挥手）

##### 三次握手 --- 连接

1. 解决问题：
   1. 确知对方的存在，协商参数（窗口值max，是否使用时间戳选项一级服务质量等）
   2. 双方对运输实体资源（缓存大小、连接表中的项目）进行分配
2. 双方先建立`传输控制块`：
   1. TCP连接表
   2. 指针：发送和缓存的、重传队伍的
   3. 当前发送和接受的序号
3. 服务器等待客户端的连接，成为`被动打开连接`
4. 客户端主动发起的连接，称为`主动打开连接`

--------------------------------------

1. 三次握手：

   在不可靠网络信道中建立可靠的连接

   - **你听见我在说话了吗？**（客户端发送`SYN=1,seq=x`，进入`SYN-SENT`同步已发送状态）	

     （SYN=1：不允许携带数据，但要消耗一个序号；seq=x：客户端进程所选择的初始序号；）

   - **我听见了，你能听见我在说话吗？**（服务端回复`SYN=1,ACK=1,seq=y,ack=x+1`,进入`SYN-RCVD`同步已接收状态）

     （SYN=1,ACK=1：TCP连接请求确认报文，不允许携带数据，但要消耗一个序号；）

     （seq=y：服务器进程所选择的初始序号；ack=x+1：对客户端初始序号确认）

   - **我听见了你在说话了**（客户端回复`ACK=1,seq=x+1,ack=y+1`，进入establish连接已建立状态）

     （ACK =1：普通的确认报文；seq=x+1：请求连接报文已消耗掉一个序号；ack=y+1：对服务器初始序号的确认）

     （TCP规定：普通的确认报文段可以携带数据，如不携带则不消耗序号；则下一个报文序号仍为`x+1`）

   - 双方开始通话（服务器收到确认报文，也进入establish链接已建立状态）

2. 为什么不使用两次握手？

   防止已经出错的请求报文突然又传给服务器，而引起的错误

   - 你听到我在说话了吗？（客户端第一次发送SYN，滞留或丢失）
   
   - 无回复

	- （客户端重新发送SYN包）你听到我在说话了吗？
	
	- 我听见了，<u>我们开始聊天吧！</u>（服务端正常收到，并回复SYN + ASK）
	
	  （二次握手成功，双方开始建立连接）
	
	- 第一次发送的SYN突然恢复，会出现两种情况
	
	  - 双方正在连接，此时服务端以为客户端请求新的连接，发送回复SYN + ASK建立两次握手后，进入等待数据状态；服务端建立两个连接，而客户端只认可一个连接，导致状态不一致。
	  - 双方已释放连接，服务器以为客户端重新请求连接，发送回复SYN + ASK建立两次握手后，而进入等待数据状态；客户端无连接请求，将不会回复数据。
##### 四次挥手 -- 释放

1. 服务器等待客户端的释放，成为`被动关闭`
2. 客户端主动发起的释放，称为`主动关闭`

-----------------------------------------------
1. **我客户端说完了，要撤咯**（客户端发送`FIN=1,ACK=1,seq=u,ack=v`，进入`FIN-WAIT-1`终止等待状态）

   （FIN=1：即使不携带一个数据，也要消耗一个序号）

   （seq=u：客户端最后已发送的最后一个字节序号+1；ack=v：客户端最后已收到的最后一个字节序号+1）

2. **知道了，我服务端还有话要说点**（服务器发送确认报文`ACK=1,seq=v,ack=u+1`，进入CLOSE-WAIT关闭等待状态）

   （普通的确认报文段， 服务器通知服务器进程关闭链接；）

   （seq=v：服务器最后已发送的最后一个字节序号+1；ack=u+1：服务器最后已收到的最后一个字节序号+1）

   （客户端收到报文，进入`FIN-WAIT-2`终止等待状态）

   （两端的应用进程方向连接释放，进入 **半关闭状态**：客户进程无话要说，服务器进程可能有话要说，客户仍要开放接收）

3. **我服务端讲完了，听见没啊？**（服务器发送`FIN=1,ACK=1,seq=w,ack=u+1`，并进入`LAST-ACK`最后确认状态）

   （FIN=1,ACK=1：TCP连接释放报文，seq=w：半关闭状态下可能发送的数据序号，ack=u+1：对收到的报文进行重复确认）

4. **嗯嗯，听到你说的话了，等你先挂电话**（客户端发送`ACK=1,seq=u+1,ack=w+1`，并进入`TIME-WAIT`超时等待状态）

   （普通的确认报文段，seq=u+1：客户端之前已发送的序号，fin消耗掉一个序号；ack=w+1：客户端收到的序号确认）

   （服务器收到报文，立即关闭连接，进入`closed`关闭状态）

5. （客户端超时等待结束，关闭连接）

-----------------------------------------
**超时等待状态**

1. 为确保服务器端已收到ACK包；时间=2MSL，最长报文段寿命的两倍（一个来回）
2. ACK丢包！服务器会重新发送`FIN`包： **喂？喂？喂！**
   1. 客户端在超时等待中可捕获到这个包，而重新第四次挥手
   2. 立即断开连接，客户端无法捕获这个`FIN`包，没有第四次成功挥手，将会使得服务器一直处于连接状态

**保活计时器**

​	【情景】客户端出现故障。服务端不会再收到信息，如果及时发现对方已下线？

- 服务器维护一个 保活计时器
- 客户端 → 服务器，服务器就重启保活计时器（2h）
- 保活计时器到时候，服务器 → 客户端发送 探测报文段；之后的75s/次，一连10次仍然没有响应，关闭连接

##### 数据确认

为解决丢包、乱序问题

1. 为每一个连接建立 发送缓冲区，建立连接后的第一个字节序列号为0，此后序列号 + 1

2. 发送报文格式：取其数据序列号 + 长度 + 数据内容

3. 确认报文格式：ACK = 序列号 + 长度 = 下一包起始序列号

   （可以连续发送多个发送报文，接收端只需回复一次ACK就可以）

   （收到ACK确认报文，发送端可将已接受字段删除）

4. 切割发送：根据序列号+长度重组 = 数据内容

5. 丢失重发：ACK = 丢失报文的序列号

   【全双工：以上过程部区分客户端、服务端】

#### 流量控制

​	Flow Control, 让发送方的发生效率不要太快，让接收方 <u>来得及</u> 接受；

##### 滑动窗口

​	依靠滑动窗口实现 可靠传输

1. 发送窗口和接受窗口并不重视一样大
   1. 网络传输窗口值有一定的滞后
   2. 发送方可根据自身情况修改发送窗口
2. 不按序到达的数据，TCP无明确规定
   1. 接收方一律丢弃，管理简单但浪费资源，发送方需要重复发送数据
   2. 接收方暂存到接受窗口，等待数据齐全后，交付给上层的应用进程
3. 接收方必须有 <u>累计确认</u> 和 <u>捎带确认</u> 机制
   1. 捎带确认：可以在有数据发送的时候，吧确认信息捎带
   2. 不应该过分推迟确认：每隔一个报文段就发送一个确认
   3. 不经常发送，因为很少要求经常同时向两个方向发送
4. TCP通信是全双工通信

【举例】每个报文可携带`100`字节数据，将要发送的数据编号后以`100`为单位分割

- 建立TCP连接时，`接收方B`告诉`发送方A`：我的接收窗口为400

   （A的发送窗口设置为400，在未收到B的`确认`，可将落入发送窗口的全部数据一直发送出去）

- `发送A`发送1~100字节数据，`seq=1,DATA`，还能发送300

- `发送A`发送101~200字节数据，`seq=101,DATA`，还能发送200

- `发送A`发送201~300字节数据，`seq=201,DATA(丢失)`，还能发送100

- `接受B`对`1~200`字节数据`累计确认`，并将接收窗口设置为300，`ACK=1,ack=201,rwnd=300`

   （ACK确认标志符，ack确认了n字节数之前的数据，rwnd重置的窗口的大小。）

   （:number1: B对A进行 <u>流量控制</u>）

   （A向前滑动发送窗口，到ack确认的字节数后`201`；调整发送窗口的大小`=300`；丢弃发送缓存中已被确认接收的数据`1~200`）

   （201~300字节已发送但没有收到确认，重传计时器开始计时）

- `发送A`发送301~400字节数据，`seq=301,DATA`，还能发送100

- `发送A`发送401~500字节数据，`seq=401,DATA`，还能发送0，不能再发送新数据

   （重传计数器到点，开始重传旧数据；300窗口为丢失数据保留一个100发送，但不能再发送新数据了）

- `发送A`发送201~300字节数据，`seq=201,DATA`，还能发送300

- `接受B`对`201~500`字节数据`累计确认`，并将接收窗口设置为100，`ACK=1，ack=501，rwnd=100`

   （:number2: B对A进行 <u>流量控制</u>）

   （A向前滑动发送窗口，到ack确认的字节数后`501`；调整发送窗口的大小`=100`；丢弃发送缓存中已被确认接收的数据`201~500`）

- `发送A`发送501~600字节数据，`seq=501,DATA`，还能发送0，不能再发送新数据

- `接受B`对`600之前的`字节数据`累计确认`，并将接收窗口设置为100，`ACK=1，ack=601，rwnd=0`

   （:number3: B对A进行 <u>流量控制</u>）

   （A向前滑动发送窗口，到ack确认的字节数后`601`；调整发送窗口的大小`=0`；丢弃发送缓存中已被确认接收的数据`501~600`）

【窗口为0的确认】

1. 当B接收缓存有了一些存储空间，于是发送`我要调整窗口为300`，但丢失了！

   形成死锁：主机A等待B的非零窗口通知；主机B等待A的数据报文

2. A主动发送`零窗口探测报文`，携带1字节数据，询问接收方

3. 每次A接收到`0窗口报文`后，启动`持续计时器`，超时时主动询问

4. B收到`零窗口探测报文`，需回复确认报文，并告知现在的窗口大小，`ACK=1,rwnd=300`

   B接受缓存已满，可以不接受一般报文，但必须接受紧急报文、确认报文和零窗口探测报文



##### 拥塞控制

###### 慢启动、拥塞避免

- 拥塞窗口cwnd：
  - 值取决于 <u>网络拥塞程度</u>，并动态变化
  - 维护原则：
    - 网络未出现拥塞，cwnd值就大一些；
    - 网络一旦出现拥塞，cwnd值就小一些；
  - 发送方的发送窗口swnd = cwnd
- 网络拥塞的依据：没有按时收到应当到达的确认报文（发送超时重传）
- 两种控制的应用：慢开始门限 ssthresh
  - cwnd < ssthresh，拥塞窗口 < 慢开始门限 ---- 使用慢开始算法（cwnd × 2）
  - cwnd > ssthresh，拥塞窗口 > 慢开始门限 ---- 停止使用慢开始，而使用拥塞算法（cwnd + 1）
  - cwnd = ssthresh，拥塞窗口 = 慢开始门限 ---- 可使用慢开始，也可使用拥塞算法
- 维护一个 慢开始门限 ssthresh
  - 设置一个初始值
  - 每次发生网络拥塞时
    - 拥塞窗口值cwnd / 2 = ssthresh
    - cwnd重置为初始值，并开始慢开始

###### 快速重传、快速恢复

- 不是所有的报文丢失由于网络拥塞导致的，当超时重传时判断是否为 网络拥塞
  - 是网络拥塞，使用拥塞算法
  - 不是网络拥塞，开启快重传、快恢复
- 快速重传：
  -  要求接收方每次收到报文，都要对其及时确认
    - 若收到失序的报文，对失序报文重复确认（确认报文只能确认**最高序号**）
    - 同时保留失序的报文
  - 发送方接受三次重复的报文确认
    - 网络未拥塞
    - 一至两次重复确认，可能报文滞留在网络某处
    - 三次确认可认为报文丢失，重发报文
- 快速恢复：
  - 启用快重传后，抛弃慢启动，使用快速恢复
  - ssthresh = cwmd / 2
  - cwmd = ssthresh
  - 拥塞避免算法

#### 超时重传

超时时间选择

​	超时重传的时间ORT 应该略小于 一个报文段往返时间RTTO

- 过短：不必要的重传，网络拥塞
- 过长：不必要的等待，网络闲置
- **略？**：经过不同速率的网络、不同数量的路由等等因素

**加权平均往返时间 RTTs -- -- 平滑的往返时间**：多次测量的RTT样本加权平均

```
加权平均往返时间 RTTs
	初始化：RTTs = RTT1
	新的RTTs1 = （1 - α）× RTTs1 + α × 新的RTT样本（0 <= α < 1，α=1/8=0.125）
RTT偏差的加权平均RTTd
	初始化：RTTD = RTT1 ÷ 2
	新的RTTD = （1 - β ）× RTTD1 + β × |RTTs1 - 新的RTT样本| （0 <= β < 1，β=1/4=0.25）
超时重传时间 RTO
	RTP = RTTs + 4 × RTTd
```

- RTT的测量准确与否非常重要

  - RTT的测量有难度：

    - 数据报文段丢失后重发。距离收到确认报文的时间，是第一次报文还是第二次报文？
    - 数据未收到确认而重发。距离收到确认报文的时间，是第一次报文还是第二次报文？

  - Karn算法：只要报文重传，就不采用其RTT样本，RTO也不会重新计算

    （若报文时延突然增大且持续很久，RTO内不会收到确认报文，于是重发，而不更新RTO，将一直重发）

  - 修正Karn算法：报文重传，就把RTO增大一些（× 2）
