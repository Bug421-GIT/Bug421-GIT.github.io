---
title: 专用工作者线程
author: "Ana-Ana"
date: 2024-01-26
tags: ["javascriptThread","Thread"]
categories: ["javascriptThread"]
render_with_liquid: true
layout: post
pin: true
---
### 专用工作者线程

​	用以执行页面主线程之外的其他任务，如发生网络请求、执行文件输入/输出、密集的计算、处理大量的数据，通过与父页面交换消息，完成不适合在主线程执行的任务。（不能直接操作页面DOM元素）又被称为 **后台脚本**（background script），由初始化线程时提供的脚本控制线程的各个方面，包括生命周期、代码路径、输入输出。

```javascript
// main.js
location.href; // "https://...com/"
const worker = new Worker(location.href + 'backgroudScript.js');  // worker是工作者线程与主线程通信的连接点
```

​	`new Worker()` 参数必须是一个脚本文件，专用工作者线程只能被生成它的脚本所使用。

​	初始化工作者线程是需要时间的（初始化延迟），且完全独立于`main.js`； 相对应的`worker`线程可能还不存在，但在`main.js`中的`Worker`对象已经可以使用了，返回`Worker {}`；信息发送给初始化状态的工作者线程，会先加入队列，等线程进入活跃状态，再把消息传入线程的消息队列。

​	**工作者线程不受主线程（document）内容的安全策略限制**，因为工作者线程于父文档处于不同的上下文中运行；但如果线程加载的脚本带有全局唯一标识符时，就会受到文档内容安全策略的限制。



#### Worker 对象

​	`new Worker('url')` 返回的实例，与新创建的工作者线程通信的连接点，用于与父上下文传递信息（`portMessage`）、捕获工作线程发出的事件（`onMessage`）在终止工作者线程之前，实例不会被垃圾回收，也不能通过编程方式恢复对之前Work对象的引用。

​	**workers 和主线程间的数据传递通过这样的消息机制进行——双方都使用 `postMessage()` 方法发送各自的消息，使用 `onmessage` 事件处理函数来响应消息**

**处理程序**。可以通过`worker.addEventLister('on + type',handler)` 添加监视器处理

| 程序关键词       | 触发类型                     | 原因                 |
| ---------------- | ---------------------------- | -------------------- |
| `onerror`        | `ErrorEvent`类型的错误事件   | 线程抛出错误         |
| `onmessage`      | `MessageEvent`类型的消息事件 | 向父级上下文发送消息 |
| `onmessageerror` | `MessageEvent`类型的错误事件 | 无法反序列化的消息   |

**方法**

​	🎈`postMessage(message, targetOrigin, [transfer])`：通过异步消息事件，向工作者线程发生消息

​			🎱 message，需要传递的信息（可以是对象、数组等）无需自己序列化

​			🎱 targetOrigin，指定哪些窗口能接收到消息事件，字符串"*"（表示无限制，不建议依赖使用）或者一个 URI

​			🎱 transfer，是一串和 message 同时传递的 `Transferable` 对象。这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。

​			 监听分发的 message： data（传递过来的对象），<u>origin（发送方的origin信息），source（发送方窗口对象的引用） 可以用来检查消息的发送者的身份</u>

​	🎈`terminate()`：**立即**终止工作者进程，没有清理机会，脚步突然停止；锁定消息队列。

#### DedicatedWorkerGlobalScope

​	全局作用域是 `DedicatedWorkerGlobalScope` 的实例，因其继承自`WorkerGlobalScope`，所以包含其内部所有属性和方法。可以通过 **self关键字** 访问全局作用域。

​	与父类不同的属性和方法：

​	🎈`name`：可选，`Worker`实例的字符串标识符

​	🎈`close()`： 与主线程上的`worker.terminate()`对应

​	🎈`importScripts()`： 引入任意数量的脚本

#### 生命周期

​	非正式地分为三个状态：初始化（`initializing`）、活动（`active`）、终止（`terminated`），对于其他上下文是不可见的。

​	创建之后，专用工作者线程伴随着 **页面整个生命期而存在。**即使线程执行完毕，其环境仍然会存在，与之关联的`Worker`对象就不会被回收。

​	关闭线程：

- `close()`：:one: 取消事件循环中的所有任务，并阻止继续添加新任务； :two: 不停止已经存在的同步任务。
- `terminate`： 线程的消息队列被清理并锁住，立即停止且没有清理的机会。

```javascript
// 主线程
worker.terminate();

// Worker 线程
self.close();
```

​	在整生命周期中，专用工作者线程只关联一个页面——只要页面存在，专用线程就会存在；页面离开，与页面关联的工作者线程标志为终止，且执行立即停止。

#### 通信

​	**异步、消息**完成通信

##### `postMessage()` —— 临时通信

##### `MessageChannel()` —— 专用通信

​	Channel Messaging API 的 **`MessageChannel`** 接口允许我们创建一个新的消息通道，并通过它的两个 [`MessagePort`](https://developer.mozilla.org/zh-CN/docs/Web/API/MessagePort) 属性发送数据。`MessageChannel`实例有个**<u>两个只读属性</u>，`MessageChannel.port1` & `MessageChannel.port2`**，就像电话的两端，使用其中一个端口发送信息，另个端口的监视事件就可以接收到数据。

需要借助 `postMessage()`建立的临时链接 分派端口给子工作者线程。

> 其他妙用：
>
> ​	管道通信 —— [MessageChannel用法总结 - 全玉 - 博客园 (cnblogs.com)](https://www.cnblogs.com/mengff/p/12818522.html)
>
> ​	其他框架使用场景 —— [浅谈MessageChannel - 掘金 (juejin.cn)](https://juejin.cn/post/7029715697173266469#heading-3)

```javascript
// main.js
const { port1, port2 } = new MessageChannel();
const workerA = new Worker('./scriptA.js')
const workerB = new Worker('./scriptB.js')

// 1. 需要把端口发送给工作者线程中，建立两者的链接
workerA.postMessage('connect',[port1]);
workerB.postMessage('connect',[port2]);

// 2. 控制两个工作者线程传递消息
workerA.postMessage('sending')
workerB.postMessage('sending')
```

```javascript
// scriptA.js
let port;
self.onmessage = (e)=>{
    switch (e.data){
        case 'connect':
            port = e.ports[0]
          	break;
       	case 'listening'
            port.onmessage = (event) => {console.log(`workerA get the msg from workerB`)}
            break;
        case 'sending':
            port.postMessage = ('listening') // port1 只能向 port2 传递消息	
            break;
    }
}
```

##### `BroadcastChannel()` —— 广播通信

​	同源脚本可以通过`BroadcastChannael`互相发送、接收信息，如广播通信，需要有实体监听信道才能获得处理。且考虑初始化工作者线程延迟，应该使用计时器延后处理。

```javascript
// main.js
const channel = new BroadcastChannel('worker_channel');
const worker = new Worker('./Worker.js');

channel.onmessage = ({data}) => {
    console.log(`heard ${data} on page`);
}
// 延时，等工作者线程初始化完成
setTimeout(() => channel.postMessage('foo'), 1000 );
```

```javascript
// Worker.js
const channel = new BroadcastChannel('worker_channel');

self.onmessage = ({data}) => {
    console.log(`heard ${data} in worker`);
    channel.postMessage('bar'), 1000 );
}
```

#### 数据传输 

​	不同线程处于不同的上下文中，它们之间的数据传输会尝试销毁。转移信息的方式有三种：结构化克隆算法（ structured clone algorithm）、可移动对象（transferable object）、共享数组缓冲区（shared array buffers）

##### 结构化克隆算法

​	在浏览器后台实现，不可以显式调用。通过`postMessage()`传递对象时，浏览器遍历该对象，并在目标上下文中生成一个副本（深拷贝），支持除了`Symbol`之外的所有原型类型。

​	注意点：

1. 可以识别对象包含的循环引用，不会无穷遍历对象
2. 克隆`error`对象、`Function`对象、`DOM`节点会抛出错误
3. 并不总数创建完全一直的副本，对象属性描述符、`get() set()`、原型链、`RegExp.prototype.lastIndex`属性不会复制

##### 可移动对象

​	把所有权从一个上下文转移到另一个上下文，适用于在不太可能大量复制数据的情况下。

​	`postMessage()` 的第二个可选参数是数组，指定转移哪些对象。浏览器遍历消息负载时，根据这个数据检查对象引用，移动而不是复制它们。

```javascript
// main.js
const worker = new Worker('./worker.js')
const arrayBuffer = new ArrayBuffer(32); // 主线程申请32位的数组缓冲区

// 第一种，常规化克隆算法
worker.postMessage(arrayBuffer);
arrayBuffer.byteLength; // 32, 主线程依然留有

// 第二种，可移动对象
worker.postMessage(arrayBuffer, [arrayBuffer]);
arrayBuffer.byteLength; // 0
```

```javascript
// worker.js
self.onmessage = ({data}) => {
    console.log(arrayBuffer.byteLength;); // 32
}
```

​	`worker.postMessage({foo:{bar:arrayBuffer}}, [arrayBuffer]);` 嵌套在对象内部可移动对象，包装对象被复制、嵌套对象被转移

##### 共享数组缓冲区

​	`SharedArrayBuffer`作为`ArrayBuffer`能够在不同浏览器上下文间共享，在使用`postMessage`时只会传递原始缓冲区的引用 —— 多个上下文（并行线程）分别维护同一个内存块，存在资源争用的风险。可以使用`Atomics`对象，让工作者线程获得`SharedArrayBuffer`实例的锁：`Atomics.add(view, view下标, argument)`，在执行完成全部读写操作后，才允许下一个线程执行操作。

```javascript
// main.js
const workers = [] // 线程池
for(let i = 0; i<4; ++i){
    workers.push(new Worker('./worker.js'));
}
let responseCount = 0; // 获取计算结果
for(const worker of workers){
    worker.onmessage = () =>{
		if(++responseCount === workers.lenght){
        	console.log(`Final buffer value: ${ view[0] }`)
         }
    }
}
const shareArrayBuffer = new SharedArrayBuffer(4); // 初始化`SharedArrayBuffer`
const view = new Uint32Array(SharedArrayBuffer);   // 创建`SharedArrayBuffer`视图
view[0] = 1;
for(const worker of workers){
    woker.portMessage(SharedArrayBuffer);
}

// Final buffer value: 400001
```

```javascript
// worker.js
self.onmessage = ({data} => {
	const view = new Uint32Array(data);
    // 执行100万次操作
    for(let i = 0; i < 1E6; ++i){
		// view[0] += 1;  可能产生脏读
        Atomice(view, 0, 1);
    }
})
```

#### 线程池

​	使用固定数量的线程活动，根据线程状态空闲与否分配任务。线程在执行任务时，会被标记为忙碌状态，直至通知线程池空闲时，才会被安排新的工作。这些活动线程被称为“线程池”。

​	`navigator.hardware Concurrency`属性返回 <u>系统可用的核心数量</u>，最好以此作为线程池大小的上限。

​	线程策略：每个线程执行相同的任务，但具体执行什么任务由参数个数控制。线程执行耗时计算后返回结果，线程池在将其他工作分配给线程执行。

eg：

​	定义`TaskWorker`类：跟踪线程是否正忙于工作、管理进出线程的信息和事件。

```javascript
class TaskWorker extends Worker{
    constructor(notifyAvailable, ...workerArgs){
        super(...workerArges);
        
        this.available = false;
        this.resolve = false;
        this.reject = false;
        
        this.notifyAvailable = notifyAvailable; // 空闲时，向线程池发送信号，以分配任务
        this.onmessage = () => this.setAvailable(); // 线程完成初始化时，向线程池发送信息
    }
    dispatch({resoleve, reject, postMessageArgs}){
        this.available = false;
        this.onmessage = ({data}) => {
            resolve(data);
            this.setAvailable();
        }
        this.onerror //... 调用 reject()、setAvailable()
        this.postMessageArgs(...postMessageArgs);
    }
    setAvailable(){ // 初始化线程，通知线程池
        this.available = false;
        this.resolve = false;
        this.reject = false;
        this.notifyAvailable();         
    }
}
```

​	定义`workerPool`类，使用`TaskWorker`类：管理未执行的任务队列，并负责关闭线程

```javascript
class WorkerPool {
    constructor(poolSize, ...workerArgs){
        this.taskQueue = [];
        this.workers = [];
        // 初始化线程池
        for(let i = 0; i < poolSize; ++i){
            this.workers.push(
                // 将可分配的线程推入数组
            	new TaskWorker(() => this.dispatchIfAvaliable(), ...workerArgs);
            )
        }
        // 初始化任务队列
        enqueue(...postMessagee){
            return new Promise((resolve, reject) => {
                this.taskQueue.push({resolve, reject});
                this.dispatchIfAvaliable();
            })
        }
        // 将任务分配给线程
        dispatchIfAvaliable(){
            if(!this.taskQueue.lenght) return; // 没有可以用的线程
            for(const worker of this.workers){
                if(worker.avaliable){
                    let a = this.taskQueue.shift();
                    worker.dispatch(a);
                    break;
                }
            }
        }
        // 终止所有工作者线程
        close(){
            for(const worker of this.workers){
                worker.terminate();
            }
        }
    }
}
```

​	使用案例： 计算1000万个浮点数之和

```javascript
// worker.js
self.onmessage = ({data}) => {
    let sum = 0;
    let view = new Float32Array(data.arrayButter);
    
    for(let i = data.arrayButter; i<data.endIdx; ++i){
        sum += view[1];
    }
    self.postMessage('ready');
}
```

```javascript
// main.js
const totalFloats = 1E8; //1000万
const numTasks = 20; // 20个任务
const floatPerTask = totalFloats / numberTasks; // 每个线程计算数
const numWorker = 4; // 4个线程
// 创建线程池
const pool = new WorkerPool(num, './worker.js');
// 填充浮点数
let arrayBuffer = new ShareArrayBuffer(4 * totalFloats);
let view = new Float32Array(data.arrayButter);
for(let i = 0; i < totalFloats; i++){
    view[i] = Math.random();
}
let partialsumPromises = [];
for(let i = 0; i< totalFloats; i += floatPerTask){
    partialSumPromises.push( // 维护一个promise队列
    	pool.enqueue({ // 添加进线程池任务队列
            startIdx: i,
            endIdx: i + floatPerTask,
            arrayBuffer
        })
    )
}
// 等待promise队列全部任务结束
Promise.all(partialSumPromises)
	.then(partialSum => partialSum.reduce((prev,cur) => prev + cur))
	.then(finalSum => console.log(finalSum))
```