---
title: 共享工作者线程
author: "Ana-Ana"
date: 2024-01-29
tags: ["javascriptThread","Thread"]
categories: ["javascriptThread"]
render_with_liquid: true
layout: post
pin: true
---
### 共享工作者线程

​	`ShareWorker`被多个可信任的执行上下文访问，消息接口外部和内部接口与`Worker`有些不同。可以减少共享线程计算性消耗的情形，一个`ShareWorker`可以管理多个同源页面web Socket消息，或成为上下文之间的通信线程。

🎈	在行内脚本中创建的共享工作者线程始终是唯一的：只有标识不存在时，才会创建新线程；否则静默新建失败，且调用`connect`与已有线程建立连接。

​	**共享工作者线程的标识**：解析后的URL、工作者线程名称、文档源

```javascript
new ShareWorker('./worker.js',{name:'foo'})
new ShareWorker('https://www.example.com/worker.js',{name:'foo'})
```

🎈	`ShareWorker.port`：特殊属性，专门用来与共享线程通信的Message

🎈	`ShareWorker.cennect`： 事件

​	`worker.port.onmessage` & `worker.port.start()` 与共享线程建立连接时触发；

​	包括`MessagePort`实例的`port`数组，可以用于把消息发回父上下文

🎈	**共享工作者线程的生命周期**： 只要还有一个上下文连接就会持续存在。

​	当线程连接数为0时（关联的所有页面被销毁且没有连接），线程被终止；没有办法以编程的方式终止它 —— 不存在` ShareWorker.teminate()`

​	共享线程端口上调用`close()`时，只要还有一个端口连接，就不会真正终止线程。

#### 连接到共享工作者线程

​	每次调用`ShareWorker.construct`时，无论是否创建新线程，都会触发`cennect`事件，隐式创建`MessageChannel`实例并将所有权给`ShareWorker`实例，这个`MessageChannel`实例保存在`connect`事件对象的`ports`数组中。

​	没有任何事件可以断开与`ShareWorker`实例的连接。随着页面加入和退出连接，`connectPorts`集合会受到死端口的影响。一个方法是在页面注销前`beforeunlode`事情时，明确发送卸载消息，让共享线程有机会清除死端口。