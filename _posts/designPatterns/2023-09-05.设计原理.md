---
title: 设计原理
author: "Ana-Ana"
date: 2023-09-05
tags: [DesignPatterns]
categories: ["DesignPatterns"]
render_with_liquid: true
layout: post
pin: true
---

# 设计原理

1. 将可能需要变化的部分独立出来，不与不需要变化的混在一起

   - 需要变化的作为接口
   - 不需要的变化的作为超类 abstract

2. 针对接口编程，而不是针对实现编程

   - 超类不负责接口的实现，而是交给其他专门实现接口的类实现

3. 多用组合，少用继承

4. 依赖抽象类，不要依赖具体类 —— 依赖倒置原则

   - 不能让高层组件依赖底层组件
   - 高层组件：由N个底层组件定义其行为的类
   - 应该在OO设计中避免这些情况：尽量符合，或有足够理由违背
     - 变量不可以持有具体类的引用
     - 不要让类派生自具体类（面向抽象）
     - 不要覆盖基类中已实现的方法（如果需要被覆盖的方法，说明并不适用于所有情况，需要被提取作为所有子类共享）

5. "最少知识"原则：只和密友谈话

   - 在任何对象内部只应该调用：
     1. 对象本身 `this`（其返回结果）
     2. 被当做方法参数传入的对象（其返回结果）
     3. 当前方法创建、实例化的任何对象（其返回结果）
     4. 对象的任何组件（引用的任何对象）
   - 使用“最少知识”原则，可能需要更过的“包装”类被制造出来，以处理和其他组件的沟通 
     - 复杂性↑ 开发时间↑
     - 系统性能↓ 维护成本↓

6. “好莱坞”原则：别调用我们，我们会调用你（**创建框架和组件**）

   - 防止依赖腐败： 环状依赖

     - 高层依赖底层，底层又依赖高层
     - 高层依赖侧边，侧边又依赖底层

     ![依赖腐败](E:\13种设计模式.assets\依赖腐败.png)

     

   - 底层组将可以挂载在高层组件中参与计算，但不能直接调用高层组件

   - 高层组件决定什么时候、怎样使用底层组件

7. 单一责任：一个类应该只有一个引起变化的原因（**高内聚**）

   - 类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变区域
   - 尽量让每个类保持单一责任：当改变这个多责任类时，多方面都会受到影响
   - 例：内部迭代器不仅要完成管理某种聚合，还要完成遍历

# UMl 

[30分钟学会UML类图](https://zhuanlan.zhihu.com/p/109655171)

**修饰符表示：**
    “+”表示 public；
    “-”表示 private；
    “#”表示 protected；
    不带符号表示 default。

**抽象类表示：**
    抽象类的类名以及抽象方法的名字都用斜体字表示

**六种关系：**

1. 实现关系
   `implements` 实现类 → 接口，空心三角形 + 虚线
2. 泛化关系 Generalization
   `extends` A *is a* B： A → B， 空心三角形 + 实线
3. 关联关系 Association
   一个对象含有另一个对象的引用
   - 单向关联：只有一个对象可以调用另一个对象的公共属性和操作
     - 带箭头 + 实线
   - 双向关联：两个对象彼此可以调用对方的公共属性和操作
     - 双箭头 + 实线
   - 又分为依赖关联、聚合关联和组合关联
4. 依赖关系 Dependency（弱关联）
   A use a B：A → B，箭头 + 虚线
   代码中的表现形式：
   - B为A的构造器
   - 方法中的局部变量、方法或构造器的参数、方法的返回值，
   - A调用B的静态方法`static`
5. 聚合关系  Aggregation
   **"has a"**  整体和部分的关系是可以分离的
   - 整体和部分有各自的生命周期
   - 部分可以属于多个整体对象共享
6. 组合关系 Composition （强聚合）
   **"contains a"** 整体和部分是不可分离的
   - 整体的对象负责部分的对象的生命周期
   - 部分不能给其他整体共享